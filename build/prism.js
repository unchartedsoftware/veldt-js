(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.prism = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function() {

    'use strict';

    const Texture2D = require('./Texture2D');
    const ImageLoader = require('../util/ImageLoader');
    const Util = require('../util/Util');

    const MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    const MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    const WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    const TYPES = {
        UNSIGNED_BYTE: true,
        FLOAT: true
    };
    const FORMATS = {
        RGB: true,
        RGBA: true
    };

    /**
     * The default type for color textures.
     */
    const DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for color textures.
     */
    const DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for color textures.
     */
    const DEFAULT_WRAP = 'REPEAT';

    /**
     * The default min / mag filter for color textures.
     */
    const DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    const DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    const DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    const DEFAULT_INVERT_Y = true;

    /**
     * @class ColorTexture2D
     * @classdesc A texture class to represent a 2D color texture.
     * @augments Texture2D
     */
    class ColorTexture2D extends Texture2D {

        /**
         * Instantiates a ColorTexture2D object.
         *
         * @param {Object} spec - The specification arguments.
         * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} spec.image - The HTMLImageElement to buffer.
         * @param {String} spec.url - The HTMLImageElement URL to load and buffer.
         * @param {Uint8Array|Float32Array} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         * @param {Function} callback - The callback to be executed if the data is loaded asynchronously via a URL.
         */
        constructor(spec = {}, callback = null) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            spec.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            spec.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            spec.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            spec.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set other properties
            spec.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            spec.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            spec.premultiplyAlpha = spec.premultiplyAlpha !== undefined ? spec.premultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format
            spec.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            // buffer the texture based on argument type
            if (typeof spec.src === 'string') {
                // request source from url
                spec.type = 'UNSIGNED_BYTE';
                // call base constructor
                super(spec);
                // TODO: put extension handling for arraybuffer / image / video differentiation
                ImageLoader.load({
                    url: spec.src,
                    success: image => {
                        // set to unsigned byte type
                        image = Util.resizeCanvas(spec, image);
                        // now buffer
                        this.bufferData(image, spec.width, spec.height);
                        this.setParameters(this);
                        // execute callback
                        if (callback) {
                            callback(null, this);
                        }
                    },
                    error: err => {
                        if (callback) {
                            callback(err, null);
                        }
                    }
                });
            } else if (Util.isCanvasType(spec.src)) {
                // is image / canvas / video type
                // set to unsigned byte type
                spec.type = 'UNSIGNED_BYTE';
                spec.src = Util.resizeCanvas(spec, spec.src);
                // call base constructor
                super(spec);
            } else {
                // array, arraybuffer, or null
                if (spec.src === undefined || spec.src === null) {
                    // if no data is provided, assume this texture will be rendered
                    // to. In this case disable mipmapping, there is no need and it
                    // will only introduce very peculiar and difficult to discern
                    // rendering phenomena in which the texture 'transforms' at
                    // certain angles / distances to the mipmapped (empty) portions.
                    spec.mipMap = false;
                }
                // buffer from arg
                spec.type = TYPES[spec.type] ? spec.type : DEFAULT_TYPE;
                // call base constructor
                super(spec);
            }
        }
    }

    module.exports = ColorTexture2D;

}());

},{"../util/ImageLoader":16,"../util/Util":17,"./Texture2D":8}],2:[function(require,module,exports){
(function() {

    'use strict';

    const Texture2D = require('./Texture2D');

    const MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    const MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    const WRAP_MODES = {
        REPEAT: true,
        CLAMP_TO_EDGE: true,
        MIRRORED_REPEAT: true
    };
    const DEPTH_TYPES = {
        UNSIGNED_BYTE: true,
        UNSIGNED_SHORT: true,
        UNSIGNED_INT: true
    };
    const FORMATS = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * The default type for depth textures.
     */
    const DEFAULT_TYPE = 'UNSIGNED_INT';

    /**
     * The default format for depth textures.
     */
    const DEFAULT_FORMAT = 'DEPTH_COMPONENT';

    /**
     * The default wrap mode for depth textures.
     */
    const DEFAULT_WRAP = 'CLAMP_TO_EDGE';

    /**
     * The default min / mag filter for depth textures.
     */
    const DEFAULT_FILTER = 'LINEAR';

    /**
     * @class DepthTexture2D
     * @classdesc A texture class to represent a 2D depth texture.
     * @augments Texture2D
     */
    class DepthTexture2D extends Texture2D {

        /**
         * Instantiates a DepthTexture2D object.
         *
         * @param {Object} spec - The specification arguments.
         * @param {Uint8Array|Uint16Array|Uint32Array} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            spec.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            spec.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            spec.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            spec.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set mip-mapping and format
            spec.mipMap = false; // disable mip-mapping
            spec.invertY = false; // no need to invert-y
            spec.premultiplyAlpha = false; // no alpha to pre-multiply
            spec.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            // check if stencil-depth, or just depth
            if (spec.format === 'DEPTH_STENCIL') {
                spec.type = 'UNSIGNED_INT_24_8_WEBGL';
            } else {
                spec.type = DEPTH_TYPES[spec.type] ? spec.type : DEFAULT_TYPE;
            }
            // call base constructor
            super(spec);
        }
    }

    module.exports = DepthTexture2D;

}());

},{"./Texture2D":8}],3:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');

    const TYPES = {
        UNSIGNED_BYTE: true,
        UNSIGNED_SHORT: true,
        UNSIGNED_INT: true
    };
    const MODES = {
        POINTS: true,
        LINES: true,
        LINE_STRIP: true,
        LINE_LOOP: true,
        TRIANGLES: true,
        TRIANGLE_STRIP: true,
        TRIANGLE_FAN: true
    };
    const BYTES_PER_TYPE = {
        UNSIGNED_BYTE: 1,
        UNSIGNED_SHORT: 2,
        UNSIGNED_INT: 4
    };

    /**
     * The default component type.
     */
    const DEFAULT_TYPE = 'UNSIGNED_SHORT';

    /**
     * The default render mode (primitive type).
     */
    const DEFAULT_MODE = 'TRIANGLES';

    /**
     * The default byte offset to render from.
     */
    const DEFAULT_BYTE_OFFSET = 0;

    /**
     * The default count of indices to render.
     */
    const DEFAULT_COUNT = 0;

    /**
     * @class IndexBuffer
     * @classdesc An index buffer class to hole indexing information.
     */
    class IndexBuffer {

        /**
         * Instantiates an IndexBuffer object.
         *
         * @param {WebGLBuffer|Uint8Array|Uint16Array|Uin32Array|Array|Number} arg - The index data to buffer.
         * @param {Object} options - The rendering options.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byte offset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         */
        constructor(arg, options = {}) {
            this.gl = WebGLContext.get();
            this.buffer = null;
            this.type = TYPES[options.type] ? options.type : DEFAULT_TYPE;
            this.mode = MODES[options.mode] ? options.mode : DEFAULT_MODE;
            this.count = (options.count !== undefined) ? options.count : DEFAULT_COUNT;
            this.byteOffset = (options.byteOffset !== undefined) ? options.byteOffset : DEFAULT_BYTE_OFFSET;
            this.byteLength = 0;
            if (arg) {
                if (arg instanceof WebGLBuffer) {
                    // WebGLBuffer argument
                    if (options.byteLength === undefined) {
                        throw 'Argument of type WebGLBuffer` must be complimented with a corresponding `options.byteLength`';
                    }
                    this.byteLength = options.byteLength;
                    this.buffer = arg;
                } else if (Number.isInteger(arg)) {
                    // byte length argument
                    if (options.type === undefined) {
                        throw 'Argument of type `number` must be complimented with a corresponding `options.type`';
                    }
                    this.bufferData(arg);
                } else if (arg instanceof ArrayBuffer) {
                    // ArrayBuffer arg
                    if (options.type === undefined) {
                        throw 'Argument of type `ArrayBuffer` must be complimented with a corresponding `options.type`';
                    }
                    this.bufferData(arg);
                } else {
                    // Array or ArrayBufferView argument
                    this.bufferData(arg);
                }
            } else {
                if (options.type === undefined) {
                    throw 'Empty buffer must be complimented with a corresponding `options.type`';
                }
            }
        }

        /**
         * Upload index data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView|number} arg - The array of data to buffer.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        bufferData(arg) {
            const gl = this.gl;
            // cast array to ArrayBufferView based on provided type
            if (Array.isArray(arg)) {
                // check for type
                if (this.type === 'UNSIGNED_INT') {
                    // buffer to uint32
                    arg = new Uint32Array(arg);
                } else if (this.type === 'UNSIGNED_SHORT') {
                    // buffer to uint16
                    arg = new Uint16Array(arg);
                } else {
                    // buffer to uint8
                    arg = new Uint8Array(arg);
                }
            } else {
                // set ensure type corresponds to data
                if (arg instanceof Uint32Array) {
                    this.type = 'UNSIGNED_INT';
                } else if (arg instanceof Uint16Array) {
                    this.type = 'UNSIGNED_SHORT';
                } else if (arg instanceof Uint8Array) {
                    this.type = 'UNSIGNED_BYTE';
                } else if (
                    !(arg instanceof ArrayBuffer) &&
                    !(Number.isInteger(arg))
                    ) {
                    throw 'Argument must be of type `Array`, `ArrayBuffer`, `ArrayBufferView`, or `number`';
                }
            }
            // check that the type is supported by extension
            if (this.type === 'UNSIGNED_INT' &&
                !WebGLContext.checkExtension('OES_element_index_uint')) {
                throw 'Cannot create IndexBuffer of type `UNSIGNED_INT` as extension `OES_element_index_uint` is not supported';
            }
            // don't overwrite the count if it is already set
            if (this.count === DEFAULT_COUNT) {
                if (Number.isInteger(arg)) {
                    this.count = (arg / BYTES_PER_TYPE[this.type]);
                } else {
                    this.count = arg.length;
                }
            }
            // set byte length
            if (Number.isInteger(arg)) {
                this.byteLength = arg;
            } else {
                this.byteLength = arg.byteLength;
            }
            // create buffer if it doesn't exist already
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            // buffer the data
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arg, gl.STATIC_DRAW);
            return this;
        }

        /**
         * Upload partial index data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView} array - The array of data to buffer.
         * @param {Number} byteOffset - The byte offset at which to buffer.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        bufferSubData(array, byteOffset = DEFAULT_BYTE_OFFSET) {
            const gl = this.gl;
            if (!this.buffer) {
                throw 'Buffer has not yet been allocated, allocate with `bufferData`';
            }
            // cast array to ArrayBufferView based on provided type
            if (Array.isArray(array)) {
                // check for type
                if (this.type === 'UNSIGNED_INT') {
                    // buffer to uint32
                    array = new Uint32Array(array);
                } else if (this.type === 'UNSIGNED_SHORT') {
                    // buffer to uint16
                    array = new Uint16Array(array);
                } else {
                    // buffer to uint8
                    array = new Uint8Array(array);
                }
            } else if (
                !(array instanceof Uint8Array) &&
                !(array instanceof Uint16Array) &&
                !(array instanceof Uint32Array) &&
                !(array instanceof ArrayBuffer)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, or `ArrayBufferView`';
            }
            // check that we aren't overflowing the buffer
            if (byteOffset + array.byteLength > this.byteLength) {
                throw `Argument of length ${array.byteLength} bytes with ` +
                    `offset of ${byteOffset} bytes overflows the buffer ` +
                    `length of ${this.byteLength} bytes`;
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, byteOffset, array);
            return this;
        }

        /**
         * Execute the draw command for the bound buffer.
         *
         * @param {Object} options - The options to pass to 'drawElements'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byteOffset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         *
         * @return {IndexBuffer} The index buffer object, for chaining.
         */
        draw(options = {}) {
            const gl = this.gl;
            const mode = gl[options.mode || this.mode];
            const type = gl[this.type];
            const byteOffset = (options.byteOffset !== undefined) ? options.byteOffset : this.byteOffset;
            const count = (options.count !== undefined) ? options.count : this.count;
            if (count === 0) {
                throw 'Attempting to draw with a count of 0';
            }
            // bind buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            // draw elements
            gl.drawElements(mode, count, type, byteOffset);
            // no need to unbind
            return this;
        }
    }

    module.exports = IndexBuffer;

}());

},{"./WebGLContext":13}],4:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');

    const TEXTURE_TARGETS = {
        TEXTURE_2D: true,
        TEXTURE_CUBE_MAP: true
    };

    const DEPTH_FORMATS = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * @class RenderTarget
     * @classdesc A renderTarget class to allow rendering to textures.
     */
    class RenderTarget {

        /**
         * Instantiates a RenderTarget object.
         */
         constructor() {
            this.gl = WebGLContext.get();
            this.framebuffer = this.gl.createFramebuffer();
            this.textures = new Map();
        }

        /**
         * Binds the renderTarget object.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        bind() {
            // bind framebuffer
            const gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            return this;
        }

        /**
         * Unbinds the renderTarget object.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        unbind() {
            // unbind framebuffer
            const gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return this;
        }

        /**
         * Attaches the provided texture to the provided attachment location.
         *
         * @param {Texture2D} texture - The texture to attach.
         * @param {Number} index - The attachment index. (optional)
         * @param {String} target - The texture target type. (optional)
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        setColorTarget(texture, index, target) {
            const gl = this.gl;
            if (!texture) {
                throw 'Texture argument is missing';
            }
            if (TEXTURE_TARGETS[index] && target === undefined) {
                target = index;
                index = 0;
            }
            if (index === undefined) {
                index = 0;
            } else if (!Number.isInteger(index) || index < 0) {
                throw 'Texture color attachment index is invalid';
            }
            if (target && !TEXTURE_TARGETS[target]) {
                throw 'Texture target is invalid';
            }
            this.textures.set(`color_${index}`, texture);
            this.bind();
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                gl['COLOR_ATTACHMENT' + index],
                gl[target || 'TEXTURE_2D'],
                texture.texture,
                0);
            this.unbind();
            return this;
        }

        /**
         * Attaches the provided texture to the provided attachment location.
         *
         * @param {Texture2D} texture - The texture to attach.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        setDepthTarget(texture) {
            if (!texture) {
                throw 'Texture argument is missing';
            }
            if (!DEPTH_FORMATS[texture.format]) {
                throw 'Provided texture is not of format `DEPTH_COMPONENT` or `DEPTH_STENCIL`';
            }
            const gl = this.gl;
            this.textures.set('depth', texture);
            this.bind();
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,
                gl.DEPTH_ATTACHMENT,
                gl.TEXTURE_2D,
                texture.texture,
                0);
            this.unbind();
            return this;
        }

        /**
         * Resizes the renderTarget and all attached textures by the provided height and width.
         *
         * @param {Number} width - The new width of the renderTarget.
         * @param {Number} height - The new height of the renderTarget.
         *
         * @return {RenderTarget} The renderTarget object, for chaining.
         */
        resize(width, height) {
            if (typeof width !== 'number' || (width <= 0)) {
                throw `Provided \`width\` of ${width} is invalid`;
            }
            if (typeof height !== 'number' || (height <= 0)) {
                throw `Provided \`height\` of ${height} is invalid`;
            }
            this.textures.forEach(texture => {
                texture.resize(width, height);
            });
            return this;
        }
    }

    module.exports = RenderTarget;

}());

},{"./WebGLContext":13}],5:[function(require,module,exports){
(function() {

    'use strict';

    const VertexPackage = require('../core/VertexPackage');
    const VertexBuffer = require('../core/VertexBuffer');
    const IndexBuffer = require('../core/IndexBuffer');

    /**
     * Iterates over all vertex buffers and throws an exception if the counts
     * are not equal.
     * @private
     *
     * @param {Array} vertexBuffers - The array of vertexBuffers.
     */
    function checkVertexBufferCounts(vertexBuffers) {
        let count = null;
        vertexBuffers.forEach(buffer => {
            if (count === null) {
                count = buffer.count;
            } else {
                if (count !== buffer.count) {
                    throw `VertexBuffers must all have the same count to be ` +
                        `rendered without an IndexBuffer, mismatch of ` +
                        `${count} and ${buffer.count} found`;
                }
            }
        });
    }

    /**
     * Iterates over all attribute pointers and throws an exception if an index
     * occurs more than once.
     * @private
     *
     * @param {Array} vertexBuffers - The array of vertexBuffers.
     */
    function checkIndexCollisions(vertexBuffers) {
        const indices = new Map();
        vertexBuffers.forEach(buffer => {
            buffer.pointers.forEach((pointer, index) => {
                const count = indices.get(index) || 0;
                indices.set(index, count + 1);
            });
        });
        indices.forEach(index => {
            if (index > 1) {
                throw `More than one attribute pointer exists for index \`${index}\``;
            }
        });
    }

    /**
     * @class Renderable
     * @classdesc A container for one or more VertexBuffers and an optional IndexBuffer.
     */
    class Renderable {

        /**
         * Instantiates an Renderable object.
         *
         * @param {Object} spec - The renderable specification object.
         * @param {Array|Float32Array} spec.vertices - The vertices to interleave and buffer.
         * @param {VertexBuffer} spec.vertexBuffer - An existing vertex buffer.
         * @param {VertexBuffer[]} spec.vertexBuffers - Multiple existing vertex buffers.
         * @param {Array|Uint16Array|Uint32Array} spec.indices - The indices to buffer.
         * @param {IndexBuffer} spec.indexbuffer - An existing index buffer.
         */
        constructor(spec = {}) {
            if (spec.vertexBuffer || spec.vertexBuffers) {
                // use existing vertex buffer
                this.vertexBuffers = spec.vertexBuffers || [spec.vertexBuffer];
            } else if (spec.vertices) {
                // create vertex package
                const vertexPackage = new VertexPackage(spec.vertices);
                // create vertex buffer
                this.vertexBuffers = [
                    new VertexBuffer(vertexPackage)
                ];
            } else {
                this.vertexBuffers = [];
            }
            if (spec.indexBuffer) {
                // use existing index buffer
                this.indexBuffer = spec.indexBuffer;
            } else if (spec.indices) {
                // create index buffer
                this.indexBuffer = new IndexBuffer(spec.indices);
            } else {
                this.indexBuffer = null;
            }
            // if there is no index buffer, check that vertex buffers all have
            // the same count
            if (!this.indexBuffer) {
                checkVertexBufferCounts(this.vertexBuffers);
            }
            // check that no attribute indices clash
            checkIndexCollisions(this.vertexBuffers);
        }

        /**
         * Execute the draw command for the underlying buffers.
         *
         * @param {Object} options - The options to pass to 'drawElements'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.byteOffset - The byteOffset into the drawn buffer.
         * @param {String} options.indexOffset - The indexOffset into the drawn buffer.
         * @param {String} options.count - The number of vertices to draw.
         *
         * @return {Renderable} - The renderable object, for chaining.
         */
        draw(options = {}) {
            // draw the renderable
            if (this.indexBuffer) {
                // use index buffer to draw elements
                // bind vertex buffers and enable attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.bind();
                });
                // draw primitives using index buffer
                this.indexBuffer.draw(options);
                // disable attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.unbind();
                });
                // no advantage to unbinding as there is no stack used
            } else {
                // no index buffer, use draw arrays
                // set all attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.bind();
                });
                if (this.vertexBuffers.length > 0) {
                    // draw the buffer
                    this.vertexBuffers[0].draw(options);
                }
                // disable all attribute pointers
                this.vertexBuffers.forEach(vertexBuffer => {
                    vertexBuffer.unbind();
                });
            }
            return this;
        }
    }

    module.exports = Renderable;

}());

},{"../core/IndexBuffer":3,"../core/VertexBuffer":10,"../core/VertexPackage":11}],6:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');
    const ShaderParser = require('./ShaderParser');
    const Async = require('../util/Async');
    const XHRLoader = require('../util/XHRLoader');

    const UNIFORM_FUNCTIONS = {
        'bool': 'uniform1i',
        'bool[]': 'uniform1iv',
        'float': 'uniform1f',
        'float[]': 'uniform1fv',
        'int': 'uniform1i',
        'int[]': 'uniform1iv',
        'uint': 'uniform1i',
        'uint[]': 'uniform1iv',
        'vec2': 'uniform2fv',
        'vec2[]': 'uniform2fv',
        'ivec2': 'uniform2iv',
        'ivec2[]': 'uniform2iv',
        'vec3': 'uniform3fv',
        'vec3[]': 'uniform3fv',
        'ivec3': 'uniform3iv',
        'ivec3[]': 'uniform3iv',
        'vec4': 'uniform4fv',
        'vec4[]': 'uniform4fv',
        'ivec4': 'uniform4iv',
        'ivec4[]': 'uniform4iv',
        'mat2': 'uniformMatrix2fv',
        'mat2[]': 'uniformMatrix2fv',
        'mat3': 'uniformMatrix3fv',
        'mat3[]': 'uniformMatrix3fv',
        'mat4': 'uniformMatrix4fv',
        'mat4[]': 'uniformMatrix4fv',
        'sampler2D': 'uniform1i',
        'samplerCube': 'uniform1i'
    };

    /**
     * Given a map of existing attributes, find the lowest index that is not
     * already used. If the attribute ordering was already provided, use that
     * instead.
     * @private
     *
     * @param {Map} attributes - The existing attributes map.
     * @param {Object} declaration - The attribute declaration object.
     *
     * @return {Number} The attribute index.
     */
    function getAttributeIndex(attributes, declaration) {
        // check if attribute is already declared, if so, use that index
        if (attributes.has(declaration.name)) {
            return attributes.get(declaration.name).index;
        }
        // return next available index
        return attributes.size;
    }

    /**
     * Given vertex and fragment shader source, parses the declarations and appends information pertaining to the uniforms and attribtues declared.
     * @private
     *
     * @param {Shader} shader - The shader object.
     * @param {String} vertSource - The vertex shader source.
     * @param {String} fragSource - The fragment shader source.
     *
     * @return {Object} The attribute and uniform information.
     */
    function setAttributesAndUniforms(shader, vertSource, fragSource) {
        const declarations = ShaderParser.parseDeclarations(
            [vertSource, fragSource],
            ['uniform', 'attribute']);
        // for each declaration in the shader
        declarations.forEach(declaration => {
            // check if its an attribute or uniform
            if (declaration.qualifier === 'attribute') {
                // if attribute, store type and index
                const index = getAttributeIndex(shader.attributes, declaration);
                shader.attributes.set(declaration.name, {
                    type: declaration.type,
                    index: index
                });
            } else { // if (declaration.qualifier === 'uniform') {
                // if uniform, store type and buffer function name
                const type = declaration.type + (declaration.count > 1 ? '[]' : '');
                shader.uniforms.set(declaration.name, {
                    type: declaration.type,
                    func: UNIFORM_FUNCTIONS[type]
                });
            }
        });
    }

    /**
     * Given a shader source string and shader type, compiles the shader and returns the resulting WebGLShader object.
     * @private
     *
     * @param {WebGLRenderingContext} gl - The webgl rendering context.
     * @param {String} shaderSource - The shader source.
     * @param {String} type - The shader type.
     *
     * @return {WebGLShader} The compiled shader object.
     */
    function compileShader(gl, shaderSource, type) {
        const shader = gl.createShader(gl[type]);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw 'An error occurred compiling the shaders:\n' + gl.getShaderInfoLog(shader);
        }
        return shader;
    }

    /**
     * Binds the attribute locations for the Shader object.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     */
    function bindAttributeLocations(shader) {
        const gl = shader.gl;
        shader.attributes.forEach((attribute, name) => {
            // bind the attribute location
            gl.bindAttribLocation(
                shader.program,
                attribute.index,
                name);
        });
    }

    /**
     * Queries the webgl rendering context for the uniform locations.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     */
    function getUniformLocations(shader) {
        const gl = shader.gl;
        const uniforms = shader.uniforms;
        uniforms.forEach((uniform, name) => {
            // get the uniform location
            const location = gl.getUniformLocation(shader.program, name);
            // check if null, parse may detect uniform that is compiled out
            // due to a preprocessor evaluation.
            // TODO: fix parser so that it evaluates these correctly.
            if (location === null) {
                uniforms.delete(name);
            } else {
                uniform.location = location;
            }
        });
    }

    /**
     * Returns a function to load shader source from a url.
     * @private
     *
     * @param {String} url - The url to load the resource from.
     *
     * @return {Function} The function to load the shader source.
     */
    function loadShaderSource(url) {
        return function(done) {
            XHRLoader.load({
                url: url,
                responseType: 'text',
                success: function(res) {
                    done(null, res);
                },
                error: function(err) {
                    done(err, null);
                }
            });
        };
    }

    /**
     * Returns a function to pass through the shader source.
     * @private
     *
     * @param {String} source - The source of the shader.
     *
     * @return {Function} The function to pass through the shader source.
     */
    function passThroughSource(source) {
        return function(done) {
            done(null, source);
        };
    }

    /**
     * Returns a function that takes an array of GLSL source strings and URLs, and resolves them into and array of GLSL source.
     * @private
     *
     * @param {Array} sources - The shader sources.
     *
     * @return {Function} A function to resolve the shader sources.
     */
    function resolveSources(sources) {
        return function(done) {
            const tasks = [];
            sources = sources || [];
            sources = !Array.isArray(sources) ? [sources] : sources;
            sources.forEach(source => {
                if (ShaderParser.isGLSL(source)) {
                    tasks.push(passThroughSource(source));
                } else {
                    tasks.push(loadShaderSource(source));
                }
            });
            Async.parallel(tasks, done);
        };
    }

    /**
     * Creates the shader program object from source strings. This includes:
     *    1) Compiling and linking the shader program.
     *    2) Parsing shader source for attribute and uniform information.
     *    3) Binding attribute locations, by order of delcaration.
     *    4) Querying and storing uniform location.
     * @private
     *
     * @param {Shader} shader - The Shader object.
     * @param {Object} sources - A map containing sources under 'vert' and 'frag' attributes.
     *
     * @return {Shader} The shader object, for chaining.
     */
    function createProgram(shader, sources) {
        const gl = shader.gl;
        const common = sources.common.join('');
        const vert = sources.vert.join('');
        const frag = sources.frag.join('');
        // compile shaders
        const vertexShader = compileShader(gl, common + vert, 'VERTEX_SHADER');
        const fragmentShader = compileShader(gl, common + frag, 'FRAGMENT_SHADER');
        // parse source for attribute and uniforms
        setAttributesAndUniforms(shader, vert, frag);
        // create the shader program
        shader.program = gl.createProgram();
        // attach vertex and fragment shaders
        gl.attachShader(shader.program, vertexShader);
        gl.attachShader(shader.program, fragmentShader);
        // bind vertex attribute locations BEFORE linking
        bindAttributeLocations(shader);
        // link shader
        gl.linkProgram(shader.program);
        // If creating the shader program failed, alert
        if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
            throw 'An error occured linking the shader:\n' + gl.getProgramInfoLog(shader.program);
        }
        // get shader uniform locations
        getUniformLocations(shader);
    }

    /**
     * @class Shader
     * @classdesc A shader class to assist in compiling and linking webgl shaders, storing attribute and uniform locations, and buffering uniforms.
     */
    class Shader {

        /**
         * Instantiates a Shader object.
         *
         * @param {Object} spec - The shader specification object.
         * @param {String|String[]|Object} spec.common - Sources / URLs to be shared by both vertex and fragment shaders.
         * @param {String|String[]|Object} spec.vert - The vertex shader sources / URLs.
         * @param {String|String[]|Object} spec.frag - The fragment shader sources / URLs.
         * @param {String[]} spec.attributes - The attribute index orderings.
         * @param {Function} callback - The callback function to execute once the shader has been successfully compiled and linked.
         */
        constructor(spec = {}, callback = null) {
            // check source arguments
            if (!spec.vert) {
                throw 'Vertex shader argument `vert` has not been provided';
            }
            if (!spec.frag) {
                throw 'Fragment shader argument `frag` has not been provided';
            }
            this.program = 0;
            this.gl = WebGLContext.get();
            this.version = spec.version || '1.00';
            this.attributes = new Map();
            this.uniforms = new Map();
            // if attribute ordering is provided, use those indices
            if (spec.attributes) {
                spec.attributes.forEach((attr, index) => {
                    this.attributes.set(attr, {
                        index: index
                    });
                });
            }
            // create the shader
            Async.parallel({
                common: resolveSources(spec.common),
                vert: resolveSources(spec.vert),
                frag: resolveSources(spec.frag),
            }, (err, sources) => {
                if (err) {
                    if (callback) {
                        setTimeout(() => {
                            callback(err, null);
                        });
                    }
                    return;
                }
                // once all shader sources are loaded
                createProgram(this, sources);
                if (callback) {
                    setTimeout(() => {
                        callback(null, this);
                    });
                }
            });
        }

        /**
         * Binds the shader program for use.
         *
         * @return {Shader} The shader object, for chaining.
         */
        use() {
            // use the shader
            this.gl.useProgram(this.program);
            return this;
        }

        /**
         * Buffer a uniform value by name.
         *
         * @param {String} name - The uniform name in the shader source.
         * @param {*} value - The uniform value to buffer.
         *
         * @return {Shader} - The shader object, for chaining.
         */
        setUniform(name, value) {
            const uniform = this.uniforms.get(name);
            // ensure that the uniform spec exists for the name
            if (!uniform) {
                throw `No uniform found under name \`${name}\``;
            }
            // check value
            if (value === undefined || value === null) {
                // ensure that the uniform argument is defined
                throw `Value passed for uniform \`${name}\` is undefined or null`;
            }
            // set the uniform
            // NOTE: checking type by string comparison is faster than wrapping
            // the functions.
            if (uniform.type === 'mat2' || uniform.type === 'mat3' || uniform.type === 'mat4') {
                this.gl[uniform.func](uniform.location, false, value);
            } else {
                this.gl[uniform.func](uniform.location, value);
            }
            return this;
        }

        /**
         * Buffer a map of uniform values.
         *
         * @param {Object} uniforms - The map of uniforms keyed by name.
         *
         * @return {Shader} The shader object, for chaining.
         */
        setUniforms(args) {
            Object.keys(args).forEach(name => {
                this.setUniform(name, args[name]);
            });
            return this;
        }
    }

    module.exports = Shader;

}());

},{"../util/Async":15,"../util/XHRLoader":18,"./ShaderParser":7,"./WebGLContext":13}],7:[function(require,module,exports){
(function() {

    'use strict';

    const COMMENTS_REGEXP = /(\/\*([\s\S]*?)\*\/)|(\/\/(.*)$)/gm;
    const ENDLINE_REGEXP = /(\r\n|\n|\r)/gm;
    const WHITESPACE_REGEXP = /\s{2,}/g;
    const BRACKET_WHITESPACE_REGEXP = /(\s*)(\[)(\s*)(\d+)(\s*)(\])(\s*)/g;
    const NAME_COUNT_REGEXP = /([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?/;
    const PRECISION_REGEX = /\bprecision\s+\w+\s+\w+;/g;
    const INLINE_PRECISION_REGEX = /\b(highp|mediump|lowp)\s+/g;
    const GLSL_REGEXP = /void\s+main\s*\(\s*(void)*\s*\)\s*/mi;
    const PREP_REGEXP = /#([\W\w\s\d])(?:.*\\r?\n)*.*$/gm;

    /**
     * Removes standard comments from the provided string.
     * @private
     *
     * @param {String} str - The string to strip comments from.
     *
     * @return {String} The commentless string.
     */
    function stripComments(str) {
        // regex source: https://github.com/moagrius/stripcomments
        return str.replace(COMMENTS_REGEXP, '');
    }

    /**
     * Removes an precision statements.
     * @private
     *
     * @param {String} source - The unprocessed source code.
     *
     * @return {String} The processed source code.
     */
    function stripPrecision(source) {
        // remove global precision declarations
        source = source.replace(PRECISION_REGEX, '');
        // remove inline precision declarations
        return source.replace(INLINE_PRECISION_REGEX, '');
    }

    /**
     * Converts all whitespace into a single ' ' space character.
     * @private
     *
     * @param {String} str - The string to normalize whitespace from.
     *
     * @return {String} The normalized string.
     */
    function normalizeWhitespace(str) {
        return str.replace(ENDLINE_REGEXP, ' ') // remove line endings
            .replace(WHITESPACE_REGEXP, ' ') // normalize whitespace to single ' '
            .replace(BRACKET_WHITESPACE_REGEXP, '$2$4$6'); // remove whitespace in brackets
    }

    /**
     * Parses the name and count out of a name statement, returning the declaration object.
     * @private
     *
     * @param {String} qualifier - The qualifier string.
     * @param {String} type - The type string.
     * @param {String} entry - The variable declaration string.
     *
     * @return {Object} The declaration object.
     */
    function parseNameAndCount(qualifier, type, entry) {
        // determine name and size of variable
        const matches = entry.match(NAME_COUNT_REGEXP);
        const name = matches[1];
        const count = (matches[2] === undefined) ? 1 : parseInt(matches[2], 10);
        return {
            qualifier: qualifier,
            type: type,
            name: name,
            count: count
        };
    }

    /**
     * Parses a single 'statement'. A 'statement' is considered any sequence of
     * characters followed by a semi-colon. Therefore, a single 'statement' in
     * this sense could contain several comma separated declarations. Returns
     * all resulting declarations.
     * @private
     *
     * @param {String} statement - The statement to parse.
     *
     * @return {Array} The array of parsed declaration objects.
     */
    function parseStatement(statement) {
        // split statement on commas
        //
        // ['uniform mat4 A[10]', 'B', 'C[2]']
        //
        const split = statement.split(',').map(elem => {
            return elem.trim();
        });

        // split declaration header from statement
        //
        // ['uniform', 'mat4', 'A[10]']
        //
        const header = split.shift().split(' ');

        // qualifier is always first element
        //
        // 'uniform'
        //
        const qualifier = header.shift();

        // type will be the second element
        //
        // 'mat4'
        //
        const type = header.shift();

        // last part of header will be the first, and possible only variable name
        //
        // ['A[10]', 'B', 'C[2]']
        //
        const names = header.concat(split);

        // if there are other names after a ',' add them as well
        return names.map(name => {
            return parseNameAndCount(qualifier, type, name);
        });
    }

    /**
     * Splits the source string by semi-colons and constructs an array of
     * declaration objects based on the provided qualifier keywords.
     * @private
     *
     * @param {String} source - The shader source string.
     * @param {String|Array} keywords - The qualifier declaration keywords.
     *
     * @return {Array} The array of qualifier declaration objects.
     */
    function parseSource(source, keywords) {
        // get individual statements (any sequence ending in ;)
        const statements = source.split(';');
        // build regex for parsing statements with targetted keywords
        const keywordStr = keywords.join('|');
        const keywordRegex = new RegExp('\\b(' + keywordStr + ')\\b.*');
        // parse and store global precision statements and any declarations
        let matched = [];
        // for each statement
        statements.forEach(statement => {
            // check for keywords
            //
            // ['uniform float uTime']
            //
            const kmatch = statement.match(keywordRegex);
            if (kmatch) {
                // parse statement and add to array
                matched = matched.concat(parseStatement(kmatch[0]));
            }
        });
        return matched;
    }

    /**
     * Filters out duplicate declarations present between shaders. Currently
     * just removes all # statements.
     * @private
     *
     * @param {Array} declarations - The array of declarations.
     *
     * @return {Array} The filtered array of declarations.
     */
    function filterDuplicatesByName(declarations) {
        // in cases where the same declarations are present in multiple
        // sources, this function will remove duplicates from the results
        const seen = {};
        return declarations.filter(declaration => {
            if (seen[declaration.name]) {
                return false;
            }
            seen[declaration.name] = true;
            return true;
        });
    }

    /**
     * Runs the preprocessor on the glsl code.
     * @private
     *
     * @param {String} source - The unprocessed source code.
     *
     * @return {String} The processed source code.
     */
    function preprocess(source) {
        // TODO: implement this correctly...
        return source.replace(PREP_REGEXP, '');
    }

    module.exports = {

        /**
         * Parses the provided GLSL source, and returns all declaration statements that contain the provided qualifier type. This can be used to extract all attributes and uniform names and types from a shader.
         *
         * For example, when provided a 'uniform' qualifiers, the declaration:
         *
         *     'uniform highp vec3 uSpecularColor;'
         *
         * Would be parsed to:
         *     {
         *         qualifier: 'uniform',
         *         type: 'vec3',
         *         name: 'uSpecularColor',
         *         count: 1
         *     }
         * @param {Array} sources - The shader sources.
         * @param {Array} qualifiers - The qualifiers to extract.
         *
         * @return {Array} The array of qualifier declaration statements.
         */
        parseDeclarations: function(sources = [], qualifiers = []) {
            // if no sources or qualifiers are provided, return empty array
            if (sources.length === 0 || qualifiers.length === 0) {
                return [];
            }
            sources = Array.isArray(sources) ? sources : [sources];
            qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
            // parse out targetted declarations
            let declarations = [];
            sources.forEach(source => {
                // run preprocessor
                source = preprocess(source);
                // remove precision statements
                source = stripPrecision(source);
                // remove comments
                source = stripComments(source);
                // finally, normalize the whitespace
                source = normalizeWhitespace(source);
                // parse out declarations
                declarations = declarations.concat(parseSource(source, qualifiers));
            });
            // remove duplicates and return
            return filterDuplicatesByName(declarations);
        },

        /**
         * Detects based on the existence of a 'void main() {' statement, if the string is glsl source code.
         *
         * @param {String} str - The input string to test.
         *
         * @return {boolean} Whether or not the string is glsl code.
         */
        isGLSL: function(str) {
            return GLSL_REGEXP.test(str);
        }

    };

}());

},{}],8:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');
    const Util = require('../util/Util');

    const MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    const MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    const NON_MIPMAP_MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
    };
    const MIPMAP_MIN_FILTERS = {
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    const WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    const DEPTH_TYPES = {
        DEPTH_COMPONENT: true,
        DEPTH_STENCIL: true
    };

    /**
     * The default type for textures.
     */
    const DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for textures.
     */
    const DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for textures.
     */
    const DEFAULT_WRAP = 'REPEAT';

    /**
     * The default min / mag filter for textures.
     */
    const DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    const DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    const DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    const DEFAULT_INVERT_Y = true;

    /**
     * The default mip-mapping filter suffix.
     */
    const DEFAULT_MIPMAP_MIN_FILTER_SUFFIX = '_MIPMAP_LINEAR';

    /**
     * @class Texture2D
     * @classdesc A texture class to represent a 2D texture.
     */
    class Texture2D {

        /**
         * Instantiates a Texture2D object.
         *
         * @param {Uint8Array|Uint16Array|Uint32Array|Float32Array|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} spec.src - The data to buffer.
         * @param {Number} spec.width - The width of the texture.
         * @param {Number} spec.height - The height of the texture.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}) {
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set context
            this.gl = WebGLContext.get();
            // empty texture
            this.texture = null;
            // set texture params
            this.wrapS = spec.wrapS || DEFAULT_WRAP;
            this.wrapT = spec.wrapT || DEFAULT_WRAP;
            this.minFilter = spec.minFilter || DEFAULT_FILTER;
            this.magFilter = spec.magFilter || DEFAULT_FILTER;
            // set other properties
            this.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            this.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            this.premultiplyAlpha = spec.premultiplyAlpha !== undefined ? spec.premultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format
            this.format = spec.format || DEFAULT_FORMAT;
            if (DEPTH_TYPES[this.format] && !WebGLContext.checkExtension('WEBGL_depth_texture')) {
                throw `Cannot create Texture2D of format \`${this.format}\` as \`WEBGL_depth_texture\` extension is unsupported`;
            }
            // set type
            this.type = spec.type || DEFAULT_TYPE;
            if (this.type === 'FLOAT' && !WebGLContext.checkExtension('OES_texture_float')) {
                throw `Cannot create Texture2D of type \`FLOAT\` as \`OES_texture_float\` extension is unsupported`;
            }
            // url will not be resolved yet, so don't buffer in that case
            if (typeof spec.src !== 'string') {
                // check size
                if (!Util.isCanvasType(spec.src)) {
                    // if not a canvas type, dimensions MUST be specified
                    if (typeof spec.width !== 'number' || spec.width <= 0) {
                        throw '`width` argument is missing or invalid';
                    }
                    if (typeof spec.height !== 'number' || spec.height <= 0) {
                        throw '`height` argument is missing or invalid';
                    }
                    if (Util.mustBePowerOfTwo(this)) {
                        if (!Util.isPowerOfTwo(spec.width)) {
                            throw `Parameters require a power-of-two texture, yet provided width of \`${spec.width}\` is not a power of two`;
                        }
                        if (!Util.isPowerOfTwo(spec.height)) {
                            throw `Parameters require a power-of-two texture, yet provided height of \`${spec.height}\` is not a power of two`;
                        }
                    }
                }
                // buffer the data
                this.bufferData(spec.src || null, spec.width, spec.height);
                this.setParameters(this);
            }
        }

        /**
         * Binds the texture object to the provided texture unit location.
         *
         * @param {Number} location - The texture unit location index. Defaults to 0.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bind(location = 0) {
            if (!Number.isInteger(location) || location < 0) {
                throw `Texture unit location is invalid`;
            }
            // bind texture
            const gl = this.gl;
            gl.activeTexture(gl['TEXTURE' + location]);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            return this;
        }

        /**
         * Unbinds the texture object.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        unbind() {
            // unbind texture
            const gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Buffer data into the texture.
         *
         * @param {Array|ArrayBufferView|null} data - The data array to buffer.
         * @param {Number} width - The width of the data.
         * @param {Number} height - The height of the data.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bufferData(data, width, height) {
            const gl = this.gl;
            // create texture object if it doesn't already exist
            if (!this.texture) {
                this.texture = gl.createTexture();
            }
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // invert y if specified
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.invertY);
            // premultiply alpha if specified
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                this.type = 'UNSIGNED_BYTE';
            } else if (data instanceof Uint16Array) {
                this.type = 'UNSIGNED_SHORT';
            } else if (data instanceof Uint32Array) {
                this.type = 'UNSIGNED_INT';
            } else if (data instanceof Float32Array) {
                this.type = 'FLOAT';
            } else if (data && !(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, `HTMLVideoElement`, or null';
            }
            if (Util.isCanvasType(data)) {
                // store width and height
                this.width = data.width;
                this.height = data.height;
                // buffer the texture
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // store width and height
                this.width = width || this.width;
                this.height = height || this.height;
                // buffer the texture data
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    this.width,
                    this.height,
                    0, // border, must be 0
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // generate mip maps
            if (this.mipMap) {
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Buffer partial data into the texture.
         *
         * @param {Array|ArrayBufferView|null} data - The data array to buffer.
         * @param {Number} xOffset - The x offset at which to buffer.
         * @param {Number} yOffset - The y offset at which to buffer.
         * @param {Number} width - The width of the data.
         * @param {Number} height - The height of the data.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        bufferSubData(data, xOffset = 0, yOffset = 0, width = undefined, height = undefined) {
            const gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                if (this.type !== 'UNSIGNED_BYTE') {
                    throw 'Provided argument of type `Uint8Array` does not match type of `UNSIGNED_BYTE`';
                }
            } else if (data instanceof Uint16Array) {
                if (this.type !== 'UNSIGNED_SHORT') {
                    throw 'Provided argument of type `Uint16Array` does not match type of `UNSIGNED_SHORT`';
                }
            } else if (data instanceof Uint32Array) {
                if (this.type !== 'UNSIGNED_INT') {
                    throw 'Provided argument of type `Uint32Array` does not match type of `UNSIGNED_INT`';
                }
            } else if (data instanceof Float32Array) {
                if (this.type !== 'FLOAT') {
                    throw 'Provided argument of type `Float32Array` does not match type of `FLOAT`';
                }
            } else if (!(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, or `HTMLVideoElement`';
            }
            if (Util.isCanvasType(data)) {
                // buffer the texture
                gl.texSubImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level
                    xOffset,
                    yOffset,
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // check that width is provided
                if (!Number.isInteger(width)) {
                    throw `Provided width of \`${width}\` is invalid`;
                }
                // check that height is provided
                if (!Number.isInteger(height)) {
                    throw `Provided height of \`${height}\` is invalid`;
                }
                // check that we aren't overflowing the buffer
                if (width + xOffset > this.width) {
                    throw `Provided width of \`${width}\` and xOffset of ` +
                        ` \`${xOffset}\` overflows the texture width of ` +
                        `\`${this.width}\``;
                }
                if (height + yOffset > this.height) {
                    throw `Provided width of \`${height}\` and xOffset of ` +
                        ` \`${yOffset}\` overflows the texture width of ` +
                        `\`${this.height}\``;
                }
                // buffer the texture data
                gl.texSubImage2D(
                    gl.TEXTURE_2D,
                    0, // mip-map level
                    xOffset,
                    yOffset,
                    width,
                    height,
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // generate mip maps
            if (this.mipMap) {
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, null);
            return this;
        }

        /**
         * Set the texture parameters.
         *
         * @param {Object} params - The parameters by name.
         * @param {String} params.wrap - The wrapping type over both S and T dimension.
         * @param {String} params.wrapS - The wrapping type over the S dimension.
         * @param {String} params.wrapT - The wrapping type over the T dimension.
         * @param {String} params.filter - The min / mag filter used during scaling.
         * @param {String} params.minFilter - The minification filter used during scaling.
         * @param {String} params.magFilter - The magnification filter used during scaling.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        setParameters(params) {
            const gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            // set wrap S parameter
            let param = params.wrapS || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapS = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_S\``;
                }
            }
            // set wrap T parameter
            param = params.wrapT || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapT = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_T\``;
                }
            }
            // set mag filter parameter
            param = params.magFilter || params.filter;
            if (param) {
                if (MAG_FILTERS[param]) {
                    this.magFilter = param;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for 'TEXTURE_MAG_FILTER\``;
                }
            }
            // set min filter parameter
            param = params.minFilter || params.filter;
            if (param) {
                if (this.mipMap) {
                    if (NON_MIPMAP_MIN_FILTERS[param]) {
                        // upgrade to mip-map min filter
                        param += DEFAULT_MIPMAP_MIN_FILTER_SUFFIX;
                    }
                    if (MIPMAP_MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else  {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                } else {
                    if (MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                }
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            return this;
        }

        /**
         * Resize the underlying texture. This clears the texture data.
         *
         * @param {Number} width - The new width of the texture.
         * @param {Number} height - The new height of the texture.
         *
         * @return {Texture2D} The texture object, for chaining.
         */
        resize(width, height) {
            if (typeof width !== 'number' || (width <= 0)) {
                throw `Provided width of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || (height <= 0)) {
                throw `Provided height of \`${height}\` is invalid`;
            }
            this.bufferData(null, width, height);
            return this;
        }
    }

    module.exports = Texture2D;

}());

},{"../util/Util":17,"./WebGLContext":13}],9:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');
    const Async = require('../util/Async');
    const Util = require('../util/Util');
    const ImageLoader = require('../util/ImageLoader');

    const FACES = [
        '-x', '+x',
        '-y', '+y',
        '-z', '+z'
    ];
    const FACE_TARGETS = {
        '+z': 'TEXTURE_CUBE_MAP_POSITIVE_Z',
        '-z': 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
        '+x': 'TEXTURE_CUBE_MAP_POSITIVE_X',
        '-x': 'TEXTURE_CUBE_MAP_NEGATIVE_X',
        '+y': 'TEXTURE_CUBE_MAP_POSITIVE_Y',
        '-y': 'TEXTURE_CUBE_MAP_NEGATIVE_Y'
    };
    const TARGETS = {
        TEXTURE_CUBE_MAP_POSITIVE_Z: true,
        TEXTURE_CUBE_MAP_NEGATIVE_Z: true,
        TEXTURE_CUBE_MAP_POSITIVE_X: true,
        TEXTURE_CUBE_MAP_NEGATIVE_X: true,
        TEXTURE_CUBE_MAP_POSITIVE_Y: true,
        TEXTURE_CUBE_MAP_NEGATIVE_Y: true
    };
    const MAG_FILTERS = {
        NEAREST: true,
        LINEAR: true
    };
    const MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    const NON_MIPMAP_MIN_FILTERS = {
        NEAREST: true,
        LINEAR: true,
    };
    const MIPMAP_MIN_FILTERS = {
        NEAREST_MIPMAP_NEAREST: true,
        LINEAR_MIPMAP_NEAREST: true,
        NEAREST_MIPMAP_LINEAR: true,
        LINEAR_MIPMAP_LINEAR: true
    };
    const WRAP_MODES = {
        REPEAT: true,
        MIRRORED_REPEAT: true,
        CLAMP_TO_EDGE: true
    };
    const FORMATS = {
        RGB: true,
        RGBA: true
    };

    /**
     * The default type for textures.
     */
    const DEFAULT_TYPE = 'UNSIGNED_BYTE';

    /**
     * The default format for textures.
     */
    const DEFAULT_FORMAT = 'RGBA';

    /**
     * The default wrap mode for textures.
     */
    const DEFAULT_WRAP = 'CLAMP_TO_EDGE';

    /**
     * The default min / mag filter for textures.
     */
    const DEFAULT_FILTER = 'LINEAR';

    /**
     * The default for whether alpha premultiplying is enabled.
     */
    const DEFAULT_PREMULTIPLY_ALPHA = true;

    /**
     * The default for whether mipmapping is enabled.
     */
    const DEFAULT_MIPMAP = true;

    /**
     * The default for whether invert-y is enabled.
     */
    const DEFAULT_INVERT_Y = true;

    /**
     * The default mip-mapping filter suffix.
     */
    const DEFAULT_MIPMAP_MIN_FILTER_SUFFIX = '_MIPMAP_LINEAR';

    /**
     * Checks the width and height of the cubemap and throws an exception if
     * it does not meet requirements.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     */
    function checkDimensions(cubeMap) {
        if (typeof cubeMap.width !== 'number' || cubeMap.width <= 0) {
            throw '`width` argument is missing or invalid';
        }
        if (typeof cubeMap.height !== 'number' || cubeMap.height <= 0) {
            throw '`height` argument is missing or invalid';
        }
        if (cubeMap.width !== cubeMap.height) {
            throw 'Provided `width` must be equal to `height`';
        }
        if (Util.mustBePowerOfTwo(cubeMap) && !Util.isPowerOfTwo(cubeMap.width)) {
            throw `Parameters require a power-of-two texture, yet provided size of ${cubeMap.width} is not a power of two`;
        }
    }

    /**
     * Returns a function to load a face from a url.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {String} url - The url to load the face from.
     *
     * @return {Function} The loader function.
     */
    function loadFaceURL(cubeMap, target, url) {
        return function(done) {
            // TODO: put extension handling for arraybuffer / image / video differentiation
            ImageLoader.load({
                url: url,
                success: image => {
                    image = Util.resizeCanvas(cubeMap, image);
                    cubeMap.bufferData(target, image);
                    done(null);
                },
                error: err => {
                    done(err, null);
                }
            });
        };
    }

    /**
     * Returns a function to load a face from a canvas type object.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} canvas - The canvas type object.
     *
     * @return {Function} - The loader function.
     */
    function loadFaceCanvas(cubeMap, target, canvas) {
        return function(done) {
            canvas = Util.resizeCanvas(cubeMap, canvas);
            cubeMap.bufferData(target, canvas);
            done(null);
        };
    }

    /**
     * Returns a function to load a face from an array type object.
     * @private
     *
     * @param {TextureCubeMap} cubeMap - The cube map texture object.
     * @param {String} target - The texture target.
     * @param {Array|ArrayBuffer|ArrayBufferView} arr - The array type object.
     *
     * @return {Function} The loader function.
     */
    function loadFaceArray(cubeMap, target, arr) {
        checkDimensions(cubeMap);
        return function(done) {
            cubeMap.bufferData(target, arr);
            done(null);
        };
    }

    /**
     * @class TextureCubeMap
     * @classdesc A texture class to represent a cube map texture.
     */
    class TextureCubeMap {

        /**
         * Instantiates a TextureCubeMap object.
         *
         * @param {Object} spec - The specification arguments
         * @param {Object} spec.faces - The faces to buffer, under keys '+x', '+y', '+z', '-x', '-y', and '-z'.
         * @param {Number} spec.width - The width of the faces.
         * @param {Number} spec.height - The height of the faces.
         * @param {String} spec.wrap - The wrapping type over both S and T dimension.
         * @param {String} spec.wrapS - The wrapping type over the S dimension.
         * @param {String} spec.wrapT - The wrapping type over the T dimension.
         * @param {String} spec.filter - The min / mag filter used during scaling.
         * @param {String} spec.minFilter - The minification filter used during scaling.
         * @param {String} spec.magFilter - The magnification filter used during scaling.
         * @param {bool} spec.mipMap - Whether or not mip-mapping is enabled.
         * @param {bool} spec.invertY - Whether or not invert-y is enabled.
         * @param {bool} spec.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
         * @param {String} spec.format - The texture pixel format.
         * @param {String} spec.type - The texture pixel component type.
         */
        constructor(spec = {}, callback = null) {
            this.gl = WebGLContext.get();
            this.texture = null;
            // get specific params
            spec.wrapS = spec.wrapS || spec.wrap;
            spec.wrapT = spec.wrapT || spec.wrap;
            spec.minFilter = spec.minFilter || spec.filter;
            spec.magFilter = spec.magFilter || spec.filter;
            // set texture params
            this.wrapS = WRAP_MODES[spec.wrapS] ? spec.wrapS : DEFAULT_WRAP;
            this.wrapT = WRAP_MODES[spec.wrapT] ? spec.wrapT : DEFAULT_WRAP;
            this.minFilter = MIN_FILTERS[spec.minFilter] ? spec.minFilter : DEFAULT_FILTER;
            this.magFilter = MAG_FILTERS[spec.magFilter] ? spec.magFilter : DEFAULT_FILTER;
            // set other properties
            this.mipMap = spec.mipMap !== undefined ? spec.mipMap : DEFAULT_MIPMAP;
            this.invertY = spec.invertY !== undefined ? spec.invertY : DEFAULT_INVERT_Y;
            this.premultiplyAlpha = spec.premultiplyAlpha !== undefined ? spec.premultiplyAlpha : DEFAULT_PREMULTIPLY_ALPHA;
            // set format and type
            this.format = FORMATS[spec.format] ? spec.format : DEFAULT_FORMAT;
            this.type = spec.type || DEFAULT_TYPE;
            if (this.type === 'FLOAT' && !WebGLContext.checkExtension('OES_texture_float')) {
                throw 'Cannot create Texture2D of type `FLOAT` as `OES_texture_float` extension is unsupported';
            }
            // set dimensions if provided
            this.width = spec.width;
            this.height = spec.height;
            // set buffered faces
            this.bufferedFaces = [];
            // create cube map based on input
            if (spec.faces) {
                const tasks = [];
                FACES.forEach(id => {
                    const face = spec.faces[id];
                    const target = FACE_TARGETS[id];
                    // load based on type
                    if (typeof face === 'string') {
                        // url
                        tasks.push(loadFaceURL(this, target, face));
                    } else if (Util.isCanvasType(face)) {
                        // canvas
                        tasks.push(loadFaceCanvas(this, target, face));
                    } else {
                        // array / arraybuffer or null
                        tasks.push(loadFaceArray(this, target, face));
                    }
                });
                Async.parallel(tasks, err => {
                    if (err) {
                        if (callback) {
                            setTimeout(() => {
                                callback(err, null);
                            });
                        }
                        return;
                    }
                    // set parameters
                    this.setParameters(this);
                    if (callback) {
                        setTimeout(() => {
                            callback(null, this);
                        });
                    }
                });
            } else {
                // null
                checkDimensions(this);
                FACES.forEach(id => {
                    this.bufferData(FACE_TARGETS[id], null);
                });
                // set parameters
                this.setParameters(this);
            }
        }

        /**
         * Binds the texture object to the provided texture unit location.
         *
         * @param {Number} location - The texture unit location index. Defaults to 0.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        bind(location = 0) {
            if (!Number.isInteger(location) || location < 0) {
                throw 'Texture unit location is invalid';
            }
            // bind cube map texture
            const gl = this.gl;
            gl.activeTexture(gl['TEXTURE' + location]);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            return this;
        }

        /**
         * Unbinds the texture object.
         *
         * @return {TextureCubeMap} - The texture object, for chaining.
         */
        unbind() {
            // unbind cube map texture
            const gl = this.gl;
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }

        /**
         * Buffer data into the respective cube map face.
         *
         * @param {String} target - The face target.
         * @param {Object|null} data - The face data.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        bufferData(target, data) {
            if (!TARGETS[target]) {
                throw `Provided \`target\` of ${target}  is invalid`;
            }
            const gl = this.gl;
            // create texture object if it doesn't already exist
            if (!this.texture) {
                this.texture = gl.createTexture();
            }
            // bind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            // invert y if specified
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.invertY);
            // premultiply alpha if specified
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
            // cast array arg
            if (Array.isArray(data)) {
                if (this.type === 'UNSIGNED_SHORT') {
                    data = new Uint16Array(data);
                } else if (this.type === 'UNSIGNED_INT') {
                    data = new Uint32Array(data);
                } else if (this.type === 'FLOAT') {
                    data = new Float32Array(data);
                } else {
                    data = new Uint8Array(data);
                }
            }
            // set ensure type corresponds to data
            if (data instanceof Uint8Array) {
                this.type = 'UNSIGNED_BYTE';
            } else if (data instanceof Uint16Array) {
                this.type = 'UNSIGNED_SHORT';
            } else if (data instanceof Uint32Array) {
                this.type = 'UNSIGNED_INT';
            } else if (data instanceof Float32Array) {
                this.type = 'FLOAT';
            } else if (data && !(data instanceof ArrayBuffer) && !Util.isCanvasType(data)) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    '`ArrayBufferView`, `ImageData`, `HTMLImageElement`, ' +
                    '`HTMLCanvasElement`, `HTMLVideoElement`, or null';
            }
            // buffer the data
            if (Util.isCanvasType(data)) {
                // store width and height
                this.width = data.width;
                this.height = data.height;
                // buffer the texture
                gl.texImage2D(
                    gl[target],
                    0, // mip-map level,
                    gl[this.format], // webgl requires format === internalFormat
                    gl[this.format],
                    gl[this.type],
                    data);
            } else {
                // buffer the texture data
                gl.texImage2D(
                    gl[target],
                    0, // mip-map level
                    gl[this.format], // webgl requires format === internalFormat
                    this.width,
                    this.height,
                    0, // border, must be 0
                    gl[this.format],
                    gl[this.type],
                    data);
            }
            // track the face that was buffered
            if (this.bufferedFaces.indexOf(target) < 0) {
                this.bufferedFaces.push(target);
            }
            // if all faces buffered, generate mipmaps
            if (this.mipMap && this.bufferedFaces.length === 6) {
                // only generate mipmaps if all faces are buffered
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }

        /**
         * Set the texture parameters.
         *
         * @param {Object} params - The parameters by name.
         * @param {String} params.wrap - The wrapping type over both S and T dimension.
         * @param {String} params.wrapS - The wrapping type over the S dimension.
         * @param {String} params.wrapT - The wrapping type over the T dimension.
         * @param {String} params.filter - The min / mag filter used during scaling.
         * @param {String} params.minFilter - The minification filter used during scaling.
         * @param {String} params.magFilter - The magnification filter used during scaling.
         *
         * @return {TextureCubeMap} The texture object, for chaining.
         */
        setParameters(params) {
            const gl = this.gl;
            // bind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
            // set wrap S parameter
            let param = params.wrapS || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapS = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_S\``;
                }
            }
            // set wrap T parameter
            param = params.wrapT || params.wrap;
            if (param) {
                if (WRAP_MODES[param]) {
                    this.wrapT = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_WRAP_T\``;
                }
            }
            // set mag filter parameter
            param = params.magFilter || params.filter;
            if (param) {
                if (MAG_FILTERS[param]) {
                    this.magFilter = param;
                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                } else {
                    throw `Texture parameter \`${param}\` is not a valid value for 'TEXTURE_MAG_FILTER\``;
                }
            }
            // set min filter parameter
            param = params.minFilter || params.filter;
            if (param) {
                if (this.mipMap) {
                    if (NON_MIPMAP_MIN_FILTERS[param]) {
                        // upgrade to mip-map min filter
                        param += DEFAULT_MIPMAP_MIN_FILTER_SUFFIX;
                    }
                    if (MIPMAP_MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else  {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                } else {
                    if (MIN_FILTERS[param]) {
                        this.minFilter = param;
                        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
                    } else {
                        throw `Texture parameter \`${param}\` is not a valid value for \`TEXTURE_MIN_FILTER\``;
                    }
                }
            }
            // unbind texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return this;
        }
    }

    module.exports = TextureCubeMap;

}());

},{"../util/Async":15,"../util/ImageLoader":16,"../util/Util":17,"./WebGLContext":13}],10:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');
    const VertexPackage = require('./VertexPackage');

    const MODES = {
        POINTS: true,
        LINES: true,
        LINE_STRIP: true,
        LINE_LOOP: true,
        TRIANGLES: true,
        TRIANGLE_STRIP: true,
        TRIANGLE_FAN: true
    };
    const TYPES = {
        BYTE: true,
        UNSIGNED_BYTE: true,
        SHORT: true,
        UNSIGNED_SHORT: true,
        FIXED: true,
        FLOAT: true
    };
    const BYTES_PER_TYPE = {
        BYTE: 1,
        UNSIGNED_BYTE: 1,
        SHORT: 2,
        UNSIGNED_SHORT: 2,
        FIXED: 4,
        FLOAT: 4
    };
    const SIZES = {
        1: true,
        2: true,
        3: true,
        4: true
    };

    /**
     * The default attribute point byte offset.
     */
    const DEFAULT_BYTE_OFFSET = 0;

    /**
     * The default render mode (primitive type).
     */
    const DEFAULT_MODE = 'TRIANGLES';

    /**
     * The default index offset to render from.
     */
    const DEFAULT_INDEX_OFFSET = 0;

    /**
     * The default count of indices to render.
     */
    const DEFAULT_COUNT = 0;

    /**
     * Parse the attribute pointers and determine the byte stride of the buffer.
     * @private
     *
     * @param {Map} attributePointers - The attribute pointer map.
     *
     * @return {Number} The byte stride of the buffer.
     */
    function getStride(attributePointers) {
        // if there is only one attribute pointer assigned to this buffer,
        // there is no need for stride, set to default of 0
        if (attributePointers.size === 1) {
            return 0;
        }
        let maxByteOffset = 0;
        let byteSizeSum = 0;
        let byteStride = 0;
        attributePointers.forEach(pointer => {
            const byteOffset = pointer.byteOffset;
            const size = pointer.size;
            const type = pointer.type;
            // track the sum of each attribute size
            byteSizeSum += size * BYTES_PER_TYPE[type];
            // track the largest offset to determine the byte stride of the buffer
            if (byteOffset > maxByteOffset) {
                maxByteOffset = byteOffset;
                byteStride = byteOffset + (size * BYTES_PER_TYPE[type]);
            }
        });
        // check if the max byte offset is greater than or equal to the the sum of
        // the sizes. If so this buffer is not interleaved and does not need a
        // stride.
        if (maxByteOffset >= byteSizeSum) {
            // TODO: test what stride === 0 does for an interleaved buffer of
            // length === 1.
            return 0;
        }
        return byteStride;
    }

    /**
     * Parse the attribute pointers to ensure they are valid.
     * @private
     *
     * @param {Object} attributePointers - The attribute pointer map.
     *
     * @return {Object} The validated attribute pointer map.
     */
    function getAttributePointers(attributePointers) {
        // parse pointers to ensure they are valid
        const pointers = new Map();
        Object.keys(attributePointers).forEach(key => {
            const index = parseInt(key, 10);
            // check that key is an valid integer
            if (isNaN(index)) {
                throw `Attribute index \`${key}\` does not represent an integer`;
            }
            const pointer = attributePointers[key];
            const size = pointer.size;
            const type = pointer.type;
            const byteOffset = pointer.byteOffset;
            // check size
            if (!SIZES[size]) {
                throw 'Attribute pointer `size` parameter is invalid, must be one of ' +
                    JSON.stringify(Object.keys(SIZES));
            }
            // check type
            if (!TYPES[type]) {
                throw 'Attribute pointer `type` parameter is invalid, must be one of ' +
                    JSON.stringify(Object.keys(TYPES));
            }
            pointers.set(index, {
                size: size,
                type: type,
                byteOffset: (byteOffset !== undefined) ? byteOffset : DEFAULT_BYTE_OFFSET
            });
        });
        return pointers;
    }

    /**
     * @class VertexBuffer
     * @classdesc A vertex buffer object.
     */
    class VertexBuffer {

        /**
         * Instantiates an VertexBuffer object.
         *
         * @param {WebGLBuffer|VertexPackage|Float32Array|Array|Number} arg - The buffer or length of the buffer.
         * @param {Object} attributePointers - The array pointer map, or in the case of a vertex package arg, the options.
         * @param {Object} options - The rendering options.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.indexOffset - The index offset into the drawn buffer.
         * @param {String} options.count - The number of indices to draw.
         */
        constructor(arg, attributePointers = {}, options = {}) {
            this.gl = WebGLContext.get();
            this.buffer = null;
            this.mode = MODES[options.mode] ? options.mode : DEFAULT_MODE;
            this.count = (options.count !== undefined) ? options.count : DEFAULT_COUNT;
            this.indexOffset = (options.indexOffset !== undefined) ? options.indexOffset : DEFAULT_INDEX_OFFSET;
            this.byteLength = 0;
            // first, set the attribute pointers
            if (arg && arg.buffer && arg.pointers) {
                // VertexPackage argument, use its attribute pointers
                this.pointers = arg.pointers;
                // shift options arg since there will be no attrib pointers arg
                options = attributePointers;
            } else {
                this.pointers = getAttributePointers(attributePointers);
            }
            // set the byte stride
            this.byteStride = getStride(this.pointers);
            // then buffer the data
            if (arg) {
                if (arg instanceof VertexPackage) {
                    // VertexPackage argument
                    this.bufferData(arg.buffer);
                } else if (arg instanceof WebGLBuffer) {
                    // WebGLBuffer argument
                    if (options.byteLength === undefined) {
                        throw 'Argument of type `WebGLBuffer` must be complimented with a corresponding `options.byteLength`';
                    }
                    this.buffer = arg;
                    this.byteLength = options.byteLength;
                } else {
                    // Array or ArrayBuffer or number argument
                    this.bufferData(arg);
                }
            }
        }

        /**
         * Upload vertex data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView|number} arg - The array of data to buffer, or size of the buffer in bytes.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        bufferData(arg) {
            const gl = this.gl;
            // ensure argument is valid
            if (Array.isArray(arg)) {
                // cast array into Float32Array
                arg = new Float32Array(arg);
            } else if (
                !(arg instanceof ArrayBuffer) &&
                !(ArrayBuffer.isView(arg)) &&
                !(Number.isInteger(arg))
                ) {
                // if not arraybuffer or a numeric size
                throw 'Argument must be of type `Array`, `ArrayBuffer`, `ArrayBufferView`, or `Number`';
            }
            // set byte length
            if (Number.isInteger(arg)) {
                this.byteLength = arg;
            } else {
                this.byteLength = arg.byteLength;
            }
            // create buffer if it doesn't exist already
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            // buffer the data
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, arg, gl.STATIC_DRAW);
        }

        /**
         * Upload partial vertex data to the GPU.
         *
         * @param {Array|ArrayBuffer|ArrayBufferView} array - The array of data to buffer.
         * @param {Number} byteOffset - The byte offset at which to buffer.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        bufferSubData(array, byteOffset = DEFAULT_BYTE_OFFSET) {
            const gl = this.gl;
            // ensure the buffer exists
            if (!this.buffer) {
                throw 'Buffer has not yet been allocated, allocate with ' +
                    '`bufferData`';
            }
            // ensure argument is valid
            if (Array.isArray(array)) {
                array = new Float32Array(array);
            } else if (
                !(array instanceof ArrayBuffer) &&
                !ArrayBuffer.isView(array)
                ) {
                throw 'Argument must be of type `Array`, `ArrayBuffer`, ' +
                    'or `ArrayBufferView`';
            }
            // check that we aren't overflowing the buffer
            if (byteOffset + array.byteLength > this.byteLength) {
                throw `Argument of length ${array.byteLength} bytes with ` +
                    `offset of ${byteOffset} bytes overflows the buffer ` +
                    `length of ${this.byteLength} bytes`;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, byteOffset, array);
            return this;
        }

        /**
         * Binds the vertex buffer object.
         *
         * @return {VertexBuffer} - Returns the vertex buffer object for chaining.
         */
        bind() {
            const gl = this.gl;
            // bind buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            // for each attribute pointer
            this.pointers.forEach((pointer, index) => {
                // set attribute pointer
                gl.vertexAttribPointer(
                    index,
                    pointer.size,
                    gl[pointer.type],
                    false,
                    this.byteStride,
                    pointer.byteOffset);
                // enable attribute index
                gl.enableVertexAttribArray(index);
            });
            return this;
        }

        /**
         * Unbinds the vertex buffer object.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        unbind() {
            const gl = this.gl;
            // unbind buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            this.pointers.forEach((pointer, index) => {
                // disable attribute index
                gl.disableVertexAttribArray(index);
            });
            return this;
        }

        /**
         * Execute the draw command for the bound buffer.
         *
         * @param {Object} options - The options to pass to 'drawArrays'. Optional.
         * @param {String} options.mode - The draw mode / primitive type.
         * @param {String} options.indexOffset - The index offset into the drawn buffer.
         * @param {String} options.count - The number of indices to draw.
         *
         * @return {VertexBuffer} The vertex buffer object, for chaining.
         */
        draw(options = {}) {
            const gl = this.gl;
            const mode = gl[options.mode || this.mode];
            const indexOffset = (options.indexOffset !== undefined) ? options.indexOffset : this.indexOffset;
            const count = (options.count !== undefined) ? options.count : this.count;
            if (count === 0) {
                throw 'Attempting to draw with a count of 0';
            }
            // draw elements
            gl.drawArrays(mode, indexOffset, count);
            return this;
        }
    }

    module.exports = VertexBuffer;

}());

},{"./VertexPackage":11,"./WebGLContext":13}],11:[function(require,module,exports){
(function() {

    'use strict';

    const COMPONENT_TYPE = 'FLOAT';
    const BYTES_PER_COMPONENT = 4;

    /**
     * Removes invalid attribute arguments. A valid argument must be an Array of length > 0 key by a string representing an int.
     * @private
     *
     * @param {Object} attributes - The map of vertex attributes.
     *
     * @return {Array} The valid array of arguments.
     */
    function parseAttributeMap(attributes) {
        const goodAttributes = [];
        Object.keys(attributes).forEach(key => {
            const index = parseFloat(key);
            // check that key is an valid integer
            if (!Number.isInteger(index) || index < 0) {
                throw `Attribute index \`${key}\` does not represent a valid integer`;
            }
            const vertices = attributes[key];
            // ensure attribute is valid
            if (Array.isArray(vertices) && vertices.length > 0) {
                // add attribute data and index
                goodAttributes.push({
                    index: index,
                    data: vertices
                });
            } else {
                throw `Error parsing attribute of index \`${index}\``;
            }
        });
        // sort attributes ascending by index
        goodAttributes.sort((a, b) => {
            return a.index - b.index;
        });
        return goodAttributes;
    }

    /**
     * Returns a component's byte size.
     * @private
     *
     * @param {Object|Array} component - The component to measure.
     *
     * @return {Number} The byte size of the component.
     */
    function getComponentSize(component) {
        // check if array
        if (Array.isArray(component)) {
            return component.length;
        }
        // check if vector
        if (component.x !== undefined) {
            // 1 component vector
            if (component.y !== undefined) {
                // 2 component vector
                if (component.z !== undefined) {
                    // 3 component vector
                    if (component.w !== undefined) {
                        // 4 component vector
                        return 4;
                    }
                    return 3;
                }
                return 2;
            }
            return 1;
        }
        // single component
        return 1;
    }

    /**
     * Calculates the type, size, and offset for each attribute in the attribute array along with the length and stride of the package.
     * @private
     *
     * @param {VertexPackage} vertexPackage - The VertexPackage object.
     * @param {Array} attributes The array of vertex attributes.
     */
    function setPointersAndStride(vertexPackage, attributes) {
        let shortestArray = Number.MAX_VALUE;
        let offset = 0;
        // for each attribute
        attributes.forEach(vertices => {
            // set size to number of components in the attribute
            const size = getComponentSize(vertices.data[0]);
            // length of the package will be the shortest attribute array length
            shortestArray = Math.min(shortestArray, vertices.data.length);
            // store pointer under index
            vertexPackage.pointers.set(vertices.index, {
                type: COMPONENT_TYPE,
                size: size,
                byteOffset: offset * BYTES_PER_COMPONENT
            });
            // accumulate attribute offset
            offset += size;
        });
        // set stride to total offset
        vertexPackage.stride = offset; // not in bytes
        // set length of package to the shortest attribute array length
        vertexPackage.length = shortestArray;
    }

    /**
     * Fill the arraybuffer with a single component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set1ComponentAttr(buffer, vertices, length, offset, stride) {
        for (let i=0; i<length; i++) {
            const vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            const j = offset + (stride * i);
            if (vertex.x !== undefined) {
                buffer[j] = vertex.x;
            } else if (vertex[0] !== undefined) {
                buffer[j] = vertex[0];
            } else {
                buffer[j] = vertex;
            }
        }
    }

    /**
     * Fill the arraybuffer with a double component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set2ComponentAttr(buffer, vertices, length, offset, stride) {
        for (let i=0; i<length; i++) {
            const vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            const j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
        }
    }

    /**
     * Fill the arraybuffer with a triple component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set3ComponentAttr(buffer, vertices, length, offset, stride) {
        for (let i=0; i<length; i++) {
            const vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            const j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
            buffer[j+2] = (vertex.z !== undefined) ? vertex.z : vertex[2];
        }
    }

    /**
     * Fill the arraybuffer with a quadruple component attribute.
     * @private
     *
     * @param {Float32Array} buffer - The arraybuffer to fill.
     * @param {Array} vertices - The vertex attribute array to copy from.
     * @param {Number} length - The length of the buffer to copy from.
     * @param {Number} offset - The offset to the attribute, not in bytes.
     * @param {Number} stride - The stride of the buffer, not in bytes.
     */
    function set4ComponentAttr(buffer, vertices, length, offset, stride) {
        for (let i=0; i<length; i++) {
            const vertex = vertices[i];
            // get the index in the buffer to the particular vertex
            const j = offset + (stride * i);
            buffer[j] = (vertex.x !== undefined) ? vertex.x : vertex[0];
            buffer[j+1] = (vertex.y !== undefined) ? vertex.y : vertex[1];
            buffer[j+2] = (vertex.z !== undefined) ? vertex.z : vertex[2];
            buffer[j+3] = (vertex.w !== undefined) ? vertex.w : vertex[3];
        }
    }

    /**
     * @class VertexPackage
     * @classdesc A vertex package to assist in interleaving vertex data and building the associated vertex attribute pointers.
     */
    class VertexPackage {

        /**
         * Instantiates a VertexPackage object.
          *
         * @param {Object} attributes - The attributes to interleave keyed by index.
         */
        constructor(attributes) {
            this.stride = 0;
            this.length = 0;
            this.buffer = null;
            this.pointers = new Map();
            if (attributes) {
                this.set(attributes);
            }
        }

        /**
         * Set the data to be interleaved inside the package. This clears any previously existing data.
         *
         * @param {Object} attributes - The attributes to interleaved, keyed by index.
         *
         * @return {VertexPackage} The vertex package object, for chaining.
         */
        set(attributes) {
            // remove bad attributes
            attributes = parseAttributeMap(attributes);
            // set attribute pointers and stride
            setPointersAndStride(this, attributes);
            // set size of data vector
            const length = this.length;
            const stride = this.stride; // not in bytes
            const pointers = this.pointers;
            const buffer = this.buffer = new Float32Array(length * stride);
            // for each vertex attribute array
            attributes.forEach(vertices => {
                // get the pointer
                const pointer = pointers.get(vertices.index);
                // get the pointers offset
                const offset = pointer.byteOffset / BYTES_PER_COMPONENT;
                // copy vertex data into arraybuffer
                switch (pointer.size) {
                    case 2:
                        set2ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    case 3:
                        set3ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    case 4:
                        set4ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                    default:
                        set1ComponentAttr(buffer, vertices.data, length, offset, stride);
                        break;
                }
            });
            return this;
        }
    }

    module.exports = VertexPackage;

}());

},{}],12:[function(require,module,exports){
(function() {

    'use strict';

    const WebGLContext = require('./WebGLContext');

    /**
     * Bind the viewport to the rendering context.
     *
     * @param {Viewport} viewport - The viewport object.
     * @param {Number} width - The width override.
     * @param {Number} height - The height override.
     * @param {Number} x - The horizontal offset override.
     * @param {Number} y - The vertical offset override.
     */
    function set(viewport, x, y, width, height) {
        const gl = viewport.gl;
        x = (x !== undefined) ? x : viewport.x;
        y = (y !== undefined) ? y : viewport.y;
        width = (width !== undefined) ? width : viewport.width;
        height = (height !== undefined) ? height : viewport.height;
        gl.viewport(x, y, width, height);
    }

    /**
     * @class Viewport
     * @classdesc A viewport class for managing WebGL viewports.
     */
    class Viewport {

        /**
         * Instantiates a Viewport object.
         *
         * @param {Object} spec - The viewport specification object.
         * @param {Number} spec.width - The width of the viewport.
         * @param {Number} spec.height - The height of the viewport.
         */
        constructor(spec = {}) {
            this.gl = WebGLContext.get();
            this.stack = [];
            // set size
            this.resize(
                spec.width || this.gl.canvas.width,
                spec.height || this.gl.canvas.height);
        }

        /**
         * Updates the viewports width and height. This resizes the underlying canvas element.
         *
         * @param {Number} width - The width of the viewport.
         * @param {Number} height - The height of the viewport.
         *
         * @return {Viewport} The viewport object, for chaining.
         */
        resize(width = 0, height = 0) {
            if (typeof width !== 'number' || width <= 0) {
                throw `Provided \`width\` of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || height <= 0) {
                throw `Provided \`height\` of \`${height}\` is invalid`;
            }
            this.width = width;
            this.height = height;
            this.gl.canvas.width = width;
            this.gl.canvas.height = height;
            return this;
        }

        /**
         * Sets the viewport dimensions and position. The underlying canvas element is not affected.
         *
         * @param {Number} width - The width override.
         * @param {Number} height - The height override.
         * @param {Number} x - The horizontal offset override.
         * @param {Number} y - The vertical offset override.
         *
         * @return {Viewport} - The viewport object, for chaining.
         */
        push(x = 0, y = 0, width = this.width, height = this.height) {
            if (typeof x !== 'number') {
                throw `Provided \`x\` of \`${x}\` is invalid`;
            }
            if (typeof y !== 'number') {
                throw `Provided \`y\` of \`${y}\` is invalid`;
            }
            if (typeof width !== 'number' || width <= 0) {
                throw `Provided \`width\` of \`${width}\` is invalid`;
            }
            if (typeof height !== 'number' || height <= 0) {
                throw `Provided \`height\` of \`${height}\` is invalid`;
            }
            // push onto stack
            this.stack.push({
                x: x,
                y: y,
                width: width,
                height: height
            });
            // set viewport
            set(this, x, y, width, height);
            return this;
        }

        /**
         * Pops current the viewport object and sets the viewport beneath it.
         *
         * @return {Viewport} The viewport object, for chaining.
         */
        pop() {
            if (this.stack.length === 0) {
                throw 'Viewport stack is empty';
            }
            this.stack.pop();
            if (this.stack.length > 0) {
                const top = this.stack[this.stack.length - 1];
                set(this, top.x, top.y, top.width, top.height);
            } else {
                set(this);
            }
            return this;
        }
    }

    module.exports = Viewport;

}());

},{"./WebGLContext":13}],13:[function(require,module,exports){
(function() {

    'use strict';

    const EXTENSIONS = [
        // ratified
        'OES_texture_float',
        'OES_texture_half_float',
        'WEBGL_lose_context',
        'OES_standard_derivatives',
        'OES_vertex_array_object',
        'WEBGL_debug_renderer_info',
        'WEBGL_debug_shaders',
        'WEBGL_compressed_texture_s3tc',
        'WEBGL_depth_texture',
        'OES_element_index_uint',
        'EXT_texture_filter_anisotropic',
        'EXT_frag_depth',
        'WEBGL_draw_buffers',
        'ANGLE_instanced_arrays',
        'OES_texture_float_linear',
        'OES_texture_half_float_linear',
        'EXT_blend_minmax',
        'EXT_shader_texture_lod',
        // community
        'WEBGL_compressed_texture_atc',
        'WEBGL_compressed_texture_pvrtc',
        'EXT_color_buffer_half_float',
        'WEBGL_color_buffer_float',
        'EXT_sRGB',
        'WEBGL_compressed_texture_etc1',
        'EXT_disjoint_timer_query',
        'EXT_color_buffer_float'
    ];

    const _contexts = new Map();

    let _boundContext = null;

    /**
     * Returns an rfc4122 version 4 compliant UUID.
     * @private
     *
     * @return {String} - The UUID string.
     */
    function getUUID() {
        const replace = function(c) {
            const r = Math.random() * 16 | 0;
            const v = (c === 'x') ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        };
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, replace);
    }

    /**
     * Returns the id of the HTMLCanvasElement element. If there is no id, it generates one and appends it.
     * @private
     *
     * @param {HTMLCanvasElement} canvas - The Canvas object.
     *
     * @return {String} The Canvas id string.
     */
    function getId(canvas) {
        if (!canvas.id) {
            canvas.id = getUUID();
        }
        return canvas.id;
    }

    /**
     * Returns a Canvas element object from either an existing object, or identification string.
     * @private
     *
     * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas id or selector string.
     *
     * @return {HTMLCanvasElement} The Canvas element object.
     */
    function getCanvas(arg) {
        if (arg instanceof HTMLCanvasElement) {
            return arg;
        } else if (typeof arg === 'string') {
            return document.getElementById(arg) ||
                document.querySelector(arg);
        }
        return null;
    }

    /**
     * Attempts to retrieve a wrapped WebGLRenderingContext.
     * @private
     *
     * @param {HTMLCanvasElement} The Canvas element object to create the context under.
     *
     * @return {Object} The context wrapper.
     */
    function getContextWrapper(arg) {
        if (arg === undefined) {
            if (_boundContext) {
                // return last bound context
                return _boundContext;
            }
        } else {
            const canvas = getCanvas(arg);
            if (canvas) {
                return _contexts.get(getId(canvas));
            }
        }
        // no bound context or argument
        return null;
    }

    /**
     * Attempts to load all known extensions for a provided WebGLRenderingContext. Stores the results in the context wrapper for later queries.
     * @private
     *
     * @param {Object} contextWrapper - The context wrapper.
     */
    function loadExtensions(contextWrapper) {
        const gl = contextWrapper.gl;
        EXTENSIONS.forEach(id => {
            contextWrapper.extensions.set(id, gl.getExtension(id));
        });
    }

    /**
     * Attempts to create a WebGLRenderingContext and load all extensions.
     * @private
     *
     * @param {HTMLCanvasElement} - The Canvas element object to create the context under.
     * @param {Object}} options - Parameters to the webgl context, only used during instantiation. Optional.
     *
     * @return {Object} The context wrapper.
     */
    function createContextWrapper(canvas, options) {
        const gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
        // wrap context
        const contextWrapper = {
            id: getId(canvas),
            gl: gl,
            extensions: new Map()
        };
        // load WebGL extensions
        loadExtensions(contextWrapper);
        // add context wrapper to map
        _contexts.set(getId(canvas), contextWrapper);
        // bind the context
        _boundContext = contextWrapper;
        return contextWrapper;
    }

    module.exports = {

        /**
         * Retrieves an existing WebGL context associated with the provided argument and binds it. While bound, the active context will be used implicitly by any instantiated `esper` constructs.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string.
         *
         * @return {WebGLContext} The namespace, used for chaining.
         */
        bind: function(arg) {
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
                _boundContext = wrapper;
                return this;
            }
            throw `No context exists for provided argument '${arg}'`;
        },

        /**
         * Retrieves an existing WebGL context associated with the provided argument. If no context exists, one is created.
         * During creation attempts to load all extensions found at: https://www.khronos.org/registry/webgl/extensions/.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {Object} options - Parameters to the webgl context, only used during instantiation. Optional.
         *
         * @return {WebGLRenderingContext} The WebGLRenderingContext object.
         */
        get: function(arg, options) {
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
               // return the native WebGLRenderingContext
               return wrapper.gl;
            }
            // get canvas element
            const canvas = getCanvas(arg);
            // try to find or create context
            if (!canvas) {
                throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
            }
            // create context
            return createContextWrapper(canvas, options).gl;
        },

        /**
         * Removes an existing WebGL context object for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {Object}} options - Parameters to the webgl context, only used during instantiation. Optional.
         *
         * @return {WebGLRenderingContext} The WebGLRenderingContext object.
         */
        remove: function(arg) {
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
                // delete the context
                _contexts.delete(wrapper.id);
                // remove if currently bound
                if (wrapper === _boundContext) {
                    _boundContext = null;
                }
            } else {
                throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
            }
        },

        /**
         * Returns an array of all supported extensions for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         *
         * @return {Array} All supported extensions.
         */
        supportedExtensions: function(arg) {
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
                const extensions = wrapper.extensions;
                const supported = [];
                extensions.forEach((extension, key) => {
                    if (extension) {
                        supported.push(key);
                    }
                });
                return supported;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Returns an array of all unsupported extensions for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         *
         * @return {Array} All unsupported extensions.
         */
        unsupportedExtensions: function(arg) {
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
                const extensions = wrapper.extensions;
                const unsupported = [];
                extensions.forEach((extension, key) => {
                    if (!extension) {
                        unsupported.push(key);
                    }
                });
                return unsupported;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Checks if an extension has been successfully loaded for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {String} extension - The extension name.
         *
         * @return {boolean} Whether or not the provided extension has been loaded successfully.
         */
        checkExtension: function(arg, extension) {
            if (!extension) {
                // shift parameters if no canvas arg is provided
                extension = arg;
                arg = undefined;
            }
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
                const extensions = wrapper.extensions;
                return extensions.get(extension) ? true : false;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        },

        /**
         * Returns an extension if it has been successfully loaded for the provided or currently bound context object.
         *
         * @param {HTMLCanvasElement|String} arg - The Canvas object or Canvas identification string. Optional.
         * @param {String} extension - The extension name.
         *
         * @return {boolean} Whether or not the provided extension has been loaded successfully.
         */
        getExtension: function(arg, extension) {
            if (!extension) {
                // shift parameters if no canvas arg is provided
                extension = arg;
                arg = undefined;
            }
            const wrapper = getContextWrapper(arg);
            if (wrapper) {
                const extensions = wrapper.extensions;
                return extensions.get(extension) || null;
            }
            throw `No context is currently bound or could be associated with provided argument of type ${typeof arg}`;
        }
    };

}());

},{}],14:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {
        IndexBuffer: require('./core/IndexBuffer'),
        Renderable: require('./core/Renderable'),
        RenderTarget: require('./core/RenderTarget'),
        Shader: require('./core/Shader'),
        Texture2D: require('./core/Texture2D'),
        ColorTexture2D: require('./core/ColorTexture2D'),
        DepthTexture2D: require('./core/DepthTexture2D'),
        TextureCubeMap: require('./core/TextureCubeMap'),
        VertexBuffer: require('./core/VertexBuffer'),
        VertexPackage: require('./core/VertexPackage'),
        Viewport: require('./core/Viewport'),
        WebGLContext: require('./core/WebGLContext')
    };

}());

},{"./core/ColorTexture2D":1,"./core/DepthTexture2D":2,"./core/IndexBuffer":3,"./core/RenderTarget":4,"./core/Renderable":5,"./core/Shader":6,"./core/Texture2D":8,"./core/TextureCubeMap":9,"./core/VertexBuffer":10,"./core/VertexPackage":11,"./core/Viewport":12,"./core/WebGLContext":13}],15:[function(require,module,exports){
(function() {

    'use strict';

    function getIterator(arg) {
        let i = -1;
        let len;
        if (Array.isArray(arg)) {
            len = arg.length;
            return function() {
                i++;
                return i < len ? i : null;
            };
        }
        let keys = Object.keys(arg);
        len = keys.length;
        return function() {
            i++;
            return i < len ? keys[i] : null;
        };
    }

    function once(fn) {
        return function() {
            if (fn === null) {
                return;
            }
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function each(object, iterator, callback) {
        callback = once(callback);
        let key;
        let completed = 0;

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            } else if (key === null && completed <= 0) {
                // check if key is null in case iterator isn't exhausted and done
                // was resolved synchronously.
                callback(null);
            }
        }

        let iter = getIterator(object);
        while ((key = iter()) !== null) {
            completed += 1;
            iterator(object[key], key, done);
        }
        if (completed === 0) {
            callback(null);
        }
    }

    module.exports = {

        /**
         * Execute a set of functions asynchronously, once all have been
         * completed, execute the provided callback function. Jobs may be passed
         * as an array or object. The callback function will be passed the
         * results in the same format as the tasks. All tasks must have accept
         * and execute a callback function upon completion.
         *
         * @param {Array|Object} tasks - The set of functions to execute.
         * @param {Function} callback - The callback function to be executed upon completion.
         */
        parallel: function(tasks, callback) {
            let results = Array.isArray(tasks) ? [] : {};
            each(tasks, function(task, key, done) {
                task(function(err, res) {
                    results[key] = res;
                    done(err);
                });
            }, function(err) {
                callback(err, results);
            });
        }

    };

}());

},{}],16:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {

        /**
         * Sends an GET request create an Image object.
         *
         * @param {Object} options - The XHR options.
         * @param {String} options.url - The URL for the resource.
         * @param {boolean} options.crossOrigin - Enable cross-origin request.
         * @param {Function} options.success - The success callback function.
         * @param {Function} options.error - The error callback function.
         */
        load: function (options = {}) {
            const image = new Image();
            image.onload = () => {
                if (options.success) {
                    options.success(image);
                }
            };
            image.onerror = (event) => {
                if (options.error) {
                    const err = `Unable to load image from URL: \`${event.path[0].currentSrc }\``;
                    options.error(err);
                }
            };
            image.crossOrigin = options.crossOrigin ? 'anonymous' : undefined;
            image.src = options.url;
        }
    };

}());

},{}],17:[function(require,module,exports){
(function() {

    'use strict';

    const Util = {};

    /**
     * Returns true if the argument is one of the WebGL `texImage2D` overridden
     * canvas types.
     *
     * @param {*} arg - The argument to test.
     *
     * @return {bool} - Whether or not it is a canvas type.
     */
    Util.isCanvasType = function(arg) {
        return arg instanceof ImageData ||
            arg instanceof HTMLImageElement ||
            arg instanceof HTMLCanvasElement ||
            arg instanceof HTMLVideoElement;
    };

    /**
     * Returns true if the texture MUST be a power-of-two. Otherwise return false.
     *
     * @param {Object} spec - The texture specification object.
     *
     * @return {bool} - Whether or not the texture must be a power of two.
     */
    Util.mustBePowerOfTwo = function(spec) {
        // According to:
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL#Non_power-of-two_textures
        // N-POT textures cannot be used with mipmapping and they must not "REPEAT"
        return spec.mipMap ||
            spec.wrapS === 'REPEAT' ||
            spec.wrapS === 'MIRRORED_REPEAT' ||
            spec.wrapT === 'REPEAT' ||
            spec.wrapT === 'MIRRORED_REPEAT';
    };

    /**
     * Returns true if the provided integer is a power of two.
     *
     * @param {Number} num - The number to test.
     *
     * @return {boolean} - Whether or not the number is a power of two.
     */
    Util.isPowerOfTwo = function(num) {
        return (num !== 0) ? (num & (num - 1)) === 0 : false;
    };

    /**
     * Returns the next highest power of two for a number.
     *
     * Ex.
     *
     *     200 -> 256
     *     256 -> 256
     *     257 -> 512
     *
     * @param {Number} num - The number to modify.
     *
     * @return {Number} - Next highest power of two.
     */
    Util.nextHighestPowerOfTwo = function(num) {
        if (num !== 0) {
            num = num-1;
        }
        num |= num >> 1;
        num |= num >> 2;
        num |= num >> 4;
        num |= num >> 8;
        num |= num >> 16;
        return num + 1;
    };

    /**
     * If the texture must be a POT, resizes and returns the image.
     * @private
     *
     * @param {Object} spec - The texture specification object.
     * @param {HTMLImageElement} img - The image object.
     *
     * @return {HTMLImageElement|HTMLCanvasElement} - The original image, or the resized canvas element.
     */
    Util.resizeCanvas = function(spec, img) {
        if (!Util.mustBePowerOfTwo(spec) ||
            (Util.isPowerOfTwo(img.width) && Util.isPowerOfTwo(img.height))) {
            return img;
        }
        // create an empty canvas element
        const canvas = document.createElement('canvas');
        canvas.width = Util.nextHighestPowerOfTwo(img.width);
        canvas.height = Util.nextHighestPowerOfTwo(img.height);
        // copy the image contents to the canvas
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
        return canvas;
    };

    module.exports = Util;

}());

},{}],18:[function(require,module,exports){
(function() {

    'use strict';

    module.exports = {

        /**
         * Sends an XMLHttpRequest GET request to the supplied url.
         *
         * @param {Object} options - The XHR options.
         * @param {String} options.url - The URL for the resource.
         * @param {boolean} options.crossOrigin - Enable cross-origin request.
         * @param {Function} options.success - The success callback function.
         * @param {Function} options.error - The error callback function.
         * @param {Function} options.responseType - The responseType of the XHR.
         */
        load: function (options) {
            const request = new XMLHttpRequest();
            request.open('GET', options.url, true);
            request.responseType = options.responseType;
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    if (request.status === 200) {
                        if (options.success) {
                            options.success(request.response);
                        }
                    } else {
                        if (options.error) {
                            options.error(`GET ${request.responseURL} ${request.status} (${request.statusText})`);
                        }
                    }
                }
            };
            request.withCredentials = options.crossOrigin ? true : false;
            request.send();
        }
    };

}());

},{}],19:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":20}],20:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":21,"./lib/stringify":22}],21:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],22:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],23:[function(require,module,exports){
//! moment.js
//! version : 2.15.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return this._months;
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return this._monthsShort;
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return this._weekdays;
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);

            if (tZone === 0) {
                this.utcOffset(0, true);
            } else {
                this.utcOffset(offsetFromString(matchOffset, this._i));
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.15.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],24:[function(require,module,exports){
'use strict';

module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],25:[function(require,module,exports){
'use strict';

module.exports = rbush;

var quickselect = require('quickselect');

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

},{"quickselect":24}],26:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Graph = require('../projection/Graph');

    L.CRS.Graph = L.extend({}, L.CRS, {

        projection: Graph,

        transformation: new L.Transformation(1, 0, 1, 0),

        infinite: false,

        scale: function scale(zoom) {
            return Math.pow(2, zoom);
        },

        zoom: function zoom(scale) {
            return Math.log(scale) / Math.LN2;
        },

        distance: function distance(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng;
            var dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
        }
    });

    module.exports = L.CRS.Graph;
})();

},{"../projection/Graph":70}],27:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {
        Graph: require('./Graph')
    };
})();

},{"./Graph":26}],28:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {
        Map: require('./map/Map'),
        Projection: require('./projection/exports'),
        CRS: require('./CRS/exports'),
        TileLayer: require('./layer/exports'),
        Renderer: require('./renderer/exports'),
        TileRequestor: require('./request/TileRequestor'),
        MetaRequestor: require('./request/MetaRequestor'),
        ColorRamp: {
            // expose as static method
            getColorRamp: require('./renderer/mixin/ColorRamp').getColorRamp
        }
    };
})();

},{"./CRS/exports":27,"./layer/exports":43,"./map/Map":69,"./projection/exports":71,"./renderer/exports":77,"./renderer/mixin/ColorRamp":78,"./request/MetaRequestor":104,"./request/TileRequestor":106}],29:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var setCustomAggs = function setCustomAggs(aggs) {
        this._params.custom_aggs = {
            aggs: aggs
        };
    };

    module.exports = {
        setCustomAggs: setCustomAggs
    };
})();

},{}],30:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var setDateHistogram = function setDateHistogram(field, from, to, interval) {
        if (!field) {
            throw 'DateHistogram `field` is missing from argument';
        }
        if (from === undefined) {
            throw 'DateHistogram `from` are missing from argument';
        }
        if (to === undefined) {
            throw 'DateHistogram `to` are missing from argument';
        }
        this._params.date_histogram = {
            field: field,
            from: from,
            to: to,
            interval: interval
        };
        this.clearExtrema();
        return this;
    };

    var getDateHistogram = function getDateHistogram() {
        return this._params.date_histogram;
    };

    module.exports = {
        setDateHistogram: setDateHistogram,
        getDateHistogram: getDateHistogram
    };
})();

},{}],31:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Histogram `field` ' + field + ' is not ordinal in meta data';
            }
        } else {
            throw 'Histogram `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setHistogram = function setHistogram(field, interval) {
        if (!field) {
            throw 'Histogram `field` is missing from argument';
        }
        if (!interval) {
            throw 'Histogram `interval` are missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.histogram = {
            field: field,
            interval: interval
        };
        this.clearExtrema();
        return this;
    };

    var getHistogram = function getHistogram() {
        return this._params.histogram;
    };

    module.exports = {
        setHistogram: setHistogram,
        getHistogram: getHistogram
    };
})();

},{}],32:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var METRICS = {
        'min': true,
        'max': true,
        'sum': true,
        'avg': true
    };

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Metrix `field` ' + field + ' is not ordinal in meta data';
            }
        } else {
            throw 'Metric `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setMetric = function setMetric(field, type) {
        if (!field) {
            throw 'Metric `field` is missing from argument';
        }
        if (!type) {
            throw 'Metric `type` is missing from argument';
        }
        checkField(this._meta[field], field);
        if (!METRICS[type]) {
            throw 'Metric type `' + type + '` is not supported';
        }
        this._params.metric = {
            field: field,
            type: type
        };
        this.clearExtrema();
        return this;
    };

    var getMetric = function getMetric() {
        return this._params.metric;
    };

    module.exports = {
        // tiling
        setMetric: setMetric,
        getMetric: getMetric
    };
})();

},{}],33:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTerms = function setTerms(field, size) {
        if (!field) {
            throw 'Terms `field` is missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.terms = {
            field: field,
            size: size
        };
        this.clearExtrema();
        return this;
    };

    var getTerms = function getTerms() {
        return this._params.terms;
    };

    module.exports = {
        setTerms: setTerms,
        getTerms: getTerms
    };
})();

},{}],34:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Terms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'Terms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTermsFilter = function setTermsFilter(field, terms) {
        if (!field) {
            throw 'Terms `field` is missing from argument';
        }
        if (terms === undefined) {
            throw 'Terms `terms` are missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.terms_filter = {
            field: field,
            terms: terms
        };
        this.clearExtrema();
        return this;
    };

    var getTermsFilter = function getTermsFilter() {
        return this._params.terms_filter;
    };

    module.exports = {
        setTermsFilter: setTermsFilter,
        getTermsFilter: getTermsFilter
    };
})();

},{}],35:[function(require,module,exports){
'use strict';

// Provides top hits query functionality. 'size' indicates the number of top
// hits to return, 'include' is the list of fields to include in the returned
// data, 'sort' is the field to use for sort critera, and 'order' is value of
// 'asc' or 'desc' to indicate sort ordering.
(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Range `field` ' + field + ' is not ordinal in meta data.';
            }
        } else {
            throw 'TopTerms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTopHits = function setTopHits(size, include, sort, order) {
        if (sort) {
            checkField(this._meta[sort], sort);
        }
        this._params.top_hits = {
            size: size,
            include: include,
            sort: sort,
            order: order
        };
        this.clearExtrema();
        return this;
    };

    var getTopHits = function getTopHits() {
        return this._params.top_hits;
    };

    // bind point for external controls
    var setSortField = function setSortField(sort) {
        if (!sort) {
            throw 'TopHits `sort` argument is missing';
        }
        checkField(this._meta[sort], sort);
        if (sort !== this._params.top_hits.sort) {
            this._params.top_hits.sort = sort;
            this.clearExtrema();
        }
        return this;
    };

    // bind point for external controls
    var getSortField = function getSortField() {
        return this._params.top_hits.sort;
    };

    module.exports = {
        setTopHits: setTopHits,
        getTopHits: getTopHits,
        setSortField: setSortField,
        getSortField: getSortField
    };
})();

},{}],36:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'TopTerms `field` ' + field + ' is not of type `string` in meta data';
            }
        } else {
            throw 'TopTerms `field` ' + field + ' is not recognized in meta data';
        }
    };

    var setTopTerms = function setTopTerms(field, size) {
        if (!field) {
            throw 'TopTerms `field` is missing from argument';
        }
        checkField(this._meta[field], field);
        this._params.top_terms = {
            field: field,
            size: size
        };
        this.clearExtrema();
        return this;
    };

    var getTopTerms = function getTopTerms() {
        return this._params.top_terms;
    };

    module.exports = {
        setTopTerms: setTopTerms,
        getTopTerms: getTopTerms
    };
})();

},{}],37:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Base = L.GridLayer.extend({

        options: {
            tms: false
        },

        getOpacity: function getOpacity() {
            return this.options.opacity;
        },

        show: function show() {
            this._hidden = false;
            this._prevMap.addLayer(this);
        },

        hide: function hide() {
            this._hidden = true;
            this._prevMap = this._map;
            this._map.removeLayer(this);
        },

        isHidden: function isHidden() {
            return this._hidden;
        },

        setBrightness: function setBrightness(brightness) {
            this._brightness = brightness;
            $(this._container).css('-webkit-filter', 'brightness(' + this._brightness * 100 + '%)');
            $(this._container).css('filter', 'brightness(' + this._brightness * 100 + '%)');
        },

        getBrightness: function getBrightness() {
            return this._brightness !== undefined ? this._brightness : 1;
        },

        isTargetLayer: function isTargetLayer(elem) {
            return this._container && this._container === elem || $.contains(this._container, elem);
        },

        _getLayerPointFromLonLat: function _getLayerPointFromLonLat(lonlatPoint, zoom) {
            zoom = zoom !== undefined ? zoom : this._map.getZoom();
            var pixel = this._map.project(lonlatPoint, zoom);
            var pow = Math.pow(2, zoom);
            var tileSize = this.options.tileSize;
            return {
                x: mod(pixel.x, pow * tileSize),
                y: mod(pixel.y, pow * tileSize)
            };
        },

        getLayerPointFromEvent: function getLayerPointFromEvent(e) {
            var lonlat = this._map.mouseEventToLatLng(e);
            return this._getLayerPointFromLonLat(lonlat);
        },

        getTileCoordFromLayerPoint: function getTileCoordFromLayerPoint(layerPoint) {
            var tileSize = this.options.tileSize;
            return {
                x: Math.floor(layerPoint.x / tileSize),
                y: Math.floor(layerPoint.y / tileSize),
                z: this._map.getZoom()
            };
        },

        getBinCoordFromLayerPoint: function getBinCoordFromLayerPoint(layerPoint, res) {
            var tileSize = this.options.tileSize;
            var resolution = res || this.getResolution() || tileSize;
            var tx = mod(layerPoint.x, tileSize);
            var y = this.options.tms ? resolution - layerPoint.y : layerPoint.y;
            var ty = mod(y, tileSize);
            var pixelSize = tileSize / resolution;
            var bx = Math.floor(tx / pixelSize);
            var by = Math.floor(ty / pixelSize);
            return {
                x: bx,
                y: by,
                index: bx + by * resolution,
                size: pixelSize
            };
        },

        _addTile: function _addTile(coords, container) {
            var tilePos = this._getTilePos(coords);
            var key = this._tileCoordsToKey(coords);
            // Override so that we don't pass in wrapped coords here
            var tile = this.createTile(coords, L.bind(this._tileReady, this, coords));
            this._initTile(tile);
            // if createTile is defined with a second argument ("done" callback),
            // we know that tile is async and will be ready later; otherwise
            if (this.createTile.length < 2) {
                // mark tile as ready, but delay one frame for opacity animation to happen
                L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
            }
            L.DomUtil.setPosition(tile, tilePos);
            // save tile in cache
            this._tiles[key] = {
                el: tile,
                coords: coords,
                current: true
            };
            container.appendChild(tile);
            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                tile: tile,
                coords: coords
            });
        },

        _isValidTile: function _isValidTile(coords) {
            var crs = this._map.options.crs;

            if (!crs.infinite) {
                // don't load tile if it's out of bounds and not wrapped
                var bounds = this._globalTileRange;
                if ((!crs.wrapLng || this.options.noWrap) && (coords.x < bounds.min.x || coords.x > bounds.max.x) || (!crs.wrapLat || this.options.noWrap) && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                    return false;
                }
            }

            if (!this.options.bounds) {
                return true;
            }

            // don't load tile if it doesn't intersect the bounds in options
            var tileBounds = this._tileCoordsToBounds(coords);
            return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
        }
    });

    module.exports = Base;
})();

},{}],38:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    function validToCopy(funcName) {
        return funcName !== 'constructor' && funcName !== 'on' && funcName !== 'off' && funcName !== 'setQuery' && funcName !== 'clearQuery' && funcName[0] !== '_';
    }

    var Composite = L.Class.extend({

        initialize: function initialize() {
            var _this = this;

            var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            var functions = {};
            // get a list of all functions for each layer
            layers.forEach(function (layer) {
                _.forIn(layer, function (val, key) {
                    if (_.isFunction(val) && validToCopy(key)) {
                        functions[key] = functions[key] || [];
                        functions[key].push(layer);
                    }
                });
            });
            // set properties
            this._layers = layers;
            this._functions = functions;
            this._handlers = {};
            this._query = null;
            // extend this composite class for each function
            _.forIn(functions, function (layers, func) {
                _this._extend(func);
            });
        },

        on: function on(evt, func) {
            this._layers.forEach(function (layer) {
                layer.on(evt, func);
            });
            this._handlers[evt] = this._handlers[evt] || [];
            this._handlers[evt].push(func);
        },

        off: function off(evt, func) {
            var handlers = this._handlers[evt];
            if (handlers) {
                var index = handlers.indexOf(func);
                if (index !== -1) {
                    this._layers.forEach(function (layer) {
                        layer.off(evt, func);
                    });
                    handlers.splice(index, 1);
                    if (handlers.length === 0) {
                        delete this._handlers[evt];
                    }
                }
            }
        },

        setQuery: function setQuery(query) {
            this._layers.forEach(function (layer) {
                layer.setQuery(query);
            });
            this._query = query;
        },

        clearQuery: function clearQuery() {
            if (this._query) {
                this._layers.forEach(function (layer) {
                    layer.clearQuery();
                });
                this._query = null;
            }
        },

        _extend: function _extend(func) {
            var functions = this._functions;
            this[func] = function () {
                var layers = functions[func];
                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];
                    var result = layer[func].apply(layer, arguments);
                    if (result !== undefined && result !== layer) {
                        return result;
                    }
                }
            };
        },

        addSubLayer: function addSubLayer(layer) {
            var _this2 = this;

            var index = this._layers.indexOf(layer);
            if (index !== -1) {
                return;
            }
            var functions = this._functions;
            _.forIn(layer, function (val, key) {
                // if it is a function and valid to copy
                if (_.isFunction(val) && validToCopy(key)) {
                    // add layer to functions
                    functions[key] = functions[key] || [];
                    functions[key].push(layer);
                    if (functions[key].length === 1) {
                        // if a new function, extend the object
                        _this2._extend(key);
                    }
                }
            });
            // add to layers
            this._layers.push(layer);
            // add handlers to layer
            _.forIn(this._handlers, function (handlers, evt) {
                handlers.forEach(function (func) {
                    layer.on(evt, func);
                });
            });
            if (this._query) {
                // add query to layer
                layer.setQuery(this._query);
            }
        },

        removeSubLayer: function removeSubLayer(layer) {
            var _this3 = this;

            var index = this._layers.indexOf(layer);
            if (index === -1) {
                return;
            }
            var functions = this._functions;
            // remove all functions used exclusively by this layer
            _.forIn(layer, function (val, key) {
                if (_.isFunction(val) && validToCopy(key)) {
                    var _index = functions[key].indexOf(layer);
                    if (_index !== -1) {
                        // remove from function list
                        functions[key].splice(_index, 1);
                    }
                    // if exclusive owner of function
                    if (functions[key].length === 0) {
                        // no more use for this function, remove it
                        delete functions[key];
                        delete _this3[key];
                    }
                }
            });
            // remove layer
            this._layers.splice(index, 1);
            // remove handlers from layer
            _.forIn(this._handlers, function (handlers, evt) {
                handlers.forEach(function (func) {
                    layer.off(evt, func);
                });
            });
            // clear the query from the layer
            layer.clearQuery();
        }
    });

    module.exports = Composite;
})();

},{}],39:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('./Base');

    var Debug = Base.extend({

        options: {
            unloadInvisibleTiles: true,
            zIndex: 5000
        },

        initialize: function initialize(options) {
            // set renderer
            if (!options.rendererClass) {
                throw 'No `rendererClass` option found.';
            } else {
                // recursively extend
                $.extend(true, this, options.rendererClass);
            }
            // set options
            L.setOptions(this, options);
        },

        createTile: function createTile(coord) {
            // create a <div> element for drawing
            var tile = L.DomUtil.create('div', 'leaflet-tile');
            // draw to it
            this.renderTile(tile, coord);
            // pass tile to callback
            return tile;
        },

        renderTile: function renderTile() {
            // override
        }

    });

    module.exports = Debug;
})();

},{"./Base":37}],40:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Image = L.TileLayer.extend({

        getOpacity: function getOpacity() {
            return this.options.opacity;
        },

        show: function show() {
            this._hidden = false;
            this._prevMap.addLayer(this);
        },

        hide: function hide() {
            this._hidden = true;
            this._prevMap = this._map;
            this._map.removeLayer(this);
        },

        isHidden: function isHidden() {
            return this._hidden;
        },

        setBrightness: function setBrightness(brightness) {
            this._brightness = brightness;
            $(this._container).css('-webkit-filter', 'brightness(' + this._brightness * 100 + '%)');
            $(this._container).css('filter', 'brightness(' + this._brightness * 100 + '%)');
        },

        getBrightness: function getBrightness() {
            return this._brightness !== undefined ? this._brightness : 1;
        }
    });

    module.exports = Image;
})();

},{}],41:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var boolQueryCheck = require('../query/Bool');

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Live = L.Class.extend({

        options: {
            transform: function transform(val) {
                return val;
            }
        },

        initialize: function initialize(meta) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // set renderer
            if (options.rendererClass) {
                var renderer = void 0;
                // recursively extend and initialize
                if (options.rendererClass.prototype) {
                    renderer = new options.rendererClass();
                } else {
                    renderer = options.rendererClass;
                }
                // extend this object
                $.extend(true, this, renderer);
                // copy prototype options property by value, this is important
                this.options = $.extend(true, {}, this.options);
                delete options.rendererClass;
            }
            // set options
            L.setOptions(this, options);
            // set meta
            this._meta = meta;
            // set params
            this._params = {
                binning: {}
            };
            // set extrema / cache
            this._cache = {};
            this.clearExtrema();
        },

        clearExtrema: function clearExtrema() {
            this._extrema = {
                min: Number.MAX_VALUE,
                max: 0
            };
        },

        getExtrema: function getExtrema() {
            return this._extrema;
        },

        updateExtrema: function updateExtrema(data) {
            var extrema = this.extractExtrema(data);
            var changed = false;
            if (extrema.min < this._extrema.min) {
                changed = true;
                this._extrema.min = extrema.min;
            }
            if (extrema.max > this._extrema.max) {
                changed = true;
                this._extrema.max = extrema.max;
            }
            return changed;
        },

        extractExtrema: function extractExtrema(data) {
            return {
                min: _.min(data),
                max: _.max(data)
            };
        },

        setQuery: function setQuery(query) {
            if (!query.must && !query.must_not && !query.should) {
                throw 'Root query must have at least one `must`, `must_not`, or `should` argument.';
            }
            // check that the query is valid
            boolQueryCheck(this._meta, query);
            // set query
            this._params.must = query.must;
            this._params.must_not = query.must_not;
            this._params.should = query.should;
            // cleat extrema
            this.clearExtrema();
        },

        getQuery: function getQuery() {
            return {
                must: this._params.must,
                must_not: this._params.must_not,
                should: this._params.should
            };
        },

        clearQuery: function clearQuery() {
            // clear query
            this._params.must = undefined;
            this._params.must_not = undefined;
            this._params.should = undefined;
            // cleat extrema
            this.clearExtrema();
        },

        getMeta: function getMeta() {
            return this._meta;
        },

        getParams: function getParams() {
            return this._params;
        },

        getNormalizedCoords: function getNormalizedCoords(coords) {
            var pow = Math.pow(2, coords.z);
            return {
                x: mod(coords.x, pow),
                y: mod(coords.y, pow),
                z: coords.z
            };
        },

        cacheKeyFromCoord: function cacheKeyFromCoord(coords, normalize) {
            if (normalize) {
                // leaflet layer x and y may be > n^2, and < 0 in the case
                // of a wraparound. If normalize is true, mod the coords
                coords = this.getNormalizedCoords(coords);
            }
            return coords.z + ':' + coords.x + ':' + coords.y;
        },

        coordFromCacheKey: function coordFromCacheKey(key) {
            var arr = key.split(':');
            return {
                x: parseInt(arr[1], 10),
                y: parseInt(arr[2], 10),
                z: parseInt(arr[0], 10)
            };
        },

        onTileUnload: function onTileUnload(event) {
            var coords = event.coords;
            // respect the TMS setting in the options
            if (this.options.tms) {
                coords = {
                    x: event.coords.x,
                    y: Math.pow(2, event.coords.z) - 1 - event.coords.y,
                    z: event.coords.z
                };
            }
            // cache key from coords
            var key = this.cacheKeyFromCoord(coords);
            // cache key from normalized coords
            var nkey = this.cacheKeyFromCoord(coords, true);
            // get cache entry
            var cached = this._cache[nkey];
            // could the be case where the cache is cleared before tiles are
            // unloaded
            if (!cached) {
                return;
            }
            // remove the tile from the cache
            delete cached.tiles[key];
            // don't remove cache entry unless to tiles use it anymore
            if (_.keys(cached.tiles).length === 0) {
                // get the tile being deleted
                var tile = cached.tiles[key];
                // no more tiles use this cached data, so delete it
                this.fire('cacheunload', {
                    tile: tile,
                    coords: coords,
                    entry: cached
                });
                delete this._cache[nkey];
            }
        },

        _requestTile: function _requestTile(coords, tile, callback) {
            var _this = this;

            // respect the TMS setting in the options
            if (this.options.tms) {
                coords = {
                    x: coords.x,
                    y: Math.pow(2, coords.z) - 1 - coords.y,
                    z: coords.z
                };
            }
            var ncoords = this.getNormalizedCoords(coords);
            // cache key from coords
            var key = this.cacheKeyFromCoord(coords);
            // cache key from normalized coords
            var nkey = this.cacheKeyFromCoord(coords, true);
            // check cache
            var cached = this._cache[nkey];
            if (cached) {
                // add tile under normalize coords
                cached.tiles[key] = tile;
                if (!cached.isPending) {
                    // cache entry already exists
                    this.fire('cachehit', {
                        tile: tile,
                        coords: coords,
                        entry: cached
                    });
                    // execute callback
                    window.requestAnimationFrame(callback);
                } else {
                    // tile is already pending, add callback
                    cached.callbacks.push(callback);
                }
            } else {
                // create a cache entry
                this._cache[nkey] = {
                    isPending: true,
                    tiles: {},
                    data: null,
                    callbacks: [callback]
                };
                // add tile to the cache entry
                this._cache[nkey].tiles[key] = tile;
                // request the tile
                this.requestTile(ncoords, function (data) {
                    var cached = _this._cache[nkey];
                    if (!cached) {
                        // tile is no longer being tracked, ignore
                        return;
                    }
                    // flag as no longer pending
                    cached.isPending = false;
                    // transform and store tile data in cache
                    cached.data = _this.options.transform(data);
                    // execute pending callbacks
                    cached.callbacks.forEach(function (callback) {
                        callback();
                    });
                    cached.callbacks = [];
                    // data is loaded into cache
                    _this.fire('cacheload', {
                        tile: tile,
                        coords: coords,
                        entry: cached
                    });
                    if (cached.data) {
                        // update the extrema
                        if (_this.updateExtrema(cached.data)) {
                            // if extrema changed, fire event
                            _this.fire('extremachange', {
                                tile: tile,
                                coords: coords,
                                entry: cached
                            });
                        }
                    }
                });
            }
        },

        requestTile: function requestTile() {
            // override
        }

    });

    module.exports = Live;
})();

},{"../query/Bool":47}],42:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('./Base');

    function mod(n, m) {
        return (n % m + m) % m;
    }

    var Pending = Base.extend({

        options: {
            unloadInvisibleTiles: true,
            zIndex: 5000
        },

        initialize: function initialize(options) {
            this._pendingTiles = {};
            // set renderer
            if (!options.rendererClass) {
                throw 'No `rendererClass` option found.';
            } else {
                // recursively extend
                $.extend(true, this, options.rendererClass);
            }
            // set options
            L.setOptions(this, options);
        },

        add: function add(layer) {
            var _this = this;

            layer._incrementHandler = function (tile) {
                _this._increment(tile.coords);
            };
            layer._decrementHandler = function (tile) {
                _this._decrement(tile.coords);
            };
            layer.on('tilestartload', layer._incrementHandler);
            layer.on('tileload', layer._decrementHandler);
            layer.on('tileerror', layer._decrementHandler);
        },

        remove: function remove(layer) {
            layer.off('tilestartload', layer._incrementHandler);
            layer.off('tileload', layer._decrementHandler);
            layer.off('tileerror', layer._decrementHandler);
            layer._incrementHandler = null;
            layer._decrementHandler = null;
        },

        _increment: function _increment(coord) {
            var _this2 = this;

            var hash = this._getTileHash(coord);
            if (this._pendingTiles[hash] === undefined) {
                this._pendingTiles[hash] = 1;
                var tiles = this._getTilesWithHash(hash);
                tiles.forEach(function (tile) {
                    _this2._updateTile(coord, tile);
                });
            } else {
                this._pendingTiles[hash]++;
            }
        },

        _decrement: function _decrement(coord) {
            var _this3 = this;

            var hash = this._getTileHash(coord);
            this._pendingTiles[hash]--;
            if (this._pendingTiles[hash] === 0) {
                delete this._pendingTiles[hash];
                var tiles = this._getTilesWithHash(hash);
                tiles.forEach(function (tile) {
                    _this3._updateTile(coord, tile);
                });
            }
        },

        _getTileClass: function _getTileClass(hash) {
            return 'leaflet-pending-' + hash;
        },

        _getNormalizedCoords: function _getNormalizedCoords(coords) {
            var pow = Math.pow(2, coords.z);
            return {
                x: mod(coords.x, pow),
                y: mod(coords.y, pow),
                z: coords.z
            };
        },

        _getTileHash: function _getTileHash(coords) {
            var ncoords = this._getNormalizedCoords(coords);
            return ncoords.z + '-' + ncoords.x + '-' + ncoords.y;
        },

        _getTilesWithHash: function _getTilesWithHash(hash) {
            var _this4 = this;

            var className = this._getTileClass(hash);
            var tiles = [];
            $(this._container).find('.' + className).each(function () {
                tiles.push(_this4);
            });
            return tiles;
        },

        _updateTile: function _updateTile(coord, tile) {
            // get hash
            var hash = this._getTileHash(coord);
            $(tile).addClass(this._getTileClass(hash) + ' pending');
            if (this._pendingTiles[hash] > 0) {
                this.renderTile(tile, coord);
            } else {
                $(tile).removeClass('pending');
                tile.innerHTML = '';
            }
        },

        createTile: function createTile(coord) {
            // create a <div> element for drawing
            var tile = L.DomUtil.create('div', 'leaflet-tile leaflet-tile-pending');
            // get hash
            this._updateTile(coord, tile);
            // pass tile to callback
            return tile;
        },

        renderTile: function renderTile() {
            // override
        }

    });

    module.exports = Pending;
})();

},{"./Base":37}],43:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    // debug tile layer

    var Debug = require('./core/Debug');

    // pending tile layer
    var Pending = require('./core/Pending');

    // image layer
    var Image = require('./core/Image');

    // composite layer
    var Composite = require('./core/Composite');

    // live layer - base type for extension
    var Live = require('./core/Live');

    // live tile layers
    var Heatmap = require('./type/Heatmap');
    var TopTrails = require('./type/TopTrails');
    var TopCount = require('./type/TopCount');
    var TopFrequency = require('./type/TopFrequency');
    var Frequency = require('./type/Frequency');
    var TopicCount = require('./type/TopicCount');
    var TopicFrequency = require('./type/TopicFrequency');
    var Preview = require('./type/Preview');
    var Macro = require('./type/Macro');
    var Micro = require('./type/Micro');
    var Count = require('./type/Count');
    var Community = require('./type/Community');
    var Custom = require('./type/Custom');

    module.exports = {
        Debug: Debug,
        Pending: Pending,
        Image: Image,
        Composite: Composite,
        Live: Live,
        Heatmap: Heatmap,
        TopCount: TopCount,
        TopTrails: TopTrails,
        TopFrequency: TopFrequency,
        Frequency: Frequency,
        TopicCount: TopicCount,
        TopicFrequency: TopicFrequency,
        Preview: Preview,
        Macro: Macro,
        Micro: Micro,
        Count: Count,
        Community: Community,
        Custom: Custom
    };
})();

},{"./core/Composite":38,"./core/Debug":39,"./core/Image":40,"./core/Live":41,"./core/Pending":42,"./type/Community":56,"./type/Count":57,"./type/Custom":58,"./type/Frequency":59,"./type/Heatmap":60,"./type/Macro":61,"./type/Micro":62,"./type/Preview":63,"./type/TopCount":64,"./type/TopFrequency":65,"./type/TopTrails":66,"./type/TopicCount":67,"./type/TopicFrequency":68}],44:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DEFAULT_RESOLUTION = 256;

    var Tiling = require('./Tiling');

    var setResolution = function setResolution(resolution) {
        if (resolution !== this._params.binning.resolution) {
            this._params.binning.resolution = resolution;
            this.clearExtrema();
        }
        return this;
    };

    var getResolution = function getResolution() {
        return this._params.binning.resolution || DEFAULT_RESOLUTION;
    };

    module.exports = {
        // tiling
        setXField: Tiling.setXField,
        getXField: Tiling.getXField,
        setYField: Tiling.setYField,
        getYField: Tiling.getYField,
        getLayerPointFromDataPoint: Tiling.getLayerPointFromDataPoint,
        getDataPointFromLayerPoint: Tiling.getDataPointFromLayerPoint,
        DEFAULT_X_FIELD: Tiling.DEFAULT_X_FIELD,
        DEFAULT_Y_FIELD: Tiling.DEFAULT_Y_FIELD,
        DEFAULT_PIXEL_MAX: Tiling.DEFAULT_PIXEL_MAX,
        // binning
        setResolution: setResolution,
        getResolution: getResolution,
        DEFAULT_RESOLUTION: DEFAULT_RESOLUTION
    };
})();

},{"./Tiling":46}],45:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var getTypes = function getTypes() {
        return this._params.elastic ? this._params.elastic.type : undefined;
    };

    var setTypes = function setTypes(types) {
        if (!types) {
            throw 'QueryString `types` are not provided.';
        }
        types = Array.isArray(types) ? types : [types];
        this._params.elastic = {
            types: types
        };
    };

    module.exports = {
        setTypes: setTypes,
        getTypes: getTypes
    };
})();

},{}],46:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var moment = require('moment');

    var DEFAULT_TILE_SIZE = 256;
    var DEFAULT_X_FIELD = 'pixel.x';
    var DEFAULT_Y_FIELD = 'pixel.y';
    var DEFAULT_PIXEL_MIN = 0;
    var DEFAULT_PIXEL_MAX = Math.pow(2, 32);

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.extrema) {
                return true;
            } else {
                throw 'Field `' + field + '` is not ordinal in meta data.';
            }
        } else {
            throw 'Field `' + field + '` is not recognized in meta data.';
        }
        return false;
    };

    var setXField = function setXField(field, type, relationship) {
        if (field !== this._params.binning.x) {
            if (field.indexOf(DEFAULT_X_FIELD) !== -1) {
                // reset if default
                this._params.binning.x = field;
                this._params.binning.left = DEFAULT_PIXEL_MIN;
                this._params.binning.right = DEFAULT_PIXEL_MAX;
                this.clearExtrema();
            } else {
                var meta = this._meta[field];
                if (checkField(meta, field)) {
                    this._params.binning.x = field;
                    this._params.binning.left = meta.extrema.min;
                    this._params.binning.right = meta.extrema.max;
                    this.clearExtrema();
                }
            }
        }
        this._params.binning.xType = type;
        this._params.binning.xRelationship = relationship;
        return this;
    };

    var getXField = function getXField() {
        return this._params.binning.x;
    };

    var setYField = function setYField(field, type, relationship) {
        if (field !== this._params.binning.y) {
            if (field.indexOf(DEFAULT_Y_FIELD) !== -1) {
                // reset if default
                this._params.binning.y = field;
                this._params.binning.bottom = DEFAULT_PIXEL_MAX;
                this._params.binning.top = DEFAULT_PIXEL_MIN;
                this.clearExtrema();
            } else {
                var meta = this._meta[field];
                if (checkField(meta, field)) {
                    this._params.binning.y = field;
                    this._params.binning.bottom = meta.extrema.min;
                    this._params.binning.top = meta.extrema.max;
                    this.clearExtrema();
                }
            }
        }
        this._params.binning.yType = type;
        this._params.binning.yRelationship = relationship;
        return this;
    };

    var getYField = function getYField() {
        return this._params.binning.y;
    };

    var getLayerPointFromDataPoint = function getLayerPointFromDataPoint(x, y, zoom) {
        var binning = this._params.binning;
        var tileSize = this.options.tileSize || DEFAULT_TILE_SIZE;
        var pow = Math.pow(2, zoom);
        var extent = tileSize * pow;
        var meta = this.getMeta();

        var left = void 0,
            right = void 0,
            bottom = void 0,
            top = void 0;
        if (meta[binning.x].type === 'date') {
            left = moment(binning.left).valueOf();
            right = moment(binning.right).valueOf();
            x = moment(x).valueOf();
        } else {
            left = binning.left;
            right = binning.right;
        }
        if (meta[binning.y].type === 'date') {
            bottom = moment(binning.bottom).valueOf();
            top = moment(binning.top).valueOf();
            y = moment(y).valueOf();
        } else {
            bottom = binning.bottom;
            top = binning.top;
        }

        var xRange = Math.abs(right - left);
        var yRange = Math.abs(bottom - top);
        var nx = void 0,
            ny = void 0;
        if (left > right) {
            nx = 1 - (x - right) / xRange;
        } else {
            nx = (x - left) / xRange;
        }
        if (top > bottom) {
            ny = 1 - (y - bottom) / yRange;
        } else {
            ny = (y - top) / yRange;
        }
        return {
            x: extent * nx,
            y: extent * ny
        };
    };

    var getDataPointFromLayerPoint = function getDataPointFromLayerPoint(x, y, zoom) {
        var binning = this._params.binning;
        var tileSize = this.options.tileSize || DEFAULT_TILE_SIZE;
        var pow = Math.pow(2, zoom);
        var extent = tileSize * pow;
        var nx = x / extent;
        var ny = y / extent;
        var xRange = Math.abs(binning.right - binning.left);
        var yRange = Math.abs(binning.bottom - binning.top);
        var px = void 0,
            py = void 0;
        if (binning.left > binning.right) {
            px = binning.right + (1 - nx) * xRange;
        } else {
            px = binning.left + nx * xRange;
        }
        if (binning.top > binning.bottom) {
            py = binning.bottom + (1 - ny) * yRange;
        } else {
            py = binning.top + ny * yRange;
        }
        return {
            x: px,
            y: py
        };
    };

    module.exports = {
        setXField: setXField,
        getXField: getXField,
        setYField: setYField,
        getYField: getYField,
        getLayerPointFromDataPoint: getLayerPointFromDataPoint,
        getDataPointFromLayerPoint: getDataPointFromLayerPoint,
        DEFAULT_X_FIELD: DEFAULT_X_FIELD,
        DEFAULT_Y_FIELD: DEFAULT_Y_FIELD,
        DEFAULT_PIXEL_MAX: DEFAULT_PIXEL_MAX
    };
})();

},{"moment":23}],47:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var check = void 0;

    function checkQuery(meta, query) {
        var keys = _.keys(query);
        if (keys.length !== 1) {
            throw 'Bool sub-query must only have a single key, query has multiple keys: `' + JSON.stringify(keys) + '`.';
        }
        var type = keys[0];
        var checkFunc = check[type];
        if (!checkFunc) {
            throw 'Query type `' + type + '` is not recognized.';
        }
        // check query by type
        check[type](meta, query[type]);
    }

    function checkQueries(meta, queries) {
        if (_.isArray(queries)) {
            queries.forEach(function (query) {
                checkQuery(meta, query);
            });
            return queries;
        }
        checkQuery(meta, queries);
        return [queries];
    }

    function checkBool(meta, query) {
        if (!query.must && !query.must_not && !query.should) {
            throw 'Bool must have at least one `must`, `must_not`, or `should` query argument.';
        }
        if (query.must) {
            checkQueries(meta, query.must);
        }
        if (query.must_not) {
            checkQueries(meta, query.must_not);
        }
        if (query.should) {
            checkQueries(meta, query.should);
        }
    }

    check = {
        bool: checkBool,
        exists: require('./Exists'),
        prefix: require('./Prefix'),
        query_string: require('./QueryString'),
        range: require('./Range'),
        terms: require('./Terms'),
        match: require('./Match'),
        has_parent: require('./HasParent'),
        has_child: require('./HasChild')
    };

    module.exports = checkBool;
})();

},{"./Exists":48,"./HasChild":49,"./HasParent":50,"./Match":51,"./Prefix":52,"./QueryString":53,"./Range":54,"./Terms":55}],48:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (!meta) {
            throw 'Exists `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Exists `field` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],49:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = function (meta, query) {
        if (!query.type) {
            throw 'has-child `type` is missing from argument.';
        }
        if (!query.query) {
            throw 'has-child `query` is missing from argument.';
        }
        if (!query.query.bool) {
            throw 'has-child `query.bool` is missing from argument.';
        }
    };
})();

},{}],50:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = function (meta, query) {
        if (!query.parent_type) {
            throw 'has-parent `parent_type` is missing from argument.';
        }
        if (!query.query) {
            throw 'has-parent `query` is missing from argument.';
        }
        if (!query.query.bool) {
            throw 'has-parent `query.bool` is missing from argument.';
        }
    };
})();

},{}],51:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Match `field` ' + field + ' is not `string` in meta data.';
            }
        } else {
            throw 'Match `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Match `field` is missing from argument.';
        }
        if (!query.string) {
            throw 'Match `string` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],52:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'Prefix `field` ' + field + ' is not of type `string` in meta data.';
            }
        } else {
            throw 'Prefix `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Prefix `field` is missing from argument';
        }
        if (query.prefixes === undefined) {
            throw 'Prefix `prefixes` are missing from argument';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],53:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (meta.type !== 'string') {
                throw 'QueryString `field` ' + field + ' is not `string` in meta data.';
            }
        } else {
            throw 'QueryString `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'QueryString `field` is missing from argument.';
        }
        if (!query.string) {
            throw 'QueryString `string` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],54:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var checkField = function checkField(meta, field) {
        if (meta) {
            if (!meta.extrema) {
                throw 'Range `field` ' + field + ' is not ordinal in meta data.';
            }
        } else {
            throw 'Range `field` ' + field + ' is not recognized in meta data.';
        }
    };

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Range `field` is missing from argument.';
        }
        if (query.from === undefined) {
            throw 'Range `from` is missing from argument.';
        }
        if (query.to === undefined) {
            throw 'Range `to` is missing from argument.';
        }
        checkField(meta[query.field], query.field);
    };
})();

},{}],55:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = function (meta, query) {
        if (!query.field) {
            throw 'Terms `field` is missing from argument.';
        }
        if (query.terms === undefined) {
            throw 'Terms `terms` are missing from argument.';
        }
        query.terms = Array.isArray(query.terms) ? query.terms : [query.terms];
    };
})();

},{}],56:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopHits = require('../agg/TopHits');

    var Community = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopHits],

        options: {
            degreeField: 'properties.degree'
        },

        type: 'micro',

        // extreme not relevant for micro
        extractExtrema: function extractExtrema(data) {
            var _this = this;

            if (!data || data.length === 0) {
                return {
                    min: Infinity,
                    max: -Infinity
                };
            }
            return {
                min: _.get(_.minBy(data, function (community) {
                    return _.get(community, _this.options.degreeField);
                }), this.options.degreeField),
                max: _.get(_.maxBy(data, function (community) {
                    return _.get(community, _this.options.degreeField);
                }), this.options.degreeField)
            };
        }
    });

    module.exports = Community;
})();

},{"../agg/TopHits":35,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],57:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');

    var Count = Live.extend({

        includes: [
        // params
        Elastic, Tiling],

        type: 'count',

        // extreme not relevant for count tile
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Count;
})();

},{"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],58:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var CustomAggs = require('../agg/CustomAggs');

    var Custom = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        CustomAggs],

        type: 'custom_tile'

    });

    module.exports = Custom;
})();

},{"../agg/CustomAggs":29,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],59:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');

    var Frequency = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        DateHistogram, Histogram],

        type: 'frequency'

    });

    module.exports = Frequency;
})();

},{"../agg/DateHistogram":30,"../agg/Histogram":31,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],60:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var Metric = require('../agg/Metric');

    var Heatmap = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        Metric],

        type: 'heatmap',

        extractExtrema: function extractExtrema(data) {
            var bins = new Float64Array(data);
            return {
                min: _.min(bins),
                max: _.max(bins)
            };
        }

    });

    module.exports = Heatmap;
})();

},{"../agg/Metric":32,"../core/Live":41,"../param/Binning":44,"../param/Elastic":45}],61:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');

    var Macro = Live.extend({

        includes: [
        // params
        Elastic, Binning],

        type: 'macro',

        extractExtrema: function extractExtrema(data) {
            var bins = new Float64Array(data);
            return {
                min: _.min(bins),
                max: _.max(bins)
            };
        }

    });

    module.exports = Macro;
})();

},{"../core/Live":41,"../param/Binning":44,"../param/Elastic":45}],62:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopHits = require('../agg/TopHits');

    var Micro = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopHits],

        type: 'micro',

        // extreme not relevant for micro
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Micro;
})();

},{"../agg/TopHits":35,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],63:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var TopHits = require('../agg/TopHits');

    var Preview = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        TopHits],

        type: 'preview',

        // extreme not relevant for preview
        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }
    });

    module.exports = Preview;
})();

},{"../agg/TopHits":35,"../core/Live":41,"../param/Binning":44,"../param/Elastic":45}],64:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopTerms = require('../agg/TopTerms');
    var Histogram = require('../agg/Histogram');
    var TopHits = require('../agg/TopHits');

    var TopCount = Live.extend({

        includes: [
        // params
        Elastic, Tiling, TopTerms,
        // aggs
        Histogram, TopHits],

        type: 'top_count'

    });

    module.exports = TopCount;
})();

},{"../agg/Histogram":31,"../agg/TopHits":35,"../agg/TopTerms":36,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],65:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TopTerms = require('../agg/TopTerms');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');
    var TopHits = require('../agg/TopHits');

    var TopFrequency = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TopTerms, DateHistogram, Histogram, TopHits],

        type: 'top_frequency'

    });

    module.exports = TopFrequency;
})();

},{"../agg/DateHistogram":30,"../agg/Histogram":31,"../agg/TopHits":35,"../agg/TopTerms":36,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],66:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Binning = require('../param/Binning');
    var Terms = require('../agg/Terms');

    var TopTrails = Live.extend({

        includes: [
        // params
        Elastic, Binning,
        // aggs
        Terms],

        type: 'top_trails',

        extractExtrema: function extractExtrema() {
            return {
                min: Infinity,
                max: -Infinity
            };
        }

    });

    module.exports = TopTrails;
})();

},{"../agg/Terms":33,"../core/Live":41,"../param/Binning":44,"../param/Elastic":45}],67:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TermsFilter = require('../agg/TermsFilter');
    var Histogram = require('../agg/Histogram');

    var TopicCount = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TermsFilter, Histogram],

        type: 'topic_count'

    });

    module.exports = TopicCount;
})();

},{"../agg/Histogram":31,"../agg/TermsFilter":34,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],68:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Live = require('../core/Live');
    var Elastic = require('../param/Elastic');
    var Tiling = require('../param/Tiling');
    var TermsFilter = require('../agg/TermsFilter');
    var DateHistogram = require('../agg/DateHistogram');
    var Histogram = require('../agg/Histogram');

    var TopicFrequency = Live.extend({

        includes: [
        // params
        Elastic, Tiling,
        // aggs
        TermsFilter, DateHistogram, Histogram],

        type: 'topic_frequency'

    });

    module.exports = TopicFrequency;
})();

},{"../agg/DateHistogram":30,"../agg/Histogram":31,"../agg/TermsFilter":34,"../core/Live":41,"../param/Elastic":45,"../param/Tiling":46}],69:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var resetMouseCursorStyle = function resetMouseCursorStyle() {
        // we only want this bound ONCE per map
        $(this._container).css('cursor', '');
    };

    var Map = L.Map.extend({

        initialize: function initialize() {
            L.Map.prototype.initialize.apply(this, arguments);
            this.on('mousemove', resetMouseCursorStyle, this);
        }

    });

    module.exports = Map;
})();

},{}],70:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    // cartesian projection in (0,0), (256, 256) coordinate space

    L.Projection.Graph = {

        project: function project(latlng) {
            return new L.Point(latlng.lng, latlng.lat);
        },

        unproject: function unproject(point) {
            return new L.LatLng(point.y, point.x);
        },

        bounds: L.bounds([0, 0], [256, 256])
    };

    module.exports = L.Projection.Graph;
})();

},{}],71:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./Graph":70,"dup":27}],72:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DOM = require('./DOM');

    var Canvas = DOM.extend({

        onAdd: function onAdd(map) {
            DOM.prototype.onAdd.call(this, map);
            // handlers
            map.on('click', this.onClick, this);
            map.on('mousemove', this.onMouseMove, this);
        },

        onRemove: function onRemove(map) {
            // handlers
            map.off('click', this.onClick, this);
            map.off('mousemove', this.onMouseMove, this);
            DOM.prototype.onRemove.call(this, map);
        },

        createTile: function createTile(coords, done) {
            var tile = L.DomUtil.create('canvas', 'leaflet-tile');
            tile.style['pointer-events'] = 'all';
            tile.width = this.options.tileSize;
            tile.height = this.options.tileSize;
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        clearTiles: function clearTiles() {
            var tileSize = this.options.tileSize;
            _.forIn(this._tiles, function (tile) {
                var ctx = tile.el.getContext('2d');
                ctx.clearRect(0, 0, tileSize, tileSize);
            });
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = Canvas;
})();

},{"./DOM":73}],73:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('../../layer/core/Base');

    var DOM = Base.extend({

        onAdd: function onAdd(map) {
            L.GridLayer.prototype.onAdd.call(this, map);
            map.on('zoomstart', this.clearExtrema, this);
            this.on('tileunload', this.onTileUnload, this);
            this.on('cacheload', this.onCacheLoad, this);
            this.on('cachehit', this.onCacheHit, this);
            this.on('cacheunload', this.onCacheUnload, this);
            this.on('extremachange', this.onExtremaChange, this);
        },

        onRemove: function onRemove(map) {
            L.GridLayer.prototype.onRemove.call(this, map);
            map.off('zoomstart', this.clearExtrema, this);
            this.off('tileunload', this.onTileUnload, this);
            this.off('cacheload', this.onCacheLoad, this);
            this.off('cachehit', this.onCacheHit, this);
            this.off('cacheunload', this.onCacheUnload, this);
            this.off('extremachange', this.onExtremaChange, this);
        },

        onCacheHit: function onCacheHit(event) {
            var cached = event.entry;
            var tile = event.tile;
            var coords = event.coords;
            // data exists, render only this tile
            if (cached.data) {
                this.renderTile(tile, cached.data, coords);
            }
        },

        onCacheLoad: function onCacheLoad(event) {
            var _this = this;

            // same extrema, we are good to render the tiles. In
            // the case of a map with wraparound, we may have
            // multiple tiles dependent on the response, so iterate
            // over each tile and draw it.
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data) {
                _.forIn(cached.tiles, function (tile) {
                    _this.renderTile(tile, cached.data, coords);
                });
            }
        },

        onExtremaChange: function onExtremaChange() {
            var _this2 = this;

            // redraw all tiles
            _.forIn(this._cache, function (cached) {
                _.forIn(cached.tiles, function (tile, key) {
                    if (cached.data) {
                        _this2.renderTile(tile, cached.data, _this2.coordFromCacheKey(key));
                    }
                });
            });
        },

        onCacheUnload: function onCacheUnload() {
            // override
        },

        createTile: function createTile() {
            // override
        },

        renderTile: function renderTile() {
            // override
        }
    });

    module.exports = DOM;
})();

},{"../../layer/core/Base":37}],74:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DOM = require('./DOM');

    var HTML = DOM.extend({

        options: {
            zoomAnimation: false
        },

        onAdd: function onAdd(map) {
            var _this = this;

            DOM.prototype.onAdd.call(this, map);
            // handlers
            map.on('click', this.onClick, this);
            map.on('zoomstart', this.clearTiles, this);
            $(this._container).on('mousemove', function (event) {
                _this.onMouseMove(event);
            });
            $(this._container).on('mouseover', function (event) {
                _this.onMouseOver(event);
            });
            $(this._container).on('mouseout', function (event) {
                _this.onMouseOut(event);
            });
        },

        onRemove: function onRemove(map) {
            // handlers
            map.off('click', this.onClick, this);
            map.off('zoomstart', this.clearTiles, this);
            $(this._container).off('mousemove');
            $(this._container).off('mouseover');
            $(this._container).off('mouseout');
            DOM.prototype.onRemove.call(this, map);
        },

        clearTiles: function clearTiles() {
            if (!this.options.zoomAnimation) {
                // remove scaled level
                this._invalidateAll();
            }
        },

        createTile: function createTile(coords, done) {
            var tile = L.DomUtil.create('div', 'leaflet-tile leaflet-html-tile');
            tile.width = this.options.tileSize;
            tile.height = this.options.tileSize;
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onMouseOver: function onMouseOver() {
            // override
        },

        onMouseOut: function onMouseOut() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = HTML;
})();

},{"./DOM":73}],75:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Base = require('../../layer/core/Base');

    var NO_OP = function NO_OP() {};

    var Overlay = Base.extend({

        options: {
            zIndex: 1
        },

        onAdd: function onAdd(map) {
            this.on('tileunload', this.onTileUnload, this);
            this.on('cacheload', this.onCacheLoad, this);
            this.on('cachehit', this.onCacheHit, this);
            this.on('cacheunload', this.onCacheUnload, this);
            this.on('extremachange', this.onExtremaChange, this);
            this._tiles = {};
            this._initContainer();
            // add event handlers
            map.on('click', this.onClick, this);
            map.on('mousemove', this.onMouseMove, this);
            this._resetView();
            this._update();
        },

        onRemove: function onRemove(map) {
            // remove layer
            this._removeAllTiles();
            L.DomUtil.remove(this._container);
            map._removeZoomLimit(this);
            this._tileZoom = null;
            // remove handlers
            this.off('tileunload', this.onTileUnload, this);
            this.off('cacheload', this.onCacheLoad, this);
            this.off('cachehit', this.onCacheHit, this);
            this.off('cacheunload', this.onCacheUnload, this);
            this.off('extremachange', this.onExtremaChange, this);
            map.off('click', this.onClick, this);
            map.off('mousemove', this.onMouseMove, this);
        },

        // No-op these functions
        _updateOpacity: NO_OP,
        _initTile: NO_OP,
        _updateLevels: NO_OP,
        _removeTilesAtZoom: NO_OP,
        _setZoomTransforms: NO_OP,

        _initContainer: function _initContainer() {
            if (!this._container) {
                this._container = document.createElement('canvas');
                this._container.className += 'leaflet-layer leaflet-zoom-animated';
            }
            this._updateZIndex();
            this.getPane().appendChild(this._container);
        },

        _pruneTiles: function _pruneTiles() {
            var _this = this;

            if (!this._map) {
                return;
            }
            var zoom = this._map.getZoom();
            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                this._removeAllTiles();
                return;
            }
            _.forIn(this._tiles, function (tile) {
                tile.retain = tile.current;
            });
            _.forIn(this._tiles, function (tile) {
                if (tile.current && !tile.active) {
                    var coords = tile.coords;
                    if (!_this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                        _this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                    }
                }
            });
            _.forIn(this._tiles, function (tile, key) {
                if (!tile.retain) {
                    _this._removeTile(key);
                }
            });
        },

        _removeAllTiles: function _removeAllTiles() {
            var _this2 = this;

            _.forIn(this._tiles, function (tile, key) {
                _this2._removeTile(key);
            });
        },

        _invalidateAll: function _invalidateAll() {
            this._removeAllTiles();
            this._tileZoom = null;
        },

        _setView: function _setView(center, zoom, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom);
            if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
                tileZoom = undefined;
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
                this._tileZoom = tileZoom;
                if (this._abortLoading) {
                    this._abortLoading();
                }
                this._resetGrid();
                if (tileZoom !== undefined) {
                    this._update(center);
                }
                if (!noPrune) {
                    this._pruneTiles();
                }
            }
            this._setZoomTransform(center, zoom);
        },

        _setZoomTransform: function _setZoomTransform(center, zoom) {
            var currentCenter = this._map.getCenter();
            var currentZoom = this._map.getZoom();
            var scale = this._map.getZoomScale(zoom, currentZoom);
            var position = L.DomUtil.getPosition(this._container);
            var viewHalf = this._map.getSize().multiplyBy(0.5);
            var currentCenterPoint = this._map.project(currentCenter, zoom);
            var destCenterPoint = this._map.project(center, zoom);
            var centerOffset = destCenterPoint.subtract(currentCenterPoint);
            var topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);
            if (L.Browser.any3d) {
                L.DomUtil.setTransform(this._container, topLeftOffset, scale);
            } else {
                L.DomUtil.setPosition(this._container, topLeftOffset);
            }
        },

        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function _update(center) {
            var map = this._map;
            if (!map) {
                return;
            }
            var zoom = map.getZoom();
            if (center === undefined) {
                center = map.getCenter();
            }
            if (this._tileZoom === undefined) {
                // if out of minzoom/maxzoom
                return;
            }
            var pixelBounds = this._getTiledPixelBounds(center),
                tileRange = this._pxBoundsToTileRange(pixelBounds),
                tileCenter = tileRange.getCenter(),
                queue = [];

            _.forIn(this._tiles, function (tile) {
                tile.current = false;
            });
            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, const _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) {
                this._setView(center, zoom);
                return;
            }
            // create a queue of coordinates to load tiles from
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
                for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                    var coords = new L.Point(i, j);
                    coords.z = this._tileZoom;

                    if (!this._isValidTile(coords)) {
                        continue;
                    }

                    var tile = this._tiles[this._tileCoordsToKey(coords)];
                    if (tile) {
                        tile.current = true;
                    } else {
                        queue.push(coords);
                    }
                }
            }
            // sort tile queue to load tiles in order of their distance to center
            queue.sort(function (a, b) {
                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
                // if its the first batch of tiles to load
                if (!this._loading) {
                    this._loading = true;
                    // @event loading: Event
                    // Fired when the grid layer starts loading tiles
                    this.fire('loading');
                }
                for (var _i = 0; _i < queue.length; _i++) {
                    this._addTile(queue[_i]);
                }
            }
        },

        _removeTile: function _removeTile(key) {
            var tile = this._tiles[key];
            if (!tile) {
                return;
            }
            delete this._tiles[key];
            // @event tileunload: TileEvent
            // Fired when a tile is removed (e.g. when a tile goes off the screen).
            this.fire('tileunload', {
                coords: this._keyToTileCoords(key)
            });
        },

        createTile: function createTile(coords, done) {
            var tile = {
                coords: coords,
                current: true
            };
            this._requestTile(coords, tile, function () {
                done(null, tile);
            });
            return tile;
        },

        _addTile: function _addTile(coords) {

            var tile = this.createTile(coords, L.bind(this._tileReady, this, coords));
            var key = this._tileCoordsToKey(coords);
            this._tiles[key] = tile;

            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                coords: coords
            });
        },

        _tileReady: function _tileReady(coords, err, tile) {
            if (!this._map) {
                return;
            }
            if (err) {
                // @event tileerror: TileErrorEvent
                // Fired when there is an error loading a tile.
                this.fire('tileerror', {
                    error: err,
                    tile: tile,
                    coords: coords
                });
            }
            // tile loaded
            tile.loaded = +new Date();
            tile.active = true;
            this._pruneTiles();

            // @event tileload: TileEvent
            // Fired when a tile loads.
            this.fire('tileload', {
                coords: coords,
                tile: tile
            });

            if (this._noTilesToLoad()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire('load');
                if (L.Browser.ielt9 || !this._map._fadeAnimated) {
                    L.Util.requestAnimFrame(this._pruneTiles, this);
                } else {
                    // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                    // to trigger a pruning.
                    setTimeout(L.bind(this._pruneTiles, this), 250);
                }
            }
        },

        onCacheHit: function onCacheHit() {
            // override
        },

        onCacheLoad: function onCacheLoad() {
            // override
        },

        onExtremaChange: function onExtremaChange() {
            // override
        },

        onCacheUnload: function onCacheUnload() {
            // override
        },

        onMouseMove: function onMouseMove() {
            // override
        },

        onClick: function onClick() {
            // override
        }

    });

    module.exports = Overlay;
})();

},{"../../layer/core/Base":37}],76:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var Overlay = require('./Overlay');

    var TILE_SIZE = 256;

    var WebGL = Overlay.extend({

        onAdd: function onAdd(map) {
            Overlay.prototype.onAdd.call(this, map);
            map.on('zoomstart', this.onZoomStart, this);
            map.on('zoomend', this.onZoomEnd, this);
        },

        onRemove: function onRemove(map) {
            Overlay.prototype.onRemove.call(this, map);
            map.off('zoomstart', this.onZoomStart, this);
            map.off('zoomend', this.onZoomEnd, this);
        },

        onZoomStart: function onZoomStart() {
            this.clearExtrema();
            this._isZooming = true;
        },

        onZoomEnd: function onZoomEnd() {
            this._isZooming = false;
            if (this._initialized) {
                var gl = this._gl;
                gl.clear(gl.COLOR_BUFFER_BIT);
                this.renderFrame();
            }
        },

        _initContainer: function _initContainer() {
            Overlay.prototype._initContainer.call(this);
            if (!this._gl) {
                this._initGL();
            } else {
                this._draw();
            }
            this._isZooming = false;
        },

        onWebGLInit: function onWebGLInit(done) {
            done(null);
        },

        _initGL: function _initGL() {
            var _this = this;

            var gl = this._gl = esper.WebGLContext.get(this._container);
            // handle missing context
            if (!gl) {
                throw 'Unable to acquire a WebGL context';
            }
            // init the webgl state
            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.disable(gl.DEPTH_TEST);
            // get map size
            var size = this._map.getSize();
            var devicePixelRatio = window.devicePixelRatio;
            // set viewport size
            this._viewport = new esper.Viewport({
                width: size.x * devicePixelRatio,
                height: size.y * devicePixelRatio
            });
            // set canvas size
            this._gl.canvas.style.width = size.x + 'px';
            this._gl.canvas.style.height = size.y + 'px';
            // webgl init callback
            this.onWebGLInit(function (err) {
                if (err) {
                    console.error(err);
                    return;
                }
                // flag as ready
                _this._initialized = true;
                // start draw loop
                _this._draw();
            });
        },

        getTranslationMatrix: function getTranslationMatrix(x, y, z) {
            var mat = new Float32Array(16);
            mat[0] = 1;
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = 0;
            mat[5] = 1;
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = 1;
            mat[11] = 0;
            mat[12] = x;
            mat[13] = y;
            mat[14] = z;
            mat[15] = 1;
            return mat;
        },

        getOrthoMatrix: function getOrthoMatrix(left, right, bottom, top, near, far) {
            var mat = new Float32Array(16);
            mat[0] = 2 / (right - left);
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = 0;
            mat[5] = 2 / (top - bottom);
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = -2 / (far - near);
            mat[11] = 0;
            mat[12] = -((right + left) / (right - left));
            mat[13] = -((top + bottom) / (top - bottom));
            mat[14] = -((far + near) / (far - near));
            mat[15] = 1;
            return mat;
        },

        getWrapAroundOffset: function getWrapAroundOffset(coords) {
            var size = Math.pow(2, this._map.getZoom());
            // create model matrix
            var xWrap = Math.floor(coords.x / size);
            var yWrap = Math.floor(coords.y / size);
            return [size * TILE_SIZE * xWrap, size * TILE_SIZE * yWrap];
        },

        getProjectionMatrix: function getProjectionMatrix() {
            var size = this._map.getSize();
            return this.getOrthoMatrix(0, size.x, 0, size.y, -1, 1);
        },

        getViewOffset: function getViewOffset() {
            var bounds = this._map.getPixelBounds();
            var dim = Math.pow(2, this._map.getZoom()) * TILE_SIZE;
            return [bounds.min.x, dim - bounds.max.y];
        },

        getTileOffset: function getTileOffset(coords) {
            var dim = Math.pow(2, coords.z);
            var x = coords.x;
            var y = this.options.tms ? coords.y : dim - coords.y - 1;
            return [x * TILE_SIZE, y * TILE_SIZE];
        },

        _positionContainer: function _positionContainer() {
            var size = this._map.getSize();
            var devicePixelRatio = window.devicePixelRatio;
            // set viewport size
            this._viewport.resize(size.x * devicePixelRatio, size.y * devicePixelRatio);
            // set canvas size
            this._gl.canvas.style.width = size.x + 'px';
            this._gl.canvas.style.height = size.y + 'px';
            // re-position container
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._container, topLeft);
        },

        _draw: function _draw() {
            if (this._map && this._initialized) {
                if (!this.isHidden()) {
                    // re-position canvas
                    if (!this._isZooming) {
                        // position the container and resize viewport
                        this._positionContainer();
                        // clear buffer
                        var gl = this._gl;
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        // draw the frame
                        this.renderFrame();
                    }
                }
                requestAnimationFrame(this._draw.bind(this));
            }
        },

        renderFrame: function renderFrame() {
            // implement this
        }

    });

    module.exports = WebGL;
})();

},{"./Overlay":75,"esper":14}],77:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Core = {
        HTML: require('./core/HTML'),
        WebGL: require('./core/WebGL'),
        Canvas: require('./core/Canvas')
    };

    // canvas renderers
    var Canvas = {
        Heatmap: require('./type/canvas/Heatmap'),
        TopTrails: require('./type/canvas/TopTrails'),
        Preview: require('./type/canvas/Preview')
    };

    // html renderers
    var HTML = {
        Empty: require('./type/html/Empty'),
        Heatmap: require('./type/html/Heatmap'),
        Ring: require('./type/html/Ring'),
        WordCloud: require('./type/html/WordCloud'),
        WordHistogram: require('./type/html/WordHistogram'),
        CommunityLabel: require('./type/html/CommunityLabel')
    };

    // webgl renderers
    var WebGL = {
        Heatmap: require('./type/webgl/Heatmap'),
        Point: require('./type/webgl/Point'),
        Cluster: require('./type/webgl/Cluster'),
        Community: require('./type/webgl/Community')
    };

    // pending layer renderers
    var Pending = {
        DelayedBlink: require('./type/pending/DelayedBlink'),
        DelayedSpin: require('./type/pending/DelayedSpin'),
        Blink: require('./type/pending/Blink'),
        Spin: require('./type/pending/Spin'),
        BlinkSpin: require('./type/pending/BlinkSpin')
    };

    // pending layer renderers
    var Debug = {
        Coord: require('./type/debug/Coord')
    };

    module.exports = {
        Core: Core,
        HTML: HTML,
        Canvas: Canvas,
        WebGL: WebGL,
        Debug: Debug,
        Pending: Pending
    };
})();

},{"./core/Canvas":72,"./core/HTML":74,"./core/WebGL":76,"./type/canvas/Heatmap":81,"./type/canvas/Preview":82,"./type/canvas/TopTrails":83,"./type/debug/Coord":84,"./type/html/CommunityLabel":85,"./type/html/Empty":86,"./type/html/Heatmap":87,"./type/html/Ring":88,"./type/html/WordCloud":89,"./type/html/WordHistogram":90,"./type/pending/Blink":91,"./type/pending/BlinkSpin":92,"./type/pending/DelayedBlink":93,"./type/pending/DelayedSpin":94,"./type/pending/Spin":95,"./type/webgl/Cluster":96,"./type/webgl/Community":97,"./type/webgl/Heatmap":98,"./type/webgl/Point":99}],78:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var NUM_GRADIENT_STEPS = 100;

    function rgb2lab(rgb) {
        var r = rgb[0] > 0.04045 ? Math.pow((rgb[0] + 0.055) / 1.055, 2.4) : rgb[0] / 12.92;
        var g = rgb[1] > 0.04045 ? Math.pow((rgb[1] + 0.055) / 1.055, 2.4) : rgb[1] / 12.92;
        var b = rgb[2] > 0.04045 ? Math.pow((rgb[2] + 0.055) / 1.055, 2.4) : rgb[2] / 12.92;
        //Observer. = 2, Illuminant = D65
        var x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
        var y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
        var z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;
        x = x / 0.95047; // Observer= 2, Illuminant= D65
        y = y / 1.00000;
        z = z / 1.08883;
        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 16 / 116;
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787037 * y + 16 / 116;
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787037 * z + 16 / 116;
        return [116 * y - 16, 500 * (x - y), 200 * (y - z), rgb[3]];
    }

    function lab2rgb(lab) {
        var y = (lab[0] + 16) / 116;
        var x = y + lab[1] / 500;
        var z = y - lab[2] / 200;
        x = x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        y = y > 0.206893034 ? y * y * y : (y - 4 / 29) / 7.787037;
        z = z > 0.206893034 ? z * z * z : (z - 4 / 29) / 7.787037;
        x = x * 0.95047; // Observer= 2, Illuminant= D65
        y = y * 1.00000;
        z = z * 1.08883;
        var r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
        var g = x * -0.9692660 + y * 1.8760108 + z * 0.0415560;
        var b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
        r = r > 0.00304 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
        g = g > 0.00304 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
        b = b > 0.00304 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;
        return [Math.max(Math.min(r, 1), 0), Math.max(Math.min(g, 1), 0), Math.max(Math.min(b, 1), 0), lab[3]];
    }

    function distance(c1, c2) {
        return Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) + (c1[1] - c2[1]) * (c1[1] - c2[1]) + (c1[2] - c2[2]) * (c1[2] - c2[2]) + (c1[3] - c2[3]) * (c1[3] - c2[3]));
    }

    var buildFlatLookupTable = function buildFlatLookupTable(color) {
        var output = [];
        for (var i = 0; i < NUM_GRADIENT_STEPS; i++) {
            output.push(color[0]);
            output.push(color[1]);
            output.push(color[2]);
            output.push(color[3]);
        }
        return output;
    };

    // Interpolate between a set of colors using even perceptual distance and interpolation in CIE L*a*b* space
    var buildPerceptualLookupTable = function buildPerceptualLookupTable(baseColors) {
        var buffer = new ArrayBuffer(NUM_GRADIENT_STEPS * 4 * 4);
        var outputGradient = new Float32Array(buffer);
        // Calculate perceptual spread in L*a*b* space
        var labs = _.map(baseColors, function (color) {
            return rgb2lab([color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 255]);
        });
        var distances = _.map(labs, function (color, index, colors) {
            return index > 0 ? distance(color, colors[index - 1]) : 0;
        });
        // Calculate cumulative distances in [0,1]
        var totalDistance = _.reduce(distances, function (a, b) {
            return a + b;
        }, 0);
        distances = _.map(distances, function (d) {
            return d / totalDistance;
        });
        var distanceTraversed = 0;
        var key = 0;
        var progress = void 0;
        var stepProgress = void 0;
        var rgb = void 0;
        for (var i = 0; i < NUM_GRADIENT_STEPS; i++) {
            progress = i / (NUM_GRADIENT_STEPS - 1);
            if (progress > distanceTraversed + distances[key + 1] && key + 1 < labs.length - 1) {
                key += 1;
                distanceTraversed += distances[key];
            }
            stepProgress = (progress - distanceTraversed) / distances[key + 1];
            rgb = lab2rgb([labs[key][0] + (labs[key + 1][0] - labs[key][0]) * stepProgress, labs[key][1] + (labs[key + 1][1] - labs[key][1]) * stepProgress, labs[key][2] + (labs[key + 1][2] - labs[key][2]) * stepProgress, labs[key][3] + (labs[key + 1][3] - labs[key][3]) * stepProgress]);
            outputGradient[i * 4] = rgb[0];
            outputGradient[i * 4 + 1] = rgb[1];
            outputGradient[i * 4 + 2] = rgb[2];
            outputGradient[i * 4 + 3] = rgb[3];
        }
        return outputGradient;
    };

    var COOL = buildPerceptualLookupTable([[0x04, 0x20, 0x40, 0x50], [0x08, 0x40, 0x81, 0x7f], [0x08, 0x68, 0xac, 0xff], [0x2b, 0x8c, 0xbe, 0xff], [0x4e, 0xb3, 0xd3, 0xff], [0x7b, 0xcc, 0xc4, 0xff], [0xa8, 0xdd, 0xb5, 0xff], [0xcc, 0xeb, 0xc5, 0xff], [0xe0, 0xf3, 0xdb, 0xff], [0xf7, 0xfc, 0xf0, 0xff]]);

    var HOT = buildPerceptualLookupTable([[0x40, 0x00, 0x13, 0x50], [0x80, 0x00, 0x26, 0x7f], [0xbd, 0x00, 0x26, 0xff], [0xe3, 0x1a, 0x1c, 0xff], [0xfc, 0x4e, 0x2a, 0xff], [0xfd, 0x8d, 0x3c, 0xff], [0xfe, 0xb2, 0x4c, 0xff], [0xfe, 0xd9, 0x76, 0xff], [0xff, 0xed, 0xa0, 0xff]]);

    var VERDANT = buildPerceptualLookupTable([[0x00, 0x40, 0x26, 0x50], [0x00, 0x5a, 0x32, 0x7f], [0x23, 0x84, 0x43, 0xff], [0x41, 0xab, 0x5d, 0xff], [0x78, 0xc6, 0x79, 0xff], [0xad, 0xdd, 0x8e, 0xff], [0xd9, 0xf0, 0xa3, 0xff], [0xf7, 0xfc, 0xb9, 0xff], [0xff, 0xff, 0xe5, 0xff]]);

    var SPECTRAL = buildPerceptualLookupTable([[0x26, 0x1a, 0x40, 0x50], [0x44, 0x2f, 0x72, 0x7f], [0xe1, 0x2b, 0x02, 0xff], [0x02, 0xdc, 0x01, 0xff], [0xff, 0xd2, 0x02, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var TEMPERATURE = buildPerceptualLookupTable([[0x00, 0x16, 0x40, 0x50], [0x00, 0x39, 0x66, 0x7f], [0x31, 0x3d, 0x66, 0xff], [0xe1, 0x2b, 0x02, 0xff], [0xff, 0xd2, 0x02, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var GREYSCALE = buildPerceptualLookupTable([[0x00, 0x00, 0x00, 0x7f], [0x40, 0x40, 0x40, 0xff], [0xff, 0xff, 0xff, 0xff]]);

    var POLAR_HOT = buildPerceptualLookupTable([[0xff, 0x44, 0x00, 0xff], [0xbd, 0xbd, 0xbd, 0xb0]]);

    var POLAR_COLD = buildPerceptualLookupTable([[0xbd, 0xbd, 0xbd, 0xb0], [0x32, 0xa5, 0xf9, 0xff]]);

    var FIRE = buildPerceptualLookupTable([[0x96, 0x00, 0x00, 0x96], [0xff, 0xff, 0x32, 0xff]]);

    var FLAT = buildFlatLookupTable([0xff, 0xff, 0xff, 0xff]);

    var buildLookupFunction = function buildLookupFunction(RAMP) {
        return function (scaledValue, inColor) {
            var index = Math.floor(scaledValue * (RAMP.length / 4 - 1));
            inColor[0] = RAMP[index * 4];
            inColor[1] = RAMP[index * 4 + 1];
            inColor[2] = RAMP[index * 4 + 2];
            inColor[3] = RAMP[index * 4 + 3];
            return inColor;
        };
    };

    var concat = function concat(a, b) {
        var combined = new Float32Array(a.length + b.length);
        combined.set(a, 0);
        combined.set(b, a.length);
        return combined;
    };

    var ColorTables = {
        cool: COOL,
        hot: HOT,
        verdant: VERDANT,
        spectral: SPECTRAL,
        temperature: TEMPERATURE,
        grey: GREYSCALE,
        polar: concat(POLAR_HOT, POLAR_COLD),
        flat: FLAT
    };

    var ColorRamp = {
        cool: buildLookupFunction(COOL),
        hot: buildLookupFunction(HOT),
        verdant: buildLookupFunction(VERDANT),
        spectral: buildLookupFunction(SPECTRAL),
        temperature: buildLookupFunction(TEMPERATURE),
        grey: buildLookupFunction(GREYSCALE),
        fire: buildLookupFunction(FIRE),
        polar: buildLookupFunction(concat(POLAR_HOT, POLAR_COLD)),
        flat: buildLookupFunction(FLAT)
    };

    var setColorRamp = function setColorRamp(type, baseColors) {
        var func = ColorRamp[type.toLowerCase()];
        if (func) {
            this._colorRamp = func;
        } else if (baseColors) {
            ColorRamp[type.toLowerCase()] = buildLookupFunction(buildPerceptualLookupTable(baseColors));
            this._colorRamp = ColorRamp[type.toLowerCase()];
        }
        this._colorRampType = type.toLowerCase();
        return this;
    };

    var getColorRamp = function getColorRamp(type) {
        return this._colorRamp || ColorRamp[type.toLowerCase()];
    };

    var getColorRampTable = function getColorRampTable() {
        return ColorTables[this._colorRampType];
    };

    var initialize = function initialize() {
        this._colorRamp = ColorRamp.verdant;
        this._colorRampType = 'verdant';
    };

    module.exports = {
        initialize: initialize,
        setColorRamp: setColorRamp,
        getColorRamp: getColorRamp,
        getColorRampTable: getColorRampTable,
        NUM_GRADIENT_STEPS: NUM_GRADIENT_STEPS
    };
})();

},{}],79:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var SIGMOID_SCALE = 0.15;

    // log10

    function log10Transform(val, min, max) {
        var logMin = Math.log10(min || 1);
        var logMax = Math.log10(max || 1);
        var logVal = Math.log10(val || 1);
        return (logVal - logMin) / (logMax - logMin || 1);
    }

    function inverseLog10Transform(nval, min, max) {
        var logMin = Math.log10(min || 1);
        var logMax = Math.log10(max || 1);
        return Math.pow(10, nval * logMax - nval * logMin + logMin);
    }

    // sigmoid

    function sigmoidTransform(val, min, max) {
        var absMin = Math.abs(min);
        var absMax = Math.abs(max);
        var distance = Math.max(absMin, absMax);
        var scaledVal = val / (SIGMOID_SCALE * distance);
        return 1 / (1 + Math.exp(-scaledVal));
    }

    function inverseSigmoidTransform(nval, min, max) {
        var absMin = Math.abs(min);
        var absMax = Math.abs(max);
        var distance = Math.max(absMin, absMax);
        if (nval === 0) {
            return -distance;
        }
        if (nval === 1) {
            return distance;
        }
        return Math.log(1 / nval - 1) * -(SIGMOID_SCALE * distance);
    }

    // linear

    function linearTransform(val, min, max) {
        var range = max - min;
        if (range === 0) {
            return 1;
        }
        return (val - min) / range;
    }

    function inverseLinearTransform(nval, min, max) {
        var range = max - min;
        if (range === 0) {
            return 1;
        }
        return min + nval * range;
    }

    var Transform = {
        linear: linearTransform,
        log10: log10Transform,
        sigmoid: sigmoidTransform
    };

    var Inverse = {
        linear: inverseLinearTransform,
        log10: inverseLog10Transform,
        sigmoid: inverseSigmoidTransform
    };

    var initialize = function initialize() {
        this._range = {
            min: 0,
            max: 1
        };
        this._transformFunc = log10Transform;
        this._inverseFunc = inverseLog10Transform;
    };

    var setTransformFunc = function setTransformFunc(type) {
        var func = type.toLowerCase();
        this._transformFunc = Transform[func];
        this._transformType = type;
        this._inverseFunc = Inverse[func];
    };

    var setValueRange = function setValueRange(range) {
        this._range.min = range.min;
        this._range.max = range.max;
    };

    var getValueRange = function getValueRange() {
        return this._range;
    };

    var getTransformEnum = function getTransformEnum() {
        if (this._transformType === 'linear') {
            return 1;
        } else if (this._transformType === 'sigmoid') {
            return 2;
        }
        return 0;
    };

    var interpolateToRange = function interpolateToRange(nval) {
        // interpolate between the filter range
        var rMin = this._range.min;
        var rMax = this._range.max;
        var rval = (nval - rMin) / (rMax - rMin);
        // ensure output is [0:1]
        return Math.max(0, Math.min(1, rval));
    };

    var transformValue = function transformValue(val) {
        // clamp the value between the extreme (shouldn't be necessary)
        var min = this._extrema.min;
        var max = this._extrema.max;
        var clamped = Math.max(Math.min(val, max), min);
        // normalize the value
        if (min !== max) {
            return this._transformFunc(clamped, min, max);
        }
        // if min === max, always return 1
        return 1;
    };

    var untransformValue = function untransformValue(nval) {
        var min = this._extrema.min;
        var max = this._extrema.max;
        // clamp the value between the extreme (shouldn't be necessary)
        var clamped = Math.max(Math.min(nval, 1), 0);
        // unnormalize the value
        if (min !== max) {
            return this._inverseFunc(clamped, min, max);
        }
        // if min === max, always return 1
        return 1;
    };

    module.exports = {
        initialize: initialize,
        setTransformFunc: setTransformFunc,
        setValueRange: setValueRange,
        getValueRange: getValueRange,
        getTransformEnum: getTransformEnum,
        transformValue: transformValue,
        untransformValue: untransformValue,
        interpolateToRange: interpolateToRange
    };
})();

},{}],80:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var POSITIVE = '1';
    var NEUTRAL = '0';
    var NEGATIVE = '-1';

    function getClassFunc(min, max) {
        min = min !== undefined ? min : -1;
        max = max !== undefined ? max : 1;
        var positive = [0.25 * max, 0.5 * max, 0.75 * max];
        var negative = [-0.25 * min, -0.5 * min, -0.75 * min];
        return function (sentiment) {
            var prefix = void 0;
            var range = void 0;
            if (sentiment < 0) {
                prefix = 'neg-';
                range = negative;
            } else {
                prefix = 'pos-';
                range = positive;
            }
            var abs = Math.abs(sentiment);
            if (abs > range[2]) {
                return prefix + '4';
            } else if (abs > range[1]) {
                return prefix + '3';
            } else if (abs > range[0]) {
                return prefix + '2';
            }
            return prefix + '1';
        };
    }

    function getTotal(count) {
        if (!count) {
            return 0;
        }
        var pos = count[POSITIVE] ? count[POSITIVE] : 0;
        var neu = count[NEUTRAL] ? count[NEUTRAL] : 0;
        var neg = count[NEGATIVE] ? count[NEGATIVE] : 0;
        return pos + neu + neg;
    }

    function getAvg(count) {
        if (!count) {
            return 0;
        }
        var pos = count[POSITIVE] ? count[POSITIVE] : 0;
        var neu = count[NEUTRAL] ? count[NEUTRAL] : 0;
        var neg = count[NEGATIVE] ? count[NEGATIVE] : 0;
        var total = pos + neu + neg;
        return total !== 0 ? (pos - neg) / total : 0;
    }

    module.exports = {
        getClassFunc: getClassFunc,
        getTotal: getTotal,
        getAvg: getAvg
    };
})();

},{}],81:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = Canvas.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        renderCanvas: function renderCanvas(bins, resolution, ramp) {
            var canvas = document.createElement('canvas');
            canvas.height = resolution;
            canvas.width = resolution;
            var ctx = canvas.getContext('2d');
            var imageData = ctx.getImageData(0, 0, resolution, resolution);
            var data = imageData.data;
            var color = [0, 0, 0, 0];
            var nval = 0;
            var rval = 0;
            var bin = 0;
            for (var i = 0; i < bins.length; i++) {
                bin = bins[i];
                if (bin === 0) {
                    color[0] = 0;
                    color[1] = 0;
                    color[2] = 0;
                    color[3] = 0;
                } else {
                    nval = this.transformValue(bin);
                    rval = this.interpolateToRange(nval);
                    ramp(rval, color);
                }
                data[i * 4] = Math.round(color[0] * 255);
                data[i * 4 + 1] = Math.round(color[1] * 255);
                data[i * 4 + 2] = Math.round(color[2] * 255);
                data[i * 4 + 3] = Math.round(color[3] * 255);
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        },

        renderTile: function renderTile(canvas, data) {
            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var ramp = this.getColorRamp();
            var tileCanvas = this.renderCanvas(bins, resolution, ramp);
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tileCanvas, 0, 0, resolution, resolution, 0, 0, canvas.width, canvas.height);
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/Canvas":72,"../../mixin/ColorRamp":78,"../../mixin/ValueTransform":79}],82:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');

    var Preview = Canvas.extend({

        options: {
            lineWidth: 1,
            lineColor: '#fff'
        },

        highlighted: false,

        _drawHighlight: function _drawHighlight(canvas, x, y, size) {
            var ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.fillStyle = this.options.fillColor;
            ctx.rect(x * size, y * size, size, size);
            ctx.lineWidth = this.options.lineWidth;
            ctx.strokeStyle = this.options.lineColor;
            ctx.stroke();
        },

        onMouseMove: function onMouseMove(e) {
            var _this = this;

            var target = e.originalEvent.target;
            if (this.highlighted) {
                // clear existing highlight
                this.clearTiles();
            }
            // get layer coord
            var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
            // get tile coord
            var coord = this.getTileCoordFromLayerPoint(layerPoint);
            // get cache key
            var nkey = this.cacheKeyFromCoord(coord, true);
            // get cache entry
            var cached = this._cache[nkey];
            if (cached && cached.data) {
                var _ret = function () {
                    // get bin coordinate
                    var bin = _this.getBinCoordFromLayerPoint(layerPoint);
                    // get bin data entry
                    var data = cached.data[bin.index];
                    if (data) {
                        // for each tile relying on that data
                        _.forIn(cached.tiles, function (tile) {
                            _this._drawHighlight(tile, bin.x, bin.y, bin.size);
                        });
                        var collision = {
                            value: data,
                            x: coord.x,
                            y: coord.z,
                            z: coord.z,
                            bx: bin.x,
                            by: bin.y,
                            type: 'preview',
                            layer: _this
                        };
                        if (!_this.highlighted) {
                            // execute callback
                            _this.fire('mouseover', {
                                elem: target,
                                value: collision
                            });
                        }
                        // flag as highlighted
                        _this.highlighted = collision;
                        // set cursor
                        $(_this._map._container).css('cursor', 'pointer');
                        return {
                            v: void 0
                        };
                    }
                }();

                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        }

    });

    module.exports = Preview;
})();

},{"../../core/Canvas":72}],83:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var Canvas = require('../../core/Canvas');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var TopTrails = Canvas.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        options: {
            selectedColor: [255, 100, 255, 255],
            highlightedColor: [200, 0, 255, 255],
            downSampleFactor: 8
        },

        highlighted: null,

        selected: null,

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        clearHighlight: function clearHighlight() {
            if (this.highlighted) {
                this.highlighted = null;
                this._highlightTrails();
            }
        },

        clearSelection: function clearSelection() {
            if (this.selected) {
                this.selected = null;
                this._highlightTrails();
            }
        },

        setSelection: function setSelection(value) {
            this.clearSelection();
            this.selected = value;
            this._highlightTrails();
        },

        setHighlight: function setHighlight(value) {
            this.clearHighlight();
            this.highlighted = value;
            this._highlightTrails();
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var bin = this._getBinData(e);
            if (bin) {
                // execute callback
                this.fire('click', {
                    elem: target,
                    value: bin
                });
                // flag as selected
                this.setSelection(bin);
                return;
            }
            // clear selected flag
            this.clearSelection();
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var bin = this._getBinData(e);
            if (bin) {
                // execute callback
                if (!this.highlighted) {
                    this.fire('mouseover', {
                        elem: target,
                        value: bin
                    });
                }
                // flag as highlighted
                this.setHighlight(bin);
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                // exit early
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted
                });
            }
            this.clearHighlight();
        },

        _getBinData: function _getBinData(e) {
            // get layer coord
            var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
            // get tile coord
            var coord = this.getTileCoordFromLayerPoint(layerPoint);
            // get cache key
            var nkey = this.cacheKeyFromCoord(coord, true);
            // get cache entry
            var cached = this._cache[nkey];
            if (cached && cached.pixels) {
                // get bin coordinate
                var bin = this.getBinCoordFromLayerPoint(layerPoint);
                // downsample the bin res
                var x = Math.floor(bin.x / this.options.downSampleFactor);
                var y = Math.floor(bin.y / this.options.downSampleFactor);
                // if hits a pixel
                if (cached.pixels[x] && cached.pixels[x][y]) {
                    var ids = Object.keys(cached.pixels[x][y]);
                    // take first entry
                    var id = ids[0];
                    // create collision object
                    var collision = {
                        value: id,
                        x: coord.x,
                        y: coord.z,
                        z: coord.z,
                        bx: bin.x,
                        by: bin.y,
                        type: 'top-trails',
                        layer: this
                    };
                    return collision;
                }
            }
            return null;
        },

        _highlightTrailsForData: function _highlightTrailsForData(cached) {
            var _this = this;

            var selected = this.selected;
            var highlighted = this.highlighted;
            if (cached.data) {
                (function () {
                    var trail = void 0;
                    if (selected) {
                        trail = cached.trails[selected.value];
                        if (trail) {
                            // for each tile relying on that data
                            _.forIn(cached.tiles, function (tile) {
                                _this._renderTrail(tile, trail, _this.options.selectedColor);
                            });
                        }
                    }
                    if (highlighted) {
                        trail = cached.trails[highlighted.value];
                        if (trail) {
                            _.forIn(cached.tiles, function (tile) {
                                _this._renderTrail(tile, trail, _this.options.highlightedColor);
                            });
                        }
                    }
                })();
            }
        },

        _highlightTrails: function _highlightTrails() {
            var _this2 = this;

            this.clearTiles();
            _.forIn(this._cache, function (cached) {
                _this2._highlightTrailsForData(cached);
            });
        },

        _renderTrail: function _renderTrail(canvas, pixels, color) {
            var resolution = this.getResolution();
            var highlight = document.createElement('canvas');
            highlight.height = resolution;
            highlight.width = resolution;
            var highlightCtx = highlight.getContext('2d');
            var imageData = highlightCtx.getImageData(0, 0, resolution, resolution);
            var data = imageData.data;
            var pixel = void 0,
                x = void 0,
                y = void 0,
                i = void 0,
                j = void 0;
            for (i = 0; i < pixels.length; i++) {
                pixel = pixels[i];
                x = pixel[0];
                y = pixel[1];
                j = x + resolution * y;
                data[j * 4] = color[0];
                data[j * 4 + 1] = color[1];
                data[j * 4 + 2] = color[2];
                data[j * 4 + 3] = color[3];
            }
            highlightCtx.putImageData(imageData, 0, 0);
            // draw to tile
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(highlight, 0, 0, resolution, resolution, 0, 0, canvas.width, canvas.height);
        },

        renderTile: function renderTile(container, data, coord) {
            if (!data) {
                return;
            }
            // modify cache entry
            var nkey = this.cacheKeyFromCoord(coord, true);
            var cached = this._cache[nkey];
            if (cached.trails) {
                // trails already added, exit early
                return;
            }
            var trails = cached.trails = {};
            var pixels = cached.pixels = {};
            var ids = Object.keys(data);
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                var bins = data[id];
                for (var j = 0; j < bins.length; j++) {
                    var bin = bins[j];
                    // down sample the pixel to make interaction easier
                    var rx = Math.floor(bin[0] / this.options.downSampleFactor);
                    var ry = Math.floor(bin[1] / this.options.downSampleFactor);
                    pixels[rx] = pixels[rx] || {};
                    pixels[rx][ry] = pixels[rx][ry] || {};
                    pixels[rx][ry][id] = true;
                    // add pixel under the trail at correct resolution
                    var x = bin[0];
                    var y = bin[1];
                    trails[id] = trails[id] || [];
                    trails[id].push([x, y]);
                }
            }
            // make sure to highlight selected trails in the tile
            this._highlightTrailsForData(cached);
        }

    });

    module.exports = TopTrails;
})();

},{"../../core/Canvas":72,"../../mixin/ColorRamp":78,"../../mixin/ValueTransform":79}],84:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    module.exports = {

        renderTile: function renderTile(elem, coord) {
            $(elem).empty();
            $(elem).append('<div style="top:0; left:0;">' + coord.z + ', ' + coord.x + ', ' + coord.y + '</div>');
        }

    };
})();

},{}],85:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var TILE_SIZE = 256;

    var CommunityLabel = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            minFontSize: 10,
            maxFontSize: 24,
            minOpacity: 0.5,
            maxOpacity: 1.0,
            labelMaxLength: TILE_SIZE,
            labelThreshold: 0.6,
            labelField: 'metadata'
        },

        onMouseOver: function onMouseOver(e) {
            // forward community title string to app level mousemove handler
            // when pointer is over a community ring
            var target = $(e.originalEvent.target);
            var data = target.data('communityData');
            var value = {
                name: data.metadata,
                count: data.numNodes
            };
            this.fire('mouseover', {
                elem: e.originalEvent.target,
                value: value,
                type: 'community-labels',
                layer: this
            });
        },

        onMouseOut: function onMouseOut(e) {
            // forward cleared string to app level mousemove handler when
            // pointer moves off a community ring
            this.fire('mouseout', {
                elem: e.originalEvent.target,
                type: 'community-labels',
                layer: this
            });
        },

        _createLabelDiv: function _createLabelDiv(community, coord, className) {
            var nval = this.transformValue(_.get(community, this.options.degreeField));
            // normalize the nval as it is currently in the range [this.options.labelThreshold : 1]
            nval = (nval - this.options.labelThreshold) / (1.0 - this.options.labelThreshold);
            var zIndex = Math.ceil(100 * nval);
            var fontSize = this.options.minFontSize + nval * (this.options.maxFontSize - this.options.minFontSize);
            var opacity = this.options.minOpacity + nval * (this.options.maxOpacity - this.options.minOpacity);
            var dim = Math.pow(2, coord.z);
            var tileSpan = Math.pow(2, 32) / dim;
            var x = _.get(community, this.getXField());
            var y = _.get(community, this.getYField());
            var left = x % tileSpan / tileSpan * TILE_SIZE - this.options.labelMaxLength / 2;
            var top = y % tileSpan / tileSpan * TILE_SIZE - fontSize / 2;
            return $('\n                <div class="' + className + '" style="\n                    left: ' + left + 'px;\n                    top: ' + top + 'px;\n                    opacity: ' + opacity + ';\n                    font-size: ' + fontSize + 'px;\n                    z-index: ' + zIndex + ';\n                    line-height: ' + fontSize + 'px;">' + _.get(community, this.options.labelField) + '</div>\n                ');
        },

        renderTile: function renderTile(container, data, coord) {
            var _this = this;

            if (!data) {
                return;
            }
            var divs = $();
            data.forEach(function (community) {
                if (!_.get(community, _this.options.labelField)) {
                    return;
                }
                var nval = _this.transformValue(_.get(community, _this.options.degreeField));
                if (nval < _this.options.labelThreshold) {
                    return;
                }
                var div = _this._createLabelDiv(community, coord, 'community-label');
                div.data('communityData', community);
                divs = divs.add(div);
            });
            $(container).empty().append(divs);
        }

    });

    module.exports = CommunityLabel;
})();

},{"../../core/HTML":74,"../../mixin/ValueTransform":79}],86:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');

    var Empty = HTML.extend({});

    module.exports = Empty;
})();

},{"../../core/HTML":74}],87:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = HTML.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            var value = target.attr('data-value');
            if (value) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                this.fire('mouseover', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: coord.x,
                    y: coord.y,
                    z: coord.z,
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            var value = target.attr('data-value');
            if (value) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                this.fire('mouseout', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: coord.x,
                    y: coord.y,
                    z: coord.z,
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        onClick: function onClick(e) {
            // un-select any prev selected pixel
            $('.heatmap-pixel').removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            if (target.hasClass('heatmap-pixel')) {
                target.addClass('highlight');
            }
            var value = target.attr('data-value');
            if (value) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                this.fire('click', {
                    elem: e.originalEvent.target,
                    value: parseInt(value, 10),
                    x: coord.x,
                    y: coord.y,
                    z: coord.z,
                    bx: parseInt(target.attr('data-bx'), 10),
                    by: parseInt(target.attr('data-by'), 10),
                    type: 'heatmap',
                    layer: this
                });
            }
        },

        renderTile: function renderTile(container, data) {
            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var ramp = this.getColorRamp();
            var pixelSize = this.options.tileSize / resolution;
            var color = [0, 0, 0, 0];
            var html = '';
            var nval = 0;
            var rval = 0;
            var left = 0;
            var top = 0;
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                if (bin === 0) {
                    continue;
                } else {
                    left = i % resolution;
                    top = Math.floor(i / resolution);
                    nval = this.transformValue(bin);
                    rval = this.interpolateToRange(nval);
                    ramp(rval, color);
                }
                var r = Math.round(color[0] * 255);
                var g = Math.round(color[1] * 255);
                var b = Math.round(color[2] * 255);
                var a = color[3];
                var rgba = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
                html += '\n                    <div class="heatmap-pixel"\n                        data-value="' + bin + '"\n                        data-bx="' + left + '"\n                        data-by="' + top + '"\n                        style="\n                            height: ' + pixelSize + 'px;\n                            width: ' + pixelSize + 'px;\n                            left: ' + left * pixelSize + 'px;\n                            top: ' + top * pixelSize + 'px;\n                            background-color: ' + rgba + ';">\n                    </div>\n                    ';
            }
            container.innerHTML = html;
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/HTML":74,"../../mixin/ColorRamp":78,"../../mixin/ValueTransform":79}],88:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');

    var Heatmap = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        onClick: function onClick(e) {
            var target = $(e.originalEvent.target);
            $('.heatmap-ring').removeClass('highlight');
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            if (target.hasClass('heatmap-ring')) {
                target.addClass('highlight');
            }
        },

        renderTile: function renderTile(container, data) {
            var _this = this;

            if (!data) {
                return;
            }
            var bins = new Float64Array(data);
            var resolution = Math.sqrt(bins.length);
            var binSize = this.options.tileSize / resolution;
            var html = '';
            bins.forEach(function (bin, index) {
                if (!bin) {
                    return;
                }
                var percent = _this.transformValue(bin);
                var radius = percent * binSize;
                var offset = (binSize - radius) / 2;
                var left = index % resolution * binSize;
                var top = Math.floor(index / resolution) * binSize;
                html += '\n                    <div class="heatmap-ring" style="\n                        left: ' + (left + offset) + 'px;\n                        top: ' + (top + offset) + 'px;\n                        width: ' + radius + 'px;\n                        height: ' + radius + 'px;">\n                    </div>\n                    ';
            });
            container.innerHTML = html;
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/HTML":74,"../../mixin/ValueTransform":79}],89:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var sentiment = require('../../sentiment/Sentiment');
    var sentimentFunc = sentiment.getClassFunc(-1, 1);

    var VERTICAL_OFFSET = 24;
    var HORIZONTAL_OFFSET = 10;
    var NUM_ATTEMPTS = 1;

    /**
     * Given an initial position, return a new position, incrementally spiralled
     * outwards.
     */
    var spiralPosition = function spiralPosition(pos) {
        var pi2 = 2 * Math.PI;
        var circ = pi2 * pos.radius;
        var inc = pos.arcLength > circ / 10 ? circ / 10 : pos.arcLength;
        var da = inc / pos.radius;
        var nt = pos.t + da;
        if (nt > pi2) {
            nt = nt % pi2;
            pos.radius = pos.radius + pos.radiusInc;
        }
        pos.t = nt;
        pos.x = pos.radius * Math.cos(nt);
        pos.y = pos.radius * Math.sin(nt);
        return pos;
    };

    /**
     *  Returns true if bounding box a intersects bounding box b
     */
    var intersectTest = function intersectTest(a, b) {
        return Math.abs(a.x - b.x) * 2 < a.width + b.width && Math.abs(a.y - b.y) * 2 < a.height + b.height;
    };

    /**
     *  Returns true if bounding box a is not fully contained inside bounding box b
     */
    var overlapTest = function overlapTest(a, b) {
        return a.x + a.width / 2 > b.x + b.width / 2 || a.x - a.width / 2 < b.x - b.width / 2 || a.y + a.height / 2 > b.y + b.height / 2 || a.y - a.height / 2 < b.y - b.height / 2;
    };

    /**
     * Check if a word intersects another word, or is not fully contained in the
     * tile bounding box
     */
    var intersectWord = function intersectWord(position, word, cloud, bb) {
        var box = {
            x: position.x,
            y: position.y,
            height: word.height,
            width: word.width
        };
        for (var i = 0; i < cloud.length; i++) {
            if (intersectTest(box, cloud[i])) {
                return true;
            }
        }
        // make sure it doesn't intersect the border;
        if (overlapTest(box, bb)) {
            // if it hits a border, increment collision count
            // and extend arc length
            position.collisions++;
            position.arcLength = position.radius;
            return true;
        }
        return false;
    };

    var WordCloud = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            maxNumWords: 15,
            minFontSize: 10,
            maxFontSize: 20
        },

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        clearSelection: function clearSelection() {
            $(this._container).removeClass('highlight');
            this.highlight = null;
        },

        setHighlight: function setHighlight(word) {
            this.clearSelection();
            // Highlight selected word
            $(this._container).addClass('highlight');
            $('.word-cloud-label[data-word="' + word + '"]').addClass('highlight');
            this.highlight = word;
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            $('.word-cloud-label').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // highlight all instances of the word
                $('.word-cloud-label[data-word="' + word + '"]').addClass('hover');
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            $('.word-cloud-label').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseout', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            }
        },

        onClick: function onClick(e) {
            // un-select any prev selected words
            $('.word-cloud-label').removeClass('highlight');
            $(this._container).removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            var word = target.attr('data-word');
            if (word) {
                this.setHighlight(word);
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('click', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-cloud',
                        layer: this
                    });
                }
            } else {
                this.clearSelection();
            }
        },

        _measureWords: function _measureWords(wordCounts) {
            var _this = this;

            // sort words by frequency
            wordCounts = wordCounts.sort(function (a, b) {
                return b.count - a.count;
            }).slice(0, this.options.maxNumWords);
            // build measurement html
            var $html = $('<div style="height:256px; width:256px;"></div>');
            var minFontSize = this.options.minFontSize;
            var maxFontSize = this.options.maxFontSize;
            wordCounts.forEach(function (word) {
                word.percent = _this.transformValue(word.count);
                word.fontSize = minFontSize + word.percent * (maxFontSize - minFontSize);
                $html.append('\n                    <div class="word-cloud-label" style="\n                        visibility:hidden;\n                        font-size: ' + word.fontSize + 'px;">' + word.text + '</div>;\n                    ');
            });
            // append measurements
            $('body').append($html);
            $html.children().each(function (index, elem) {
                wordCounts[index].width = elem.offsetWidth;
                wordCounts[index].height = elem.offsetHeight;
            });
            $html.remove();
            return wordCounts;
        },

        _createWordCloud: function _createWordCloud(wordCounts) {
            var tileSize = this.options.tileSize;
            var boundingBox = {
                width: tileSize - HORIZONTAL_OFFSET * 2,
                height: tileSize - VERTICAL_OFFSET * 2,
                x: 0,
                y: 0
            };
            var cloud = [];
            // sort words by frequency
            wordCounts = this._measureWords(wordCounts);
            // assemble word cloud
            wordCounts.forEach(function (wordCount) {
                // starting spiral position
                var pos = {
                    radius: 1,
                    radiusInc: 5,
                    arcLength: 10,
                    x: 0,
                    y: 0,
                    t: 0,
                    collisions: 0
                };
                // spiral outwards to find position
                while (pos.collisions < NUM_ATTEMPTS) {
                    // increment position in a spiral
                    pos = spiralPosition(pos);
                    // test for intersection
                    if (!intersectWord(pos, wordCount, cloud, boundingBox)) {
                        cloud.push({
                            key: wordCount.key,
                            text: wordCount.text,
                            fontSize: wordCount.fontSize,
                            percent: Math.round(wordCount.percent * 100 / 10) * 10, // round to nearest 10
                            x: pos.x,
                            y: pos.y,
                            width: wordCount.width,
                            height: wordCount.height,
                            sentiment: wordCount.sentiment,
                            avg: wordCount.avg
                        });
                        break;
                    }
                }
            });
            return cloud;
        },

        extractExtrema: function extractExtrema(data) {
            var sums = _.map(data, function (count) {
                count = count.counts || count;
                if (_.isNumber(count)) {
                    return count;
                }
                return sentiment.getTotal(count);
            });
            return {
                min: _.min(sums),
                max: _.max(sums)
            };
        },

        getText: function getText(keyData, key) {
            return key;
        },

        renderTile: function renderTile(container, data) {
            var _this2 = this;

            if (!data || _.isEmpty(data)) {
                return;
            }
            var highlight = this.highlight;
            var wordCounts = _.map(data, function (keyData, key) {
                var count = keyData.counts || keyData;
                var text = _this2.getText(keyData, key);
                if (_.isNumber(count)) {
                    return {
                        key: key,
                        text: text,
                        count: count
                    };
                }
                var total = sentiment.getTotal(count);
                var avg = sentiment.getAvg(count);
                return {
                    key: key,
                    text: text,
                    count: total,
                    avg: avg,
                    sentiment: sentimentFunc(avg)
                };
            });
            // exit early if no words
            if (wordCounts.length === 0) {
                return;
            }
            // genereate the cloud
            var cloud = this._createWordCloud(wordCounts);
            // build html elements
            var halfSize = this.options.tileSize / 2;
            var html = '';
            cloud.forEach(function (word) {
                // create classes
                var classNames = ['word-cloud-label', 'word-cloud-label-' + word.percent, word.text === highlight ? 'highlight' : '', word.sentiment ? word.sentiment : ''].join(' ');
                // create styles
                var styles = ['font-size: ' + word.fontSize + 'px', 'left: ' + (halfSize + word.x - word.width / 2) + 'px', 'top: ' + (halfSize + word.y - word.height / 2) + 'px', 'width: ' + word.width + 'px', 'height: ' + word.height + 'px'].join(';');
                // create html for entry
                html += '\n                    <div class="' + classNames + '"\n                        style="' + styles + '"\n                        data-sentiment="' + word.avg + '"\n                        data-word="' + word.key + '">' + word.text + '</div>\n                    ';
            });
            container.innerHTML = html;
        }

    });

    module.exports = WordCloud;
})();

},{"../../core/HTML":74,"../../mixin/ValueTransform":79,"../../sentiment/Sentiment":80}],90:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var HTML = require('../../core/HTML');
    var ValueTransform = require('../../mixin/ValueTransform');
    var sentiment = require('../../sentiment/Sentiment');
    var sentimentFunc = sentiment.getClassFunc(-1, 1);

    var isSingleValue = function isSingleValue(count) {
        // single values are never null, and always numbers
        return count !== null && _.isNumber(count);
    };

    var extractCount = function extractCount(count) {
        if (isSingleValue(count)) {
            return count;
        }
        return sentiment.getTotal(count);
    };

    var extractSentimentClass = function extractSentimentClass(avg) {
        if (avg !== undefined) {
            return sentimentFunc(avg);
        }
        return '';
    };

    var extractFrequency = function extractFrequency(count) {
        count = count.counts || count;
        if (isSingleValue(count)) {
            return {
                count: count
            };
        }
        return {
            count: sentiment.getTotal(count),
            avg: sentiment.getAvg(count)
        };
    };

    var extractAvg = function extractAvg(frequencies) {
        if (frequencies[0].avg === undefined) {
            return;
        }
        var sum = _.sumBy(frequencies, function (frequency) {
            return frequency.avg;
        });
        return sum / frequencies.length;
    };

    var WordHistogram = HTML.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            maxNumWords: 8,
            minFontSize: 16,
            maxFontSize: 22
        },

        initialize: function initialize() {
            ValueTransform.initialize.apply(this, arguments);
        },

        clearSelection: function clearSelection() {
            $(this._container).removeClass('highlight');
            this.highlight = null;
        },

        setHighlight: function setHighlight(word) {
            this.clearSelection();
            // Highlight selected word
            $(this._container).addClass('highlight');
            $('.word-histogram-entry[data-word="' + word + '"]').addClass('highlight');
            this.highlight = word;
        },

        onMouseOver: function onMouseOver(e) {
            var target = $(e.originalEvent.target);
            $('.word-histogram-entry').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                $('.word-histogram-entry[data-word="' + word + '"]').addClass('hover');
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseover', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            }
        },

        onMouseOut: function onMouseOut(e) {
            var target = $(e.originalEvent.target);
            $('.word-histogram-entry').removeClass('hover');
            var word = target.attr('data-word');
            if (word) {
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('mouseout', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            }
        },

        onClick: function onClick(e) {
            // un-select and prev selected histogram
            $('.word-histogram-entry').removeClass('highlight');
            $(this._container).removeClass('highlight');
            // get target
            var target = $(e.originalEvent.target);
            if (!this.isTargetLayer(e.originalEvent.target)) {
                // this layer is not the target
                return;
            }
            var word = target.attr('data-word');
            if (word) {
                this.setHighlight(word);
                // get layer coord
                var layerPoint = this.getLayerPointFromEvent(e.originalEvent);
                // get tile coord
                var coord = this.getTileCoordFromLayerPoint(layerPoint);
                // get cache key
                var nkey = this.cacheKeyFromCoord(coord, true);
                // get cache entry
                var cached = this._cache[nkey];
                if (cached && cached.data) {
                    this.fire('click', {
                        elem: e.originalEvent.target,
                        value: word,
                        x: coord.x,
                        y: coord.y,
                        z: coord.z,
                        data: cached.data,
                        type: 'word-histogram',
                        layer: this
                    });
                }
            } else {
                this.clearSelection();
            }
        },

        extractExtrema: function extractExtrema(data) {
            var sums = _.map(data, function (counts) {
                return _.sumBy(counts, extractCount);
            });
            return {
                min: _.min(sums),
                max: _.max(sums)
            };
        },

        getText: function getText(keyData, key) {
            return key;
        },

        extractValues: function extractValues(data, key) {
            var frequencies = _.map(data, extractFrequency);
            var avg = extractAvg(frequencies);
            var max = _.maxBy(frequencies, function (val) {
                return val.count;
            }).count;
            var total = _.sumBy(frequencies, function (val) {
                return val.count;
            });
            return {
                key: key,
                topic: this.getText(data, key),
                frequencies: frequencies,
                max: max,
                total: total,
                avg: avg
            };
        },

        renderTile: function renderTile(container, data) {
            var _this = this;

            if (!data || _.isEmpty(data)) {
                return;
            }
            var highlight = this.highlight;
            // convert object to array
            var values = _.map(data, this.extractValues.bind(this)).sort(function (a, b) {
                return b.total - a.total;
            });
            // get number of entries
            var numEntries = Math.min(values.length, this.options.maxNumWords);
            var $html = $('<div class="word-histograms" style="display:inline-block;"></div>');
            var totalHeight = 0;
            var minFontSize = this.options.minFontSize;
            var maxFontSize = this.options.maxFontSize;
            values.slice(0, numEntries).forEach(function (value) {
                var key = value.key;
                var topic = value.topic;
                var frequencies = value.frequencies;
                var max = value.max;
                var total = value.total;
                var avg = value.avg;
                var sentimentClass = extractSentimentClass(avg);
                var highlightClass = key === highlight ? 'highlight' : '';
                // scale the height based on level min / max
                var percent = _this.transformValue(total);
                var percentLabel = Math.round(percent * 100 / 10) * 10;
                var height = minFontSize + percent * (maxFontSize - minFontSize);
                totalHeight += height;
                // create container 'entry' for chart and hashtag
                var $entry = $('\n                    <div class="word-histogram-entry ' + highlightClass + '"\n                        data-sentiment="' + avg + '"\n                        data-word="' + key + '"\n                        style="height:' + height + 'px;">\n                    </div>\n                    ');
                // create chart
                var $chart = $('\n                    <div class="word-histogram-left"\n                        data-sentiment="' + avg + '"\n                        data-word="' + key + '">\n                    </div>\n                    ');
                var barWidth = 'calc(' + 100 / frequencies.length + '%)';
                // create bars
                frequencies.forEach(function (frequency) {
                    var count = frequency.count;
                    var avg = frequency.avg;
                    var sentimentClass = extractSentimentClass(avg);
                    // get the percent relative to the highest count in the tile
                    var relativePercent = max !== 0 ? count / max * 100 : 0;
                    // make invisible if zero count
                    var visibility = relativePercent === 0 ? 'hidden' : 'visible';
                    // Get the style class of the bar
                    var percentLabel = Math.round(relativePercent / 10) * 10;
                    var barClasses = ['word-histogram-bar', 'word-histogram-bar-' + percentLabel, sentimentClass + '-fill'].join(' ');
                    var barHeight = void 0;
                    var barTop = void 0;
                    // ensure there is at least a single pixel of color
                    if (relativePercent / 100 * height < 3) {
                        barHeight = '3px';
                        barTop = 'calc(100% - 3px)';
                    } else {
                        barHeight = relativePercent + '%';
                        barTop = 100 - relativePercent + '%';
                    }
                    // create bar
                    $chart.append('\n                        <div class="' + barClasses + '"\n                            data-word="' + key + '"\n                            style="\n                            visibility: ' + visibility + ';\n                            width: ' + barWidth + ';\n                            height: ' + barHeight + ';\n                            top: ' + barTop + ';">\n                        </div>\n                        ');
                });
                $entry.append($chart);
                var topicClasses = ['word-histogram-label', 'word-histogram-label-' + percentLabel, sentimentClass].join(' ');
                // create tag label
                var $topic = $('\n                    <div class="word-histogram-right">\n                        <div class="' + topicClasses + '"\n                            data-sentiment="' + avg + '"\n                            data-word="' + key + '"\n                        style="\n                            font-size: ' + height + 'px;\n                            line-height: ' + height + 'px;\n                            height: ' + height + 'px;">' + topic + '</div>\n                    </div>\n                    ');
                $entry.append($topic);
                $html.append($entry);
            });
            $html.css('top', this.options.tileSize / 2 - totalHeight / 2);
            container.innerHTML = $html[0].outerHTML;
        }
    });

    module.exports = WordHistogram;
})();

},{"../../core/HTML":74,"../../mixin/ValueTransform":79,"../../sentiment/Sentiment":80}],91:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '<div class="blinking blinking-tile" style="animation-delay:' + delay + 'ms"></div>';
        }

    };
})();

},{}],92:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '\n                <div class="vertical-centered-box blinking" style="animation-delay: ' + delay + 'ms">\n                    <div class="content">\n                        <div class="loader-circle"></div>\n                        <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                            <div class="loader-line"></div>\n                        </div>\n                    </div>\n                </div>\n                ';
        }

    };
})();

},{}],93:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            setTimeout(function () {
                var delay = -(Math.random() * DELAY);
                if ($(elem).hasClass('pending')) {
                    elem.innerHTML = '<div class="blinking blinking-tile" style="animation-delay: ' + delay + 'ms"></div>';
                }
            }, DELAY);
        }

    };
})();

},{}],94:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            setTimeout(function () {
                var delay = -(Math.random() * DELAY);
                if ($(elem).hasClass('pending')) {
                    elem.innerHTML = '\n                        <div class="vertical-centered-box" style="animation-delay: ' + delay + 'ms">\n                            <div class="content">\n                                <div class="loader-circle"></div>\n                                <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                                    <div class="loader-line"></div>\n                                </div>\n                            </div>\n                        </div>\n                        ';
                }
            }, DELAY);
        }

    };
})();

},{}],95:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var DELAY = 1200;

    module.exports = {

        renderTile: function renderTile(elem) {
            var delay = -(Math.random() * DELAY);
            elem.innerHTML = '\n                <div class="vertical-centered-box" style="animation-delay: ' + delay + 'ms">\n                    <div class="content">\n                        <div class="loader-circle"></div>\n                        <div class="loader-line-mask" style="animation-delay: ' + delay + 'ms">\n                            <div class="loader-line"></div>\n                        </div>\n                    </div>\n                </div>\n                ';
        }

    };
})();

},{}],96:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var WebGL = require('../../core/WebGL');
    var VertexAtlas = require('./VertexAtlas');
    var Shaders = require('./Shaders');
    var Shapes = require('./Shapes');

    var TILE_SIZE = 256;
    var NUM_SLICES = 64;
    var POINT_RADIUS = 2;

    var Cluster = WebGL.extend({

        options: {
            outlineWidth: 1,
            outlineColor: [0.0, 0.0, 0.0, 1.0],
            fillColor: [0.2, 0.15, 0.4, 0.5],
            radius: POINT_RADIUS,
            blending: true
        },

        onWebGLInit: function onWebGLInit(done) {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // create the circle vertexbuffer
            this._circleFillBuffer = Shapes.circle.fill(NUM_SLICES);
            this._circleOutlineBuffer = Shapes.circle.outline(NUM_SLICES);
            // vertex atlas for all tiles
            this._atlas = new VertexAtlas({
                1: {
                    type: 'FLOAT',
                    size: 2
                }
            });
            // load shader
            this._shader = new esper.Shader({
                vert: Shaders.instancedPoint.vert,
                frag: Shaders.instancedPoint.frag
            });
            done();
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            var data = new Float64Array(cached.data);
            var positions = new Float32Array(data.length * 2);
            var resolution = Math.sqrt(data.length);
            var pointWidth = TILE_SIZE / resolution;
            var halfWidth = pointWidth / 2;
            var numPoints = 0;

            for (var i = 0; i < data.length; i++) {
                var bin = data[i];
                if (bin > 0) {
                    var x = i % resolution * pointWidth + halfWidth;
                    var y = Math.floor(i / resolution) * pointWidth + halfWidth;
                    // add point to buffer
                    positions[numPoints * 2] = x;
                    positions[numPoints * 2 + 1] = TILE_SIZE - y;
                    // increment point count
                    numPoints++;
                }
            }

            cached.numPoints = numPoints;
            if (numPoints > 0) {
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.addTile(hash, positions, numPoints);
            }
        },

        onCacheUnload: function onCacheUnload(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.numPoints > 0) {
                cached.numPoints = 0;
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.removeTile(hash);
            }
        },

        drawInstanced: function drawInstanced(circle, color, radius) {
            var _this = this;

            var gl = this._gl;
            var shader = this._shader;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            var atlas = this._atlas;
            if (this.options.blending) {
                // enable blending
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uColor', color);
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uRadius', radius);
            // calc view offset
            var viewOffset = this.getViewOffset();
            // bind the circle to instance
            circle.bind();
            // bind offsets and enable instancing
            atlas.bind();
            // for each allocated chunk
            atlas.forEach(function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        var coords = _this.coordFromCacheKey(hash);
                        if (coords.z !== zoom) {
                            // NOTE: we have to check here if the tiles are stale or not
                            return;
                        }
                        // get wrap offset
                        var wrapOffset = _this.getWrapAroundOffset(coords);
                        // get tile offset
                        var tileOffset = _this.getTileOffset(coords);
                        // calculate the total tile offset
                        var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                        shader.setUniform('uTileOffset', totalOffset);
                        // draw the instances
                        atlas.draw(hash, circle.mode, circle.count);
                    });
                }
            });
            // disable instancing
            atlas.unbind();
            // unbind buffer
            circle.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            var gl = this._gl;
            var viewport = this._viewport;
            viewport.push();
            // draw instanced fill
            this.drawInstanced(this._circleFillBuffer, this.options.fillColor, this.options.radius);
            // draw instanced outlines
            gl.lineWidth(this.options.outlineWidth);
            this.drawInstanced(this._circleOutlineBuffer, this.options.outlineColor, this.options.radius);
            // teardown
            viewport.pop();
        }

    });

    module.exports = Cluster;
})();

},{"../../core/WebGL":76,"./Shaders":100,"./Shapes":101,"./VertexAtlas":103,"esper":14}],97:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var rbush = require('rbush');
    var ValueTransform = require('../../mixin/ValueTransform');
    var WebGL = require('../../core/WebGL');
    var VertexAtlas = require('./VertexAtlas');
    var Shaders = require('./Shaders');
    var Shapes = require('./Shapes');

    var TILE_SIZE = 256;
    var NUM_SLICES = 360;
    var RADIUS = 10;

    var Cluster = WebGL.extend({

        includes: [
        // mixins
        ValueTransform],

        options: {
            outlineWidth: 2,
            outlineColor: [0.0, 0.0, 0.0, 1.0],
            ringWidth: 3,
            ringOffset: 0,
            radiusField: 'node.radius',
            tickWidth: 2,
            tickHeight: 8
        },

        highlighted: null,
        selected: null,

        onWebGLInit: function onWebGLInit(done) {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // ring vertexbuffers
            var fullWidth = this.options.ringWidth + this.options.outlineWidth;
            this._ringFillBuffer = Shapes.ring.fill(NUM_SLICES, RADIUS, this.options.ringWidth);
            this._ringOutlineBuffer = Shapes.ring.fill(NUM_SLICES, RADIUS, fullWidth);
            // quad vertexbuffer
            this._quadBuffer = Shapes.quad.fill(-this.options.tickWidth / 2, this.options.tickWidth / 2, -fullWidth / 2, this.options.tickHeight);
            // vertex atlas for all tiles
            this._atlas = new VertexAtlas({
                1: {
                    type: 'FLOAT',
                    size: 2
                },
                2: {
                    type: 'FLOAT',
                    size: 1
                }
            });
            // create spatial index
            this._rtree = new rbush();
            // load shaders
            this._instancedShader = new esper.Shader({
                vert: Shaders.instancedRing.vert,
                frag: Shaders.instancedRing.frag
            });
            this._individualShader = new esper.Shader({
                vert: Shaders.ring.vert,
                frag: Shaders.ring.frag
            });
            this._instancedTickShader = new esper.Shader({
                vert: Shaders.instancedTick.vert,
                frag: Shaders.instancedTick.frag
            });
            done();
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            var data = cached.data;
            if (!data) {
                return;
            }
            var radiusOffset = this.options.ringOffset + this.options.ringWidth + this.options.outlineWidth;
            var vertices = new Float32Array(data.length * 3);
            var tileOffset = {
                x: coords.x * TILE_SIZE,
                y: coords.y * TILE_SIZE
            };
            var tilePoint = { x: 0, y: 0 };
            var layerPoint = { x: 0, y: 0 };
            var points = [];
            for (var i = 0; i < data.length; i++) {
                var community = data[i];
                var nval = this.transformValue(_.get(community, this.options.degreeField));
                if (nval < this.options.communityThreshold) {
                    return;
                }
                var scale = Math.pow(2, coords.z);
                var radius = Math.max(4, _.get(community, this.options.radiusField) * scale) + radiusOffset;
                var tileSpan = Math.pow(2, 32) / scale;
                var xVal = _.get(community, this.getXField());
                var yVal = _.get(community, this.getYField());
                var x = xVal % tileSpan / tileSpan * TILE_SIZE;
                var y = yVal % tileSpan / tileSpan * TILE_SIZE;
                // get position in tile
                tilePoint.x = x;
                tilePoint.y = TILE_SIZE - y;
                // get position in layer
                layerPoint.x = x + tileOffset.x;
                layerPoint.y = y + tileOffset.y;
                // store point
                points.push({
                    x: tilePoint.x,
                    y: tilePoint.y,
                    radius: radius,
                    minX: layerPoint.x - radius,
                    maxX: layerPoint.x + radius,
                    minY: layerPoint.y - radius,
                    maxY: layerPoint.y + radius,
                    data: community,
                    coords: coords
                });
                // add point to buffer
                vertices[i * 3] = tilePoint.x;
                vertices[i * 3 + 1] = tilePoint.y;
                vertices[i * 3 + 2] = radius;
            }
            if (points.length > 0) {
                // bulk insert points to the rtree
                this._rtree.load(points);
                // store points in the cache
                cached.points = points;
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.addTile(hash, vertices, points.length);
            }
        },

        onCacheUnload: function onCacheUnload(event) {
            var cached = event.entry;
            if (cached.points) {
                var coords = event.coords;
                // remove from atlas
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.removeTile(hash);
                // remove from rtree
                var points = cached.points;
                for (var i = 0; i < points.length; i++) {
                    this._rtree.remove(points[i]);
                }
                cached.points = null;
            }
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var collisions = this._rtree.search({
                minX: layerPixel.x,
                maxX: layerPixel.x,
                minY: layerPixel.y,
                maxY: layerPixel.y
            });
            if (collisions.length > 0) {
                var collision = collisions[0];
                // mimic mouseover / mouseout events
                if (this.highlighted) {
                    if (this.highlighted.value !== collision) {
                        // new collision
                        // execute mouseout for old
                        this.fire('mouseout', {
                            elem: target,
                            value: this.highlighted.value
                        });
                        // execute mouseover for new
                        this.fire('mouseover', {
                            elem: target,
                            value: collision
                        });
                    }
                } else {
                    // no previous collision, execute mouseover
                    this.fire('mouseover', {
                        elem: target,
                        value: collision
                    });
                }
                // use collision point to find tile
                var hash = this.cacheKeyFromCoord(collision.coords);
                // flag as highlighted
                this.highlighted = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    radius: collision.radius,
                    point: [collision.x, collision.y]
                };
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted.value
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var collisions = this._rtree.search({
                minX: layerPixel.x,
                maxX: layerPixel.x,
                minY: layerPixel.y,
                maxY: layerPixel.y
            });
            if (collisions.length > 0) {
                var collision = collisions[0];
                // use collision point to find tile
                var hash = this.cacheKeyFromCoord(collision.coords);
                // flag as selected
                this.selected = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    radius: collision.radius,
                    point: [collision.x, collision.y]
                };
                this.fire('click', {
                    elem: target,
                    value: collision
                });
            } else {
                this.selected = null;
            }
        },

        drawInstancedOutline: function drawInstancedOutline(color) {
            var _this = this;

            var shader = this._instancedShader;
            var ring = this._ringOutlineBuffer;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            var atlas = this._atlas;
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uColor', color);
            shader.setUniform('uDegrees', 360);
            shader.setUniform('uRadiusOffset', RADIUS);
            shader.setUniform('uOpacity', this.getOpacity());
            // calc view offset
            var viewOffset = this.getViewOffset();
            // bind the circle to instance
            ring.bind();
            // bind offsets and enable instancing
            atlas.bind();
            // for each allocated chunk
            atlas.forEach(function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        var coords = _this.coordFromCacheKey(hash);
                        if (coords.z !== zoom) {
                            // NOTE: we have to check here if the tiles are stale or not
                            return;
                        }
                        // get wrap offset
                        var wrapOffset = _this.getWrapAroundOffset(coords);
                        // get tile offset
                        var tileOffset = _this.getTileOffset(coords);
                        // calculate the total tile offset
                        var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                        shader.setUniform('uTileOffset', totalOffset);
                        // draw the instances
                        atlas.draw(hash, ring.mode, ring.count);
                    });
                }
            });
            // disable instancing
            atlas.unbind();
            // unbind buffer
            ring.unbind();
        },

        drawInstancedFill: function drawInstancedFill(segments) {
            var _this2 = this;

            var shader = this._instancedShader;
            var ring = this._ringFillBuffer;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            var atlas = this._atlas;
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uRadiusOffset', RADIUS);
            shader.setUniform('uOpacity', this.getOpacity());
            // calc view offset
            var viewOffset = this.getViewOffset();
            // bind the circle to instance
            ring.bind();
            // bind offsets and enable instancing
            atlas.bind();
            // for each allocated chunk
            atlas.forEach(function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    segments.forEach(function (segment) {
                        shader.setUniform('uColor', segment.color);
                        shader.setUniform('uDegrees', segment.percent * 360);
                        // render for each tile
                        _.keys(cached.tiles).forEach(function (hash) {
                            var coords = _this2.coordFromCacheKey(hash);
                            if (coords.z !== zoom) {
                                // NOTE: we have to check here if the tiles are stale or not
                                return;
                            }
                            // get wrap offset
                            var wrapOffset = _this2.getWrapAroundOffset(coords);
                            // get tile offset
                            var tileOffset = _this2.getTileOffset(coords);
                            // calculate the total tile offset
                            var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                            shader.setUniform('uTileOffset', totalOffset);
                            // draw the instances
                            atlas.draw(hash, ring.mode, ring.count);
                        });
                    });
                }
            });
            // disable instancing
            atlas.unbind();
            // unbind buffer
            ring.unbind();
        },

        drawInstancedTick: function drawInstancedTick(color) {
            var _this3 = this;

            var shader = this._instancedTickShader;
            var quad = this._quadBuffer;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            var atlas = this._atlas;
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uColor', color);
            shader.setUniform('uOpacity', this.getOpacity());
            // calc view offset
            var viewOffset = this.getViewOffset();
            // bind the circle to instance
            quad.bind();
            // bind offsets and enable instancing
            atlas.bind();
            // for each allocated chunk
            atlas.forEach(function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        var coords = _this3.coordFromCacheKey(hash);
                        if (coords.z !== zoom) {
                            // NOTE: we have to check here if the tiles are stale or not
                            return;
                        }
                        // get wrap offset
                        var wrapOffset = _this3.getWrapAroundOffset(coords);
                        // get tile offset
                        var tileOffset = _this3.getTileOffset(coords);
                        // calculate the total tile offset
                        var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                        shader.setUniform('uTileOffset', totalOffset);
                        // draw the instances
                        atlas.draw(hash, quad.mode, quad.count);
                    });
                }
            });
            // disable instancing
            atlas.unbind();
            // unbind buffer
            quad.unbind();
        },

        drawIndividualFill: function drawIndividualFill(segments, tiles, point, radius) {
            var _this4 = this;

            // draw selected points
            var shader = this._individualShader;
            var ring = this._ringFillBuffer;
            var zoom = this._map.getZoom();
            // bind the buffer
            ring.bind();
            // use shader
            shader.use();
            // use uniform for offset
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uRadiusOffset', RADIUS);
            shader.setUniform('uRadius', radius);
            shader.setUniform('uOpacity', this.getOpacity());
            // view offset
            var viewOffset = this.getViewOffset();

            segments.forEach(function (segment) {
                shader.setUniform('uColor', segment.color);
                shader.setUniform('uDegrees', segment.percent * 360);
                _.forIn(tiles, function (tile) {
                    if (tile.coords.z !== zoom) {
                        // NOTE: we have to check here if the tiles are stale or not
                        return;
                    }
                    // get wrap offset
                    var wrapOffset = _this4.getWrapAroundOffset(tile.coords);
                    // get tile offset
                    var tileOffset = _this4.getTileOffset(tile.coords);
                    // calculate the total tile offset
                    var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                    shader.setUniform('uTileOffset', totalOffset);
                    shader.setUniform('uOffset', point);
                    ring.draw();
                });
            });
            // unbind the buffer
            ring.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            var gl = this._gl;
            var viewport = this._viewport;
            viewport.push();

            // TEMP
            var segments = [{
                color: [0.2, 0.2, 0.2, 1.0],
                percent: 1
            }, {
                color: [0.4, 0.4, 0.4, 1.0],
                percent: 0.8
            }, {
                color: [0.8, 0.8, 0.8, 1.0],
                percent: 0.4
            }];

            var selectedSegments = [{
                color: [0.4, 0.4, 0.4, 1.0],
                percent: 1
            }, {
                color: [0.6, 0.6, 0.6, 1.0],
                percent: 0.8
            }, {
                color: [1.0, 1.0, 1.0, 1.0],
                percent: 0.4
            }];

            // disable blending
            gl.disable(gl.BLEND);

            // draw instanced outlines
            this.drawInstancedOutline(this.options.outlineColor);
            // draw instanced fill
            this.drawInstancedFill(segments);

            if (this.highlighted) {
                // draw individual fill
                this.drawIndividualFill(selectedSegments, this.highlighted.tiles, this.highlighted.point, this.highlighted.radius);
            }

            if (this.selected) {
                // draw individual fill
                this.drawIndividualFill(selectedSegments, this.selected.tiles, this.selected.point, this.selected.radius);
            }

            // draw instanced tick
            this.drawInstancedTick(this.options.outlineColor);

            // teardown
            viewport.pop();
        }
    });

    module.exports = Cluster;
})();

},{"../../core/WebGL":76,"../../mixin/ValueTransform":79,"./Shaders":100,"./Shapes":101,"./VertexAtlas":103,"esper":14,"rbush":25}],98:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var WebGL = require('../../core/WebGL');
    var ColorRamp = require('../../mixin/ColorRamp');
    var ValueTransform = require('../../mixin/ValueTransform');
    var TextureAtlas = require('./TextureAtlas');
    var Shaders = require('./Shaders');
    var Shapes = require('./Shapes');

    var TILE_SIZE = 256;

    function encode(enc, val) {
        enc[0] = val / 16777216.0 & 0xFF;
        enc[1] = val / 65536.0 & 0xFF;
        enc[2] = val / 256.0 & 0xFF;
        enc[3] = val & 0xFF;
        return enc;
    }

    var Heatmap = WebGL.extend({

        includes: [
        // mixins
        ColorRamp, ValueTransform],

        onWebGLInit: function onWebGLInit(done) {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // quad buffer
            this._quadBuffer = Shapes.quad.textured(TILE_SIZE);
            // texture atlas for all tiles
            this._atlas = new TextureAtlas();
            // load shader
            this._shader = new esper.Shader({
                vert: Shaders.heatmap.vert,
                frag: Shaders.heatmap.frag
            });
            done();
        },

        initialize: function initialize() {
            ColorRamp.initialize.apply(this, arguments);
            ValueTransform.initialize.apply(this, arguments);
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data && cached.data.byteLength > 0) {
                // add to atlas
                this.bufferTileTexture(cached, coords);
            }
        },

        onCacheUnload: function onCacheUnload(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.sum > 0) {
                cached.sum = 0;
                // remove from atlas
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.removeTile(hash);
            }
        },

        bufferTileTexture: function bufferTileTexture(cached, coords) {
            var data = new Float64Array(cached.data);
            var bins = new Uint8Array(data.length * 4);
            var enc = [0, 0, 0, 0];
            var sum = 0;
            var bin = 0;
            for (var i = 0; i < data.length; i++) {
                bin = data[i];
                sum += bin;
                encode(enc, bin);
                bins[i * 4] = enc[0];
                bins[i * 4 + 1] = enc[1];
                bins[i * 4 + 2] = enc[2];
                bins[i * 4 + 3] = enc[3];
            }
            if (sum > 0) {
                cached.sum = sum;
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.addTile(hash, bins);
            }
        },

        renderTiles: function renderTiles() {
            var _this = this;

            var buffer = this._quadBuffer;
            var shader = this._shader;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            // calc view offset
            var viewOffset = this.getViewOffset();
            this._atlas.forEach(function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        // find the tiles position from its key
                        var coords = _this.coordFromCacheKey(hash);
                        // NOTE: we have to check here if the tiles are stale or not
                        if (coords.z !== zoom) {
                            return;
                        }
                        // get wraparound offset
                        var wrapOffset = _this.getWrapAroundOffset(coords);
                        // get tile offset
                        var tileOffset = _this.getTileOffset(coords);
                        // calculate the total tile offset
                        var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                        shader.setUniform('uTileOffset', totalOffset);
                        // uv offset and extent
                        shader.setUniform('uTextureCoordOffset', chunk.uvOffset);
                        shader.setUniform('uTextureCoordExtent', chunk.uvExtent);
                        // draw the tile
                        buffer.draw();
                    });
                }
            });
        },

        renderFrame: function renderFrame() {
            // setup
            this._viewport.push();
            this._shader.use();
            // set uniforms
            this._shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            this._shader.setUniform('uOpacity', this.getOpacity());
            this._shader.setUniform('uRangeMin', this.getValueRange().min);
            this._shader.setUniform('uRangeMax', this.getValueRange().max);
            this._shader.setUniform('uMin', this.getExtrema().min);
            this._shader.setUniform('uMax', this.getExtrema().max);
            this._shader.setUniform('uTransformType', this.getTransformEnum());
            this._shader.setUniform('uTextureSampler', 0);
            this._shader.setUniform('uRamp', this.getColorRampTable());
            this._atlas.texture.bind(0);
            // draw
            this._quadBuffer.bind();
            this.renderTiles();
            this._quadBuffer.unbind();
            // teardown
            this._atlas.texture.unbind();
            this._viewport.pop();
        }

    });

    module.exports = Heatmap;
})();

},{"../../core/WebGL":76,"../../mixin/ColorRamp":78,"../../mixin/ValueTransform":79,"./Shaders":100,"./Shapes":101,"./TextureAtlas":102,"esper":14}],99:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');
    var rbush = require('rbush');
    var WebGL = require('../../core/WebGL');
    var VertexAtlas = require('./VertexAtlas');
    var Shaders = require('./Shaders');
    var Shapes = require('./Shapes');

    var TILE_SIZE = 256;
    var MAX_POINTS_PER_TILE = TILE_SIZE * TILE_SIZE;

    var NUM_SLICES = 64;
    var POINT_RADIUS = 8;
    var POINT_RADIUS_INC = 2;

    function applyJitter(point, maxDist) {
        var angle = Math.random() * (Math.PI * 2);
        var dist = Math.random() * maxDist;
        point.x += Math.floor(Math.cos(angle) * dist);
        point.y += Math.floor(Math.sin(angle) * dist);
    }

    var Point = WebGL.extend({

        options: {
            outlineWidth: 1,
            outlineColor: [0.0, 0.0, 0.0, 1.0],
            fillColor: [0.2, 0.15, 0.4, 0.5],
            radius: POINT_RADIUS,
            selectedOutlineColor: [0.0, 0.0, 0.0, 1.0],
            selectedFillColor: [0.8, 0.4, 0.2, 0.5],
            selectedRadius: POINT_RADIUS + POINT_RADIUS_INC,
            highlightedOutlineColor: [0.0, 0.0, 0.0, 1.0],
            highlightedFillColor: [0.3, 0.25, 0.5, 0.5],
            highlightedRadius: POINT_RADIUS + POINT_RADIUS_INC,
            blending: true,
            jitter: true,
            jitterDistance: 10
        },

        highlighted: null,
        selected: null,

        onWebGLInit: function onWebGLInit(done) {
            // ensure we use the correct context
            esper.WebGLContext.bind(this._container);
            // create the circle vertexbuffer
            this._circleFillBuffer = Shapes.circle.fill(NUM_SLICES);
            this._circleOutlineBuffer = Shapes.circle.outline(NUM_SLICES);
            // vertex atlas for all tiles
            this._atlas = new VertexAtlas({
                1: {
                    type: 'FLOAT',
                    size: 2
                }
            });
            // create spatial index
            this._rtree = new rbush();
            // load shaders
            this._instancedShader = new esper.Shader({
                vert: Shaders.instancedPoint.vert,
                frag: Shaders.instancedPoint.frag
            });
            this._individualShader = new esper.Shader({
                vert: Shaders.point.vert,
                frag: Shaders.point.frag
            });
            done();
        },

        getCollisionRadius: function getCollisionRadius() {
            return this.options.radius + this.options.outlineWidth;
        },

        onAdd: function onAdd(map) {
            WebGL.prototype.onAdd.call(this, map);
            map.on('zoomend', this.onZoomEnd, this);
        },

        onRemove: function onRemove(map) {
            WebGL.prototype.onRemove.call(this, map);
            map.off('zoomend', this.onZoomEnd, this);
        },

        onZoomStart: function onZoomStart() {
            this._rtree.clear();
            WebGL.prototype.onZoomStart.apply(this, arguments);
        },

        onCacheLoad: function onCacheLoad(event) {
            var cached = event.entry;
            var coords = event.coords;
            if (cached.data && cached.data.length > 0) {
                // convert x / y to tile pixels
                var data = cached.data;
                var xField = this.getXField();
                var yField = this.getYField();
                var zoom = coords.z;
                var radius = this.getCollisionRadius();
                var numPoints = Math.min(data.length, MAX_POINTS_PER_TILE);
                var positions = new Float32Array(numPoints * 2);
                var points = [];
                var collisions = {};

                var xOffset = coords.x * TILE_SIZE;
                var yOffset = coords.y * TILE_SIZE;

                var tilePoint = { x: 0, y: 0 };
                // calc pixel locations
                for (var i = 0; i < numPoints; i++) {
                    var hit = data[i];
                    var x = _.get(hit, xField);
                    var y = _.get(hit, yField);
                    // get position in layer
                    var layerPoint = this.getLayerPointFromDataPoint(x, y, zoom);
                    // add jitter if specified
                    if (this.options.jitter) {
                        var hash = layerPoint.x + ':' + layerPoint.y;
                        if (collisions[hash]) {
                            applyJitter(layerPoint, this.options.jitterDistance);
                        }
                        collisions[hash] = true;
                    }
                    // get position in tile
                    tilePoint.x = layerPoint.x - xOffset;
                    tilePoint.y = TILE_SIZE - (layerPoint.y - yOffset);
                    // store point
                    points.push({
                        x: tilePoint.x,
                        y: tilePoint.y,
                        minX: layerPoint.x - radius,
                        maxX: layerPoint.x + radius,
                        minY: layerPoint.y - radius,
                        maxY: layerPoint.y + radius,
                        data: hit,
                        coords: coords
                    });
                    // add point to buffer
                    positions[i * 2] = tilePoint.x;
                    positions[i * 2 + 1] = tilePoint.y;
                }
                if (points.length > 0) {
                    // bulk insert points to the rtree
                    this._rtree.load(points);
                    // store points in the cache
                    cached.points = points;
                    // add to atlas
                    var ncoords = this.getNormalizedCoords(coords);
                    var _hash = this.cacheKeyFromCoord(ncoords);
                    this._atlas.addTile(_hash, positions, points.length);
                }
            }
        },

        onCacheUnload: function onCacheUnload(event) {
            var _this = this;

            var cached = event.entry;
            if (cached.points) {
                var coords = event.coords;
                // remove from atlas
                var ncoords = this.getNormalizedCoords(coords);
                var hash = this.cacheKeyFromCoord(ncoords);
                this._atlas.removeTile(hash);
                // remove from rtree
                cached.points.forEach(function (point) {
                    _this._rtree.remove(point);
                });
                cached.points = null;
            }
        },

        onMouseMove: function onMouseMove(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var collisions = this._rtree.search({
                minX: layerPixel.x,
                maxX: layerPixel.x,
                minY: layerPixel.y,
                maxY: layerPixel.y
            });
            if (collisions.length > 0) {
                var collision = collisions[0];
                // mimic mouseover / mouseout events
                if (this.highlighted) {
                    if (this.highlighted.value !== collision) {
                        // new collision
                        // execute mouseout for old
                        this.fire('mouseout', {
                            elem: target,
                            value: this.highlighted.value
                        });
                        // execute mouseover for new
                        this.fire('mouseover', {
                            elem: target,
                            value: collision
                        });
                    }
                } else {
                    // no previous collision, execute mouseover
                    this.fire('mouseover', {
                        elem: target,
                        value: collision
                    });
                }
                // use collision point to find tile
                var hash = this.cacheKeyFromCoord(collision.coords);
                // flag as highlighted
                this.highlighted = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    point: [collision.x, collision.y]
                };
                // set cursor
                $(this._map._container).css('cursor', 'pointer');
                return;
            }
            // mouse out
            if (this.highlighted) {
                this.fire('mouseout', {
                    elem: target,
                    value: this.highlighted.value
                });
            }
            // clear highlighted flag
            this.highlighted = null;
        },

        onClick: function onClick(e) {
            var target = e.originalEvent.target;
            var layerPixel = this.getLayerPointFromEvent(e.originalEvent);
            var collisions = this._rtree.search({
                minX: layerPixel.x,
                maxX: layerPixel.x,
                minY: layerPixel.y,
                maxY: layerPixel.y
            });
            if (collisions.length > 0) {
                var collision = collisions[0];
                // use collision point to find tile
                var hash = this.cacheKeyFromCoord(collision.coords);
                // flag as selected
                this.selected = {
                    tiles: this._cache[hash].tiles,
                    value: collision,
                    point: [collision.x, collision.y]
                };
                this.fire('click', {
                    elem: target,
                    value: collision
                });
            } else {
                this.selected = null;
            }
        },

        drawInstanced: function drawInstanced(circle, color, radius) {
            var _this2 = this;

            var gl = this._gl;
            var shader = this._instancedShader;
            var cache = this._cache;
            var zoom = this._map.getZoom();
            var atlas = this._atlas;
            if (this.options.blending) {
                // enable blending
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
            // use shader
            shader.use();
            // set uniforms
            shader.setUniform('uColor', color);
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uRadius', radius);
            // calc view offset
            var viewOffset = this.getViewOffset();
            // binds the circle to instance
            circle.bind();
            // bind offsets and enable instancing
            atlas.bind();
            // for each allocated chunk
            atlas.forEach(function (chunk, hash) {
                // for each tile referring to the data
                var cached = cache[hash];
                if (cached) {
                    // render for each tile
                    _.keys(cached.tiles).forEach(function (hash) {
                        var coords = _this2.coordFromCacheKey(hash);
                        if (coords.z !== zoom) {
                            // NOTE: we have to check here if the tiles are stale or not
                            return;
                        }
                        // get wrap offset
                        var wrapOffset = _this2.getWrapAroundOffset(coords);
                        // get tile offset
                        var tileOffset = _this2.getTileOffset(coords);
                        // calculate the total tile offset
                        var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                        shader.setUniform('uTileOffset', totalOffset);
                        // draw the instances
                        atlas.draw(hash, circle.mode, circle.count);
                    });
                }
            });
            // disable instancing
            atlas.unbind();
            // unbind buffer
            circle.unbind();
        },

        drawIndividual: function drawIndividual(circle, color, radius, tiles, point) {
            var _this3 = this;

            // draw selected points
            var gl = this._gl;
            var shader = this._individualShader;
            var zoom = this._map.getZoom();
            // bind the buffer
            circle.bind();
            // disable blending
            gl.disable(gl.BLEND);
            // use shader
            shader.use();
            // use uniform for offset
            shader.setUniform('uProjectionMatrix', this.getProjectionMatrix());
            shader.setUniform('uOpacity', this.getOpacity());
            shader.setUniform('uRadius', radius);
            // view offset
            var viewOffset = this.getViewOffset();
            _.forIn(tiles, function (tile) {
                if (tile.coords.z !== zoom) {
                    // NOTE: we have to check here if the tiles are stale or not
                    return;
                }
                // get wrap offset
                var wrapOffset = _this3.getWrapAroundOffset(tile.coords);
                // get tile offset
                var tileOffset = _this3.getTileOffset(tile.coords);
                // calculate the total tile offset
                var totalOffset = [tileOffset[0] + wrapOffset[0] - viewOffset[0], tileOffset[1] + wrapOffset[1] - viewOffset[1]];
                shader.setUniform('uTileOffset', totalOffset);
                shader.setUniform('uOffset', point);
                shader.setUniform('uColor', color);
                circle.draw();
            });
            // unbind the buffer
            circle.unbind();
        },

        renderFrame: function renderFrame() {
            // setup
            var gl = this._gl;
            var viewport = this._viewport;
            viewport.push();

            // draw instanced points

            // draw instanced fill
            this.drawInstanced(this._circleFillBuffer, this.options.fillColor, this.options.radius);
            // draw instanced outlines
            gl.lineWidth(this.options.outlineWidth);
            this.drawInstanced(this._circleOutlineBuffer, this.options.outlineColor, this.options.radius);

            // draw individual points

            if (this.highlighted) {
                // draw individual fill
                this.drawIndividual(this._circleFillBuffer, this.options.highlightedFillColor, this.options.highlightedRadius, this.highlighted.tiles, this.highlighted.point);
                // draw individual outline
                gl.lineWidth(this.options.outlineWidth);
                this.drawIndividual(this._circleOutlineBuffer, this.options.highlightedOutlineColor, this.options.highlightedRadius, this.highlighted.tiles, this.highlighted.point);
            }

            if (this.selected) {
                // draw individual fill
                this.drawIndividual(this._circleFillBuffer, this.options.selectedFillColor, this.options.selectedRadius, this.selected.tiles, this.selected.point);
                // draw individual outline
                gl.lineWidth(this.options.outlineWidth);
                this.drawIndividual(this._circleOutlineBuffer, this.options.selectedOutlineColor, this.options.selectedRadius, this.selected.tiles, this.selected.point);
            }

            // teardown
            viewport.pop();
        }

    });

    module.exports = Point;
})();

},{"../../core/WebGL":76,"./Shaders":100,"./Shapes":101,"./VertexAtlas":103,"esper":14,"rbush":25}],100:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var ColorRamp = require('../../mixin/ColorRamp');

    /**
     * precision
     */
    var precision = '\n        precision highp float;\n        precision highp int;\n        ';

    /**
     * decode float
     */
    var decodeRGBAToFloat = '\n        float decodeRGBAToFloat(vec4 v) {\n            return (v.x * 255.0 * 16777216.0) +\n                (v.y * 255.0 * 65536.0) +\n                (v.z * 255.0 * 256.0) +\n                v.w * 255.0;\n        }\n        ';

    /**
     * transforms
     */

    // log10
    var log10Transform = '\n        float log10(float val) {\n            return log(val) / log(10.0);\n        }\n        float log10Transform(float val, float minVal, float maxVal) {\n            if (minVal < 1.0) { minVal = 1.0; }\n            if (maxVal < 1.0) { maxVal = 1.0; }\n            if (val < 1.0) { val = 1.0; }\n            float logMin = log10(minVal);\n            float logMax = log10(maxVal);\n            float logVal = log10(val);\n            float range = logMax - logMin;\n            if (range == 0.0) { range = 1.0; }\n            return (logVal - logMin) / range;\n        }\n        ';

    // sigmoid
    var sigmoidTransform = '\n        float sigmoidTransform(float val, float minVal, float maxVal) {\n            minVal = abs(minVal);\n            maxVal = abs(maxVal);\n            float dist = max(minVal, maxVal);\n            float SIGMOID_SCALE = 0.15;\n            float scaledVal = val / (SIGMOID_SCALE * dist);\n            return 1.0 / (1.0 + exp(-scaledVal));\n        }\n        ';

    // linear
    var linearTransform = '\n        float linearTransform(float val, float minVal, float maxVal) {\n            float range = maxVal - minVal;\n            if (range == 0.0) { range = 1.0; }\n            return (val - minVal) / range;\n        }\n        ';

    var transform = log10Transform + sigmoidTransform + linearTransform + '\n        #define LOG_TRANSFORM 0\n        #define LINEAR_TRANSFORM 1\n        #define SIGMOID_TRANSFORM 2\n        uniform int uTransformType;\n        uniform float uMin;\n        uniform float uMax;\n        float transform(float val) {\n            if (val < uMin) { val = uMin; }\n            if (val > uMax) { val = uMax; }\n            if (uTransformType == LINEAR_TRANSFORM) {\n                return linearTransform(val, uMin, uMax);\n            } else if (uTransformType == SIGMOID_TRANSFORM) {\n                return sigmoidTransform(val, uMin, uMax);\n            }\n            return log10Transform(val, uMin, uMax);\n        }\n        ';

    /**
     * Color ramp
     */
    var colorRamp = '\n        #define RAMP_VALUES ' + ColorRamp.NUM_GRADIENT_STEPS + '\n        uniform vec4 uRamp[RAMP_VALUES];\n        vec4 colorRamp(float value) {\n            float maxIndex = float(RAMP_VALUES - 1);\n            int index = int(value * maxIndex);\n            // NOTE: I REALLY don\'t like this, but it seems to be the only way\n            // to index the uRamp array\n            for (int i=0; i<RAMP_VALUES; i++) {\n                if (i == index) {\n                    return uRamp[i];\n                }\n            }\n            return vec4(1.0, 0.0, 1.0, 1.0);\n        }\n        ';

    /**
     * Value Range
     */
    var valueRange = '\n        uniform float uRangeMin;\n        uniform float uRangeMax;\n        float interpolateToRange(float nval) {\n            float rval = (nval - uRangeMin) / (uRangeMax - uRangeMin);\n            if (rval > 1.0) {\n                rval = 1.0;\n            } else if (rval < 0.0) {\n                rval = 0.0;\n            }\n            return rval;\n        }\n        ';

    /**
     * heatmap shader
     */
    var heatmap = {
        vert: precision + '\n            attribute vec2 aPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat4 uProjectionMatrix;\n            uniform ivec2 uTileOffset;\n            uniform vec2 uTextureCoordOffset;\n            uniform vec2 uTextureCoordExtent;\n            varying vec2 vTextureCoord;\n            void main() {\n                vTextureCoord = vec2(\n                    uTextureCoordOffset.x + (aTextureCoord.x * uTextureCoordExtent.x),\n                    uTextureCoordOffset.y + (aTextureCoord.y * uTextureCoordExtent.y));\n                ivec2 wPosition = ivec2(aPosition) + uTileOffset;\n                gl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + decodeRGBAToFloat + transform + colorRamp + valueRange + '\n            uniform sampler2D uTextureSampler;\n            uniform float uOpacity;\n            varying vec2 vTextureCoord;\n            void main() {\n                vec4 enc = texture2D(uTextureSampler, vTextureCoord);\n                float count = decodeRGBAToFloat(enc);\n                if (count == 0.0) {\n                    discard;\n                }\n                float nval = transform(count);\n                float rval = interpolateToRange(nval);\n                vec4 color = colorRamp(rval);\n                gl_FragColor = vec4(color.rgb, color.a * uOpacity);\n            }\n            '
    };

    /**
     * instanced point shader
     */
    var instancedPoint = {
        vert: precision + '\n            attribute vec2 aPosition;\n            attribute vec2 aOffset;\n            uniform ivec2 uTileOffset;\n            uniform float uRadius;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                ivec2 iOffset = ivec2(aOffset);\n                vec2 mPosition = (uRadius * aPosition) + vec2(iOffset + uTileOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    var point = {
        vert: precision + '\n            attribute vec2 aPosition;\n            uniform ivec2 uOffset;\n            uniform ivec2 uTileOffset;\n            uniform float uRadius;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                vec2 mPosition = uRadius * aPosition + vec2(uOffset + uTileOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    /**
     * instanced ring shader
     */
    var instancedRing = {
        vert: precision + '\n            attribute vec3 aPosition;\n            attribute vec2 aOffset;\n            attribute float aRadius;\n            uniform ivec2 uTileOffset;\n            uniform float uDegrees;\n            uniform float uRadiusOffset;\n            uniform mat4 uProjectionMatrix;\n            uniform vec4 uColor;\n            varying vec4 vColor;\n            void main() {\n                ivec2 iOffset = ivec2(aOffset);\n                vec2 mPosition = (aPosition.xy + (normalize(aPosition.xy) * (aRadius - uRadiusOffset))) + vec2(iOffset + uTileOffset);\n                if (aPosition.z > uDegrees) {\n                    vColor = vec4(0.0, 0.0, 0.0, 0.0);\n                } else {\n                    vColor = uColor;\n                }\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            varying vec4 vColor;\n            void main() {\n                if (vColor.a == 0.0) {\n                    discard;\n                }\n                gl_FragColor = vec4(vColor.rgb, vColor.a * uOpacity);\n            }\n            '
    };

    var ring = {
        vert: precision + '\n            attribute vec3 aPosition;\n            uniform ivec2 uOffset;\n            uniform float uRadius;\n            uniform float uDegrees;\n            uniform float uRadiusOffset;\n            uniform ivec2 uTileOffset;\n            uniform mat4 uProjectionMatrix;\n            uniform vec4 uColor;\n            varying vec4 vColor;\n            void main() {\n                vec2 mPosition = (aPosition.xy + (normalize(aPosition.xy) * (uRadius - uRadiusOffset))) + vec2(uOffset + uTileOffset);\n                if (aPosition.z > uDegrees) {\n                    vColor = vec4(0.0, 0.0, 0.0, 0.0);\n                } else {\n                    vColor = uColor;\n                }\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            varying vec4 vColor;\n            void main() {\n                if (vColor.a == 0.0) {\n                    discard;\n                }\n                gl_FragColor = vec4(vColor.rgb, vColor.a * uOpacity);\n            }\n            '
    };

    /**
     * instanced ring shader
     */
    var instancedTick = {
        vert: precision + '\n            attribute vec2 aPosition;\n            attribute vec2 aOffset;\n            attribute float aRadius;\n            uniform ivec2 uTileOffset;\n            uniform float uRadiusOffset;\n            uniform mat4 uProjectionMatrix;\n            void main() {\n                ivec2 iOffset = ivec2(aOffset);\n                vec2 mPosition = (aPosition + (vec2(0, 1) * aRadius)) + vec2(iOffset + uTileOffset);\n                gl_Position = uProjectionMatrix * vec4(mPosition, 0.0, 1.0);\n            }\n            ',
        frag: precision + '\n            uniform float uOpacity;\n            uniform vec4 uColor;\n            void main() {\n                gl_FragColor = vec4(uColor.rgb, uColor.a * uOpacity);\n            }\n            '
    };

    module.exports = {

        /**
         * heatmap shader
         */
        heatmap: heatmap,

        /**
         * instanced point shader
         */
        instancedPoint: instancedPoint,

        /**
         * point shader
         */
        point: point,

        /**
         * instanced ring shader
         */
        instancedRing: instancedRing,

        /**
         * ring shader
         */
        ring: ring,

        /**
         * instanced tick shader
         */
        instancedTick: instancedTick

    };
})();

},{"../../mixin/ColorRamp":78}],101:[function(require,module,exports){
'use strict';

(function () {

    'use strict';

    var esper = require('esper');

    function circleOutline(numSegments) {
        var theta = 2 * Math.PI / numSegments;
        var radius = 1.0;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        // start at angle = 0
        var x = radius;
        var y = 0;
        var positions = new Float32Array(numSegments * 2);
        for (var i = 0; i < numSegments; i++) {
            positions[i * 2] = x;
            positions[i * 2 + 1] = y;
            // apply the rotation
            var t = x;
            x = c * x - s * y;
            y = s * t + c * y;
        }
        var pointers = {
            0: {
                size: 2,
                type: 'FLOAT'
            }
        };
        var options = {
            mode: 'LINE_LOOP',
            count: positions.length / 2
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    function circleFill(numSegments) {
        var theta = 2 * Math.PI / numSegments;
        var radius = 1.0;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        // start at angle = 0
        var x = radius;
        var y = 0;
        var positions = new Float32Array((numSegments + 2) * 2);
        positions[0] = 0;
        positions[1] = 0;
        positions[positions.length - 2] = radius;
        positions[positions.length - 1] = 0;
        for (var i = 0; i < numSegments; i++) {
            positions[(i + 1) * 2] = x;
            positions[(i + 1) * 2 + 1] = y;
            // apply the rotation
            var t = x;
            x = c * x - s * y;
            y = s * t + c * y;
        }
        var pointers = {
            0: {
                size: 2,
                type: 'FLOAT'
            }
        };
        var options = {
            mode: 'TRIANGLE_FAN',
            count: positions.length / 2
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    function ringFill(numSegments, radius, outline) {
        var theta = 2 * Math.PI / numSegments;
        // precalculate sine and cosine
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        // start at angle = 0
        var x0 = 0;
        var y0 = radius - outline / 2;
        var x1 = 0;
        var y1 = radius + outline / 2;
        var degPerSeg = 360 / (numSegments + 1);
        var positions = new Float32Array((numSegments + 1) * (3 + 3));
        for (var i = 0; i <= numSegments; i++) {
            positions[i * 6] = x0;
            positions[i * 6 + 1] = y0;
            positions[i * 6 + 2] = i * degPerSeg;
            positions[i * 6 + 3] = x1;
            positions[i * 6 + 4] = y1;
            positions[i * 6 + 5] = i * degPerSeg;
            // apply the rotation
            var t = x0;
            x0 = c * x0 - s * y0;
            y0 = s * t + c * y0;
            t = x1;
            x1 = c * x1 - s * y1;
            y1 = s * t + c * y1;
        }
        var pointers = {
            0: {
                size: 3, // x, y, degree
                type: 'FLOAT'
            }
        };
        var options = {
            mode: 'TRIANGLE_STRIP',
            count: positions.length / 3
        };
        return new esper.VertexBuffer(positions, pointers, options);
    }

    function quadTextured(size) {
        // quad vertices
        var vertices = new Float32Array([
        // positions
        0, 0, size, 0, size, size, 0, 0, size, size, 0, size,
        // uvs
        0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]);
        // quad buffer
        return new esper.VertexBuffer(vertices, {
            0: {
                size: 2,
                type: 'FLOAT',
                byteOffset: 0
            },
            1: {
                size: 2,
                type: 'FLOAT',
                byteOffset: 2 * 6 * 4
            }
        }, {
            count: 6
        });
    }

    function quadFill(left, right, bottom, top) {
        // quad vertices
        var vertices = new Float32Array([
        // positions
        left, bottom, right, bottom, right, top, left, bottom, right, top, left, top]);
        // quad buffer
        return new esper.VertexBuffer(vertices, {
            0: {
                size: 2,
                type: 'FLOAT',
                byteOffset: 0
            }
        }, {
            count: 6
        });
    }

    module.exports = {

        circle: {
            fill: circleFill,
            outline: circleOutline
        },

        quad: {
            textured: quadTextured,
            fill: quadFill
        },

        ring: {
            fill: ringFill
        }

    };
})();

},{"esper":14}],102:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {

    'use strict';

    var esper = require('esper');

    var TILE_SIZE = 256;
    var HORIZONTAL_TILES = 16;
    var VERTICAL_TILES = 8;

    var TextureAtlas = function () {
        function TextureAtlas() {
            _classCallCheck(this, TextureAtlas);

            // mega texture for all tiles
            this.texture = new esper.Texture2D({
                width: TILE_SIZE * HORIZONTAL_TILES,
                height: TILE_SIZE * VERTICAL_TILES,
                src: null,
                mipMap: false,
                format: 'RGBA',
                type: 'UNSIGNED_BYTE',
                wrap: 'CLAMP_TO_EDGE',
                filter: 'NEAREST',
                invertY: true
            });
            // init the chunks// allocate available chunks
            this.available = new Array(HORIZONTAL_TILES * VERTICAL_TILES);
            for (var i = 0; i < HORIZONTAL_TILES; i++) {
                for (var j = 0; j < VERTICAL_TILES; j++) {
                    this.available[i * VERTICAL_TILES + j] = {
                        xPixelOffset: i * TILE_SIZE,
                        yPixelOffset: j * TILE_SIZE,
                        uvOffset: [i / HORIZONTAL_TILES, j / VERTICAL_TILES],
                        uvExtent: [0, 0],
                        resolution: 0
                    };
                }
            }
            this.used = new Map();
        }

        _createClass(TextureAtlas, [{
            key: 'addTile',
            value: function addTile(hash, data) {
                if (this.available.length === 0) {
                    console.warn('No available chunks remaining to buffer data');
                    return;
                }
                // get an available chunk
                var chunk = this.available.pop();
                // set chunk resolution and extents
                chunk.resolution = Math.sqrt(data.length / 4);
                chunk.uvExtent[0] = chunk.resolution / TILE_SIZE / HORIZONTAL_TILES;
                chunk.uvExtent[1] = chunk.resolution / TILE_SIZE / VERTICAL_TILES;
                // buffer the data into the physical chunk
                this.texture.bufferSubData(data, chunk.xPixelOffset, chunk.yPixelOffset, chunk.resolution, chunk.resolution);
                // flag as used
                this.used.set(hash, chunk);
            }
        }, {
            key: 'removeTile',
            value: function removeTile(hash) {
                var chunk = this.used.get(hash);
                // remove from used
                this.used.delete(hash);
                // add as a new available chunk
                this.available.push(chunk);
            }
        }, {
            key: 'forEach',
            value: function forEach(fn) {
                this.used.forEach(fn);
            }
        }]);

        return TextureAtlas;
    }();

    module.exports = TextureAtlas;
})();

},{"esper":14}],103:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {

    'use strict';

    var esper = require('esper');

    var TILE_SIZE = 256;
    var MAX_TILES = 128;
    var MAX_POINTS_PER_TILE = TILE_SIZE * TILE_SIZE;

    var BYTES_PER_TYPE = {
        BYTE: 1,
        UNSIGNED_BYTE: 1,
        SHORT: 2,
        UNSIGNED_SHORT: 2,
        FIXED: 4,
        FLOAT: 4
    };

    var calcChunkByteSize = function calcChunkByteSize(pointers, chunkSize) {
        var byteSize = 0;
        pointers.forEach(function (pointer) {
            byteSize += BYTES_PER_TYPE[pointer.type] * pointer.size * chunkSize;
        });
        return byteSize;
    };

    var calcByteOffsets = function calcByteOffsets(chunk, pointers, chunkByteOffset) {
        var byteOffset = 0;
        pointers.forEach(function (pointer, location) {
            chunk.byteOffsets[location] = chunkByteOffset + byteOffset;
            byteOffset += BYTES_PER_TYPE[pointer.type] * pointer.size;
        });
        chunk.byteStride = byteOffset;
    };

    var VertexAtlas = function () {
        function VertexAtlas(pointers) {
            var _this = this;

            _classCallCheck(this, VertexAtlas);

            // get context
            var gl = this.gl = esper.WebGLContext.get();
            // get the extension for hardware instancing
            this.ext = esper.WebGLContext.getExtension('ANGLE_instanced_arrays');
            if (!this.ext) {
                throw 'ANGLE_instanced_arrays WebGL extension is not supported';
            }
            this.numChunks = MAX_TILES;
            this.chunkSize = MAX_POINTS_PER_TILE;
            // set the pointers of the atlas
            this.pointers = new Map();
            _.forIn(pointers, function (pointer, index) {
                _this.pointers.set(index, pointer);
            });
            // create available chunks
            this.available = new Array(this.numChunks);
            // calc the chunk byte size
            var chunkByteSize = calcChunkByteSize(this.pointers, this.chunkSize);
            // for each chunk
            for (var i = 0; i < this.numChunks; i++) {
                var chunkByteOffset = i * chunkByteSize;
                var available = {
                    count: 0,
                    chunkByteOffset: chunkByteOffset,
                    byteOffsets: {},
                    byteStride: 0
                };
                // calculate interleaved offsets / stride, this only needs
                // to be done once
                calcByteOffsets(available, this.pointers, chunkByteOffset);
                // add chunk
                this.available[i] = available;
            }
            this.used = new Map();
            // create buffer
            this.buffer = gl.createBuffer();
            // calc total size of the buffer
            var byteSize = chunkByteSize * this.numChunks;
            // buffer the data
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, byteSize, gl.DYNAMIC_DRAW);
        }

        _createClass(VertexAtlas, [{
            key: 'addTile',
            value: function addTile(key, data, count) {
                if (this.available.length === 0) {
                    console.warn('No available chunks remaining to buffer data');
                    return;
                }
                // get an available chunk
                var chunk = this.available.pop();
                // update chunk count
                chunk.count = count;
                // buffer the data
                var gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.bufferSubData(gl.ARRAY_BUFFER, chunk.chunkByteOffset, data);
                // add to used
                this.used.set(key, chunk);
            }
        }, {
            key: 'removeTile',
            value: function removeTile(key) {
                // get chunk
                var chunk = this.used.get(key);
                // remove from used
                this.used.delete(key);
                // add to available
                this.available.push(chunk);
                return this;
            }
        }, {
            key: 'bind',
            value: function bind() {
                var gl = this.gl;
                var ext = this.ext;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                // for each attribute pointer
                this.pointers.forEach(function (pointer, index) {
                    // enable attribute index
                    gl.enableVertexAttribArray(index);
                    // enable instancing this attribute
                    ext.vertexAttribDivisorANGLE(index, 1);
                });
                return this;
            }
        }, {
            key: 'unbind',
            value: function unbind() {
                var gl = this.gl;
                var ext = this.ext;
                // for each attribute pointer
                this.pointers.forEach(function (pointer, index) {
                    if (index !== 0) {
                        // disable attribute index
                        gl.disableVertexAttribArray(index);
                    }
                    // disable instancing this attribute
                    ext.vertexAttribDivisorANGLE(index, 0);
                });
                return this;
            }
        }, {
            key: 'forEach',
            value: function forEach(fn) {
                this.used.forEach(fn);
            }
        }, {
            key: 'draw',
            value: function draw(key, mode, count) {
                var gl = this.gl;
                var ext = this.ext;
                var chunk = this.used.get(key);
                // for each attribute pointer
                this.pointers.forEach(function (pointer, index) {
                    // set attribute pointer
                    gl.vertexAttribPointer(index, pointer.size, gl[pointer.type], false, chunk.byteStride, chunk.byteOffsets[index]);
                });
                // draw the bound vertex array
                ext.drawArraysInstancedANGLE(gl[mode], 0, count, chunk.count);
            }
        }]);

        return VertexAtlas;
    }();

    module.exports = VertexAtlas;
})();

},{"esper":14}],104:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {

    'use strict';

    var Requestor = require('./Requestor');

    var MetaRequestor = function (_Requestor) {
        _inherits(MetaRequestor, _Requestor);

        function MetaRequestor(url, callback) {
            _classCallCheck(this, MetaRequestor);

            return _possibleConstructorReturn(this, (MetaRequestor.__proto__ || Object.getPrototypeOf(MetaRequestor)).call(this, url, callback));
        }

        _createClass(MetaRequestor, [{
            key: 'getHash',
            value: function getHash(req) {
                return req.type + '-' + req.uri + '-' + req.store;
            }
        }, {
            key: 'getURL',
            value: function getURL(res) {
                return 'meta/' + res.type + '/' + res.endpoint + '/' + res.uri + '/' + res.store;
            }
        }]);

        return MetaRequestor;
    }(Requestor);

    module.exports = MetaRequestor;
})();

},{"./Requestor":105}],105:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {

    'use strict';

    var RETRY_INTERVAL = 5000;

    function getHost() {
        var loc = window.location;
        var new_uri = loc.protocol === 'https:' ? 'wss:' : 'ws:';
        return new_uri + '//' + loc.host + loc.pathname;
    }

    function establishConnection(requestor, callback) {
        requestor.socket = new WebSocket(getHost() + requestor.url);
        // on open
        requestor.socket.onopen = function () {
            requestor.isOpen = true;
            console.log('Websocket connection established');
            callback.apply(this, arguments);
        };
        // on message
        requestor.socket.onmessage = function (event) {
            var res = JSON.parse(event.data);
            var hash = requestor.getHash(res);
            var request = requestor.requests[hash];
            delete requestor.requests[hash];
            if (res.success) {
                request.resolve(requestor.getURL(res), res);
            } else {
                request.reject(res);
            }
        };
        // on close
        requestor.socket.onclose = function () {
            // log close only if connection was ever open
            if (requestor.isOpen) {
                console.warn('Websocket connection closed, attempting to re-connect in', RETRY_INTERVAL);
            }
            requestor.socket = null;
            requestor.isOpen = false;
            // reject all pending requests
            Object.keys(requestor.requests).forEach(function (key) {
                requestor.requests[key].reject();
            });
            // clear request map
            requestor.requests = {};
            // attempt to re-establish connection
            setTimeout(function () {
                establishConnection(requestor, function () {
                    // once connection is re-established, send pending requests
                    requestor.pending.forEach(function (req) {
                        requestor.get(req);
                    });
                    requestor.pending = [];
                });
            }, RETRY_INTERVAL);
        };
    }

    var Requestor = function () {
        function Requestor(url, callback) {
            _classCallCheck(this, Requestor);

            this.url = url;
            this.requests = {};
            this.pending = [];
            this.isOpen = false;
            establishConnection(this, callback);
        }

        _createClass(Requestor, [{
            key: 'getHash',
            value: function getHash() {
                // override
            }
        }, {
            key: 'getURL',
            value: function getURL() {
                // override
            }
        }, {
            key: 'get',
            value: function get(req) {
                if (!this.isOpen) {
                    // if no connection, add request to pending queue
                    this.pending.push(req);
                    return;
                }
                var hash = this.getHash(req);
                var request = this.requests[hash];
                if (request) {
                    return request.promise();
                }
                request = this.requests[hash] = $.Deferred();
                this.socket.send(JSON.stringify(req));
                return request.promise();
            }
        }, {
            key: 'close',
            value: function close() {
                this.socket.onclose = null;
                this.socket.close();
                this.socket = null;
            }
        }]);

        return Requestor;
    }();

    module.exports = Requestor;
})();

},{}],106:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

(function () {

    'use strict';

    var stringify = require('json-stable-stringify');
    var Requestor = require('./Requestor');

    function pruneEmpty(obj) {
        return function prune(current) {
            _.forOwn(current, function (value, key) {
                if (_.isUndefined(value) || _.isNull(value) || _.isNaN(value) || _.isString(value) && _.isEmpty(value) || _.isObject(value) && _.isEmpty(prune(value))) {
                    delete current[key];
                }
            });
            // remove any leftover undefined values from the delete
            // operation on an array
            if (_.isArray(current)) {
                _.pull(current, undefined);
            }
            return current;
        }(_.cloneDeep(obj)); // do not modify the original object, create a clone instead
    }

    var TileRequestor = function (_Requestor) {
        _inherits(TileRequestor, _Requestor);

        function TileRequestor(url, callback) {
            _classCallCheck(this, TileRequestor);

            return _possibleConstructorReturn(this, (TileRequestor.__proto__ || Object.getPrototypeOf(TileRequestor)).call(this, url, callback));
        }

        _createClass(TileRequestor, [{
            key: 'getHash',
            value: function getHash(req) {
                var coord = req.coord;
                var hash = stringify(pruneEmpty(req.params));
                return req.type + '-' + req.uri + '-' + req.store + '-' + coord.z + '-' + coord.x + '-' + coord.y + '-' + hash;
            }
        }, {
            key: 'getURL',
            value: function getURL(res) {
                var coord = res.coord;
                return 'tile/' + res.type + '/' + res.uri + '/' + res.store + '/' + coord.z + '/' + coord.x + '/' + coord.y;
            }
        }]);

        return TileRequestor;
    }(Requestor);

    module.exports = TileRequestor;
})();

},{"./Requestor":105,"json-stable-stringify":19}]},{},[28])(28)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvQ29sb3JUZXh0dXJlMkQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvRGVwdGhUZXh0dXJlMkQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvSW5kZXhCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvUmVuZGVyVGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1JlbmRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1NoYWRlclBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9lc3Blci9zcmMvY29yZS9UZXh0dXJlMkQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVGV4dHVyZUN1YmVNYXAuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVmVydGV4QnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9jb3JlL1ZlcnRleFBhY2thZ2UuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvVmlld3BvcnQuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL2NvcmUvV2ViR0xDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy9leHBvcnRzLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy91dGlsL0FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy91dGlsL0ltYWdlTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2VzcGVyL3NyYy91dGlsL1V0aWwuanMiLCJub2RlX21vZHVsZXMvZXNwZXIvc3JjL3V0aWwvWEhSTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzIiwic2NyaXB0cy9DUlMvR3JhcGguanMiLCJzY3JpcHRzL0NSUy9leHBvcnRzLmpzIiwic2NyaXB0cy9leHBvcnRzLmpzIiwic2NyaXB0cy9sYXllci9hZ2cvQ3VzdG9tQWdncy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL0RhdGVIaXN0b2dyYW0uanMiLCJzY3JpcHRzL2xheWVyL2FnZy9IaXN0b2dyYW0uanMiLCJzY3JpcHRzL2xheWVyL2FnZy9NZXRyaWMuanMiLCJzY3JpcHRzL2xheWVyL2FnZy9UZXJtcy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL1Rlcm1zRmlsdGVyLmpzIiwic2NyaXB0cy9sYXllci9hZ2cvVG9wSGl0cy5qcyIsInNjcmlwdHMvbGF5ZXIvYWdnL1RvcFRlcm1zLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0Jhc2UuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvQ29tcG9zaXRlLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0RlYnVnLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0ltYWdlLmpzIiwic2NyaXB0cy9sYXllci9jb3JlL0xpdmUuanMiLCJzY3JpcHRzL2xheWVyL2NvcmUvUGVuZGluZy5qcyIsInNjcmlwdHMvbGF5ZXIvZXhwb3J0cy5qcyIsInNjcmlwdHMvbGF5ZXIvcGFyYW0vQmlubmluZy5qcyIsInNjcmlwdHMvbGF5ZXIvcGFyYW0vRWxhc3RpYy5qcyIsInNjcmlwdHMvbGF5ZXIvcGFyYW0vVGlsaW5nLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9Cb29sLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9FeGlzdHMuanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L0hhc0NoaWxkLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9IYXNQYXJlbnQuanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L01hdGNoLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9QcmVmaXguanMiLCJzY3JpcHRzL2xheWVyL3F1ZXJ5L1F1ZXJ5U3RyaW5nLmpzIiwic2NyaXB0cy9sYXllci9xdWVyeS9SYW5nZS5qcyIsInNjcmlwdHMvbGF5ZXIvcXVlcnkvVGVybXMuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvQ29tbXVuaXR5LmpzIiwic2NyaXB0cy9sYXllci90eXBlL0NvdW50LmpzIiwic2NyaXB0cy9sYXllci90eXBlL0N1c3RvbS5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9GcmVxdWVuY3kuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvSGVhdG1hcC5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9NYWNyby5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9NaWNyby5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9QcmV2aWV3LmpzIiwic2NyaXB0cy9sYXllci90eXBlL1RvcENvdW50LmpzIiwic2NyaXB0cy9sYXllci90eXBlL1RvcEZyZXF1ZW5jeS5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Ub3BUcmFpbHMuanMiLCJzY3JpcHRzL2xheWVyL3R5cGUvVG9waWNDb3VudC5qcyIsInNjcmlwdHMvbGF5ZXIvdHlwZS9Ub3BpY0ZyZXF1ZW5jeS5qcyIsInNjcmlwdHMvbWFwL01hcC5qcyIsInNjcmlwdHMvcHJvamVjdGlvbi9HcmFwaC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvY29yZS9DYW52YXMuanMiLCJzY3JpcHRzL3JlbmRlcmVyL2NvcmUvRE9NLmpzIiwic2NyaXB0cy9yZW5kZXJlci9jb3JlL0hUTUwuanMiLCJzY3JpcHRzL3JlbmRlcmVyL2NvcmUvT3ZlcmxheS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvY29yZS9XZWJHTC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvZXhwb3J0cy5qcyIsInNjcmlwdHMvcmVuZGVyZXIvbWl4aW4vQ29sb3JSYW1wLmpzIiwic2NyaXB0cy9yZW5kZXJlci9taXhpbi9WYWx1ZVRyYW5zZm9ybS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvc2VudGltZW50L1NlbnRpbWVudC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9jYW52YXMvSGVhdG1hcC5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9jYW52YXMvUHJldmlldy5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9jYW52YXMvVG9wVHJhaWxzLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2RlYnVnL0Nvb3JkLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2h0bWwvQ29tbXVuaXR5TGFiZWwuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9FbXB0eS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9odG1sL0hlYXRtYXAuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvaHRtbC9SaW5nLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2h0bWwvV29yZENsb3VkLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL2h0bWwvV29yZEhpc3RvZ3JhbS5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS9wZW5kaW5nL0JsaW5rLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3BlbmRpbmcvQmxpbmtTcGluLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3BlbmRpbmcvRGVsYXllZEJsaW5rLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3BlbmRpbmcvRGVsYXllZFNwaW4uanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvcGVuZGluZy9TcGluLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3dlYmdsL0NsdXN0ZXIuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvd2ViZ2wvQ29tbXVuaXR5LmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3dlYmdsL0hlYXRtYXAuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvd2ViZ2wvUG9pbnQuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvd2ViZ2wvU2hhZGVycy5qcyIsInNjcmlwdHMvcmVuZGVyZXIvdHlwZS93ZWJnbC9TaGFwZXMuanMiLCJzY3JpcHRzL3JlbmRlcmVyL3R5cGUvd2ViZ2wvVGV4dHVyZUF0bGFzLmpzIiwic2NyaXB0cy9yZW5kZXJlci90eXBlL3dlYmdsL1ZlcnRleEF0bGFzLmpzIiwic2NyaXB0cy9yZXF1ZXN0L01ldGFSZXF1ZXN0b3IuanMiLCJzY3JpcHRzL3JlcXVlc3QvUmVxdWVzdG9yLmpzIiwic2NyaXB0cy9yZXF1ZXN0L1RpbGVSZXF1ZXN0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDampCQyxhQUFXOztBQUVSOztBQUVBLFFBQU0sUUFBUSxRQUFRLHFCQUFSLENBQWQ7O0FBRUEsTUFBRSxH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OlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBUZXh0dXJlMkQgPSByZXF1aXJlKCcuL1RleHR1cmUyRCcpO1xuICAgIGNvbnN0IEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9JbWFnZUxvYWRlcicpO1xuICAgIGNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuICAgIGNvbnN0IE1BR19GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IE1JTl9GSUxURVJTID0ge1xuICAgICAgICBORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVI6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTElORUFSOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX0xJTkVBUjogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgV1JBUF9NT0RFUyA9IHtcbiAgICAgICAgUkVQRUFUOiB0cnVlLFxuICAgICAgICBNSVJST1JFRF9SRVBFQVQ6IHRydWUsXG4gICAgICAgIENMQU1QX1RPX0VER0U6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IFRZUEVTID0ge1xuICAgICAgICBVTlNJR05FRF9CWVRFOiB0cnVlLFxuICAgICAgICBGTE9BVDogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgRk9STUFUUyA9IHtcbiAgICAgICAgUkdCOiB0cnVlLFxuICAgICAgICBSR0JBOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIGNvbG9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfVFlQRSA9ICdVTlNJR05FRF9CWVRFJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCBmb3IgY29sb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9GT1JNQVQgPSAnUkdCQSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB3cmFwIG1vZGUgZm9yIGNvbG9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfV1JBUCA9ICdSRVBFQVQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbWluIC8gbWFnIGZpbHRlciBmb3IgY29sb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9GSUxURVIgPSAnTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9QUkVNVUxUSVBMWV9BTFBIQSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBtaXBtYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9NSVBNQVAgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX0lOVkVSVF9ZID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBDb2xvclRleHR1cmUyRFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIDJEIGNvbG9yIHRleHR1cmUuXG4gICAgICogQGF1Z21lbnRzIFRleHR1cmUyRFxuICAgICAqL1xuICAgIGNsYXNzIENvbG9yVGV4dHVyZTJEIGV4dGVuZHMgVGV4dHVyZTJEIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGEgQ29sb3JUZXh0dXJlMkQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzcGVjaWZpY2F0aW9uIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzcGVjLmltYWdlIC0gVGhlIEhUTUxJbWFnZUVsZW1lbnQgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy51cmwgLSBUaGUgSFRNTEltYWdlRWxlbWVudCBVUkwgdG8gbG9hZCBhbmQgYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fSBzcGVjLnNyYyAtIFRoZSBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBTIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgUyBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBUIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1pbkZpbHRlciAtIFRoZSBtaW5pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1hZ0ZpbHRlciAtIFRoZSBtYWduaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMubWlwTWFwIC0gV2hldGhlciBvciBub3QgbWlwLW1hcHBpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBzcGVjLmludmVydFkgLSBXaGV0aGVyIG9yIG5vdCBpbnZlcnQteSBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMucHJlbXVsdGlwbHlBbHBoYSAtIFdoZXRoZXIgb3Igbm90IGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZvcm1hdCAtIFRoZSB0ZXh0dXJlIHBpeGVsIGZvcm1hdC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMudHlwZSAtIFRoZSB0ZXh0dXJlIHBpeGVsIGNvbXBvbmVudCB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBpZiB0aGUgZGF0YSBpcyBsb2FkZWQgYXN5bmNocm9ub3VzbHkgdmlhIGEgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9LCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGdldCBzcGVjaWZpYyBwYXJhbXNcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPSBzcGVjLndyYXBTIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMud3JhcFQgPSBzcGVjLndyYXBUIHx8IHNwZWMud3JhcDtcbiAgICAgICAgICAgIHNwZWMubWluRmlsdGVyID0gc3BlYy5taW5GaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICBzcGVjLm1hZ0ZpbHRlciA9IHNwZWMubWFnRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgLy8gc2V0IHRleHR1cmUgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gV1JBUF9NT0RFU1tzcGVjLndyYXBTXSA/IHNwZWMud3JhcFMgOiBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gV1JBUF9NT0RFU1tzcGVjLndyYXBUXSA/IHNwZWMud3JhcFQgOiBERUZBVUxUX1dSQVA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IE1JTl9GSUxURVJTW3NwZWMubWluRmlsdGVyXSA/IHNwZWMubWluRmlsdGVyIDogREVGQVVMVF9GSUxURVI7XG4gICAgICAgICAgICBzcGVjLm1hZ0ZpbHRlciA9IE1BR19GSUxURVJTW3NwZWMubWFnRmlsdGVyXSA/IHNwZWMubWFnRmlsdGVyIDogREVGQVVMVF9GSUxURVI7XG4gICAgICAgICAgICAvLyBzZXQgb3RoZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgc3BlYy5taXBNYXAgPSBzcGVjLm1pcE1hcCAhPT0gdW5kZWZpbmVkID8gc3BlYy5taXBNYXAgOiBERUZBVUxUX01JUE1BUDtcbiAgICAgICAgICAgIHNwZWMuaW52ZXJ0WSA9IHNwZWMuaW52ZXJ0WSAhPT0gdW5kZWZpbmVkID8gc3BlYy5pbnZlcnRZIDogREVGQVVMVF9JTlZFUlRfWTtcbiAgICAgICAgICAgIHNwZWMucHJlbXVsdGlwbHlBbHBoYSA9IHNwZWMucHJlbXVsdGlwbHlBbHBoYSAhPT0gdW5kZWZpbmVkID8gc3BlYy5wcmVtdWx0aXBseUFscGhhIDogREVGQVVMVF9QUkVNVUxUSVBMWV9BTFBIQTtcbiAgICAgICAgICAgIC8vIHNldCBmb3JtYXRcbiAgICAgICAgICAgIHNwZWMuZm9ybWF0ID0gRk9STUFUU1tzcGVjLmZvcm1hdF0gPyBzcGVjLmZvcm1hdCA6IERFRkFVTFRfRk9STUFUO1xuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSB0ZXh0dXJlIGJhc2VkIG9uIGFyZ3VtZW50IHR5cGVcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYy5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBzb3VyY2UgZnJvbSB1cmxcbiAgICAgICAgICAgICAgICBzcGVjLnR5cGUgPSAnVU5TSUdORURfQllURSc7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBiYXNlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcHV0IGV4dGVuc2lvbiBoYW5kbGluZyBmb3IgYXJyYXlidWZmZXIgLyBpbWFnZSAvIHZpZGVvIGRpZmZlcmVudGlhdGlvblxuICAgICAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHNwZWMuc3JjLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBpbWFnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdG8gdW5zaWduZWQgYnl0ZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IFV0aWwucmVzaXplQ2FudmFzKHNwZWMsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdyBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShpbWFnZSwgc3BlYy53aWR0aCwgc3BlYy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzQ2FudmFzVHlwZShzcGVjLnNyYykpIHtcbiAgICAgICAgICAgICAgICAvLyBpcyBpbWFnZSAvIGNhbnZhcyAvIHZpZGVvIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBzZXQgdG8gdW5zaWduZWQgYnl0ZSB0eXBlXG4gICAgICAgICAgICAgICAgc3BlYy50eXBlID0gJ1VOU0lHTkVEX0JZVEUnO1xuICAgICAgICAgICAgICAgIHNwZWMuc3JjID0gVXRpbC5yZXNpemVDYW52YXMoc3BlYywgc3BlYy5zcmMpO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSwgYXJyYXlidWZmZXIsIG9yIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zcmMgPT09IHVuZGVmaW5lZCB8fCBzcGVjLnNyYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBkYXRhIGlzIHByb3ZpZGVkLCBhc3N1bWUgdGhpcyB0ZXh0dXJlIHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8uIEluIHRoaXMgY2FzZSBkaXNhYmxlIG1pcG1hcHBpbmcsIHRoZXJlIGlzIG5vIG5lZWQgYW5kIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgb25seSBpbnRyb2R1Y2UgdmVyeSBwZWN1bGlhciBhbmQgZGlmZmljdWx0IHRvIGRpc2Nlcm5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIHBoZW5vbWVuYSBpbiB3aGljaCB0aGUgdGV4dHVyZSAndHJhbnNmb3JtcycgYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBhbmdsZXMgLyBkaXN0YW5jZXMgdG8gdGhlIG1pcG1hcHBlZCAoZW1wdHkpIHBvcnRpb25zLlxuICAgICAgICAgICAgICAgICAgICBzcGVjLm1pcE1hcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgZnJvbSBhcmdcbiAgICAgICAgICAgICAgICBzcGVjLnR5cGUgPSBUWVBFU1tzcGVjLnR5cGVdID8gc3BlYy50eXBlIDogREVGQVVMVF9UWVBFO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgYmFzZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb2xvclRleHR1cmUyRDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFRleHR1cmUyRCA9IHJlcXVpcmUoJy4vVGV4dHVyZTJEJyk7XG5cbiAgICBjb25zdCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBNSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBXUkFQX01PREVTID0ge1xuICAgICAgICBSRVBFQVQ6IHRydWUsXG4gICAgICAgIENMQU1QX1RPX0VER0U6IHRydWUsXG4gICAgICAgIE1JUlJPUkVEX1JFUEVBVDogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgREVQVEhfVFlQRVMgPSB7XG4gICAgICAgIFVOU0lHTkVEX0JZVEU6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiB0cnVlLFxuICAgICAgICBVTlNJR05FRF9JTlQ6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IEZPUk1BVFMgPSB7XG4gICAgICAgIERFUFRIX0NPTVBPTkVOVDogdHJ1ZSxcbiAgICAgICAgREVQVEhfU1RFTkNJTDogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciBkZXB0aCB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfSU5UJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCBmb3IgZGVwdGggdGV4dHVyZXMuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9GT1JNQVQgPSAnREVQVEhfQ09NUE9ORU5UJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHdyYXAgbW9kZSBmb3IgZGVwdGggdGV4dHVyZXMuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9XUkFQID0gJ0NMQU1QX1RPX0VER0UnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbWluIC8gbWFnIGZpbHRlciBmb3IgZGVwdGggdGV4dHVyZXMuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9GSUxURVIgPSAnTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBEZXB0aFRleHR1cmUyRFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIDJEIGRlcHRoIHRleHR1cmUuXG4gICAgICogQGF1Z21lbnRzIFRleHR1cmUyRFxuICAgICAqL1xuICAgIGNsYXNzIERlcHRoVGV4dHVyZTJEIGV4dGVuZHMgVGV4dHVyZTJEIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGEgRGVwdGhUZXh0dXJlMkQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSBzcGVjaWZpY2F0aW9uIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtVaW50OEFycmF5fFVpbnQxNkFycmF5fFVpbnQzMkFycmF5fSBzcGVjLnNyYyAtIFRoZSBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBTIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgUyBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLndyYXBUIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1pbkZpbHRlciAtIFRoZSBtaW5pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm1hZ0ZpbHRlciAtIFRoZSBtYWduaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLnR5cGUgLSBUaGUgdGV4dHVyZSBwaXhlbCBjb21wb25lbnQgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHNwZWMgPSB7fSkge1xuICAgICAgICAgICAgLy8gZ2V0IHNwZWNpZmljIHBhcmFtc1xuICAgICAgICAgICAgc3BlYy53cmFwUyA9IHNwZWMud3JhcFMgfHwgc3BlYy53cmFwO1xuICAgICAgICAgICAgc3BlYy53cmFwVCA9IHNwZWMud3JhcFQgfHwgc3BlYy53cmFwO1xuICAgICAgICAgICAgc3BlYy5taW5GaWx0ZXIgPSBzcGVjLm1pbkZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIHNwZWMubWFnRmlsdGVyID0gc3BlYy5tYWdGaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICAvLyBzZXQgdGV4dHVyZSBwYXJhbXNcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPSBXUkFQX01PREVTW3NwZWMud3JhcFNdID8gc3BlYy53cmFwUyA6IERFRkFVTFRfV1JBUDtcbiAgICAgICAgICAgIHNwZWMud3JhcFQgPSBXUkFQX01PREVTW3NwZWMud3JhcFRdID8gc3BlYy53cmFwVCA6IERFRkFVTFRfV1JBUDtcbiAgICAgICAgICAgIHNwZWMubWluRmlsdGVyID0gTUlOX0ZJTFRFUlNbc3BlYy5taW5GaWx0ZXJdID8gc3BlYy5taW5GaWx0ZXIgOiBERUZBVUxUX0ZJTFRFUjtcbiAgICAgICAgICAgIHNwZWMubWFnRmlsdGVyID0gTUFHX0ZJTFRFUlNbc3BlYy5tYWdGaWx0ZXJdID8gc3BlYy5tYWdGaWx0ZXIgOiBERUZBVUxUX0ZJTFRFUjtcbiAgICAgICAgICAgIC8vIHNldCBtaXAtbWFwcGluZyBhbmQgZm9ybWF0XG4gICAgICAgICAgICBzcGVjLm1pcE1hcCA9IGZhbHNlOyAvLyBkaXNhYmxlIG1pcC1tYXBwaW5nXG4gICAgICAgICAgICBzcGVjLmludmVydFkgPSBmYWxzZTsgLy8gbm8gbmVlZCB0byBpbnZlcnQteVxuICAgICAgICAgICAgc3BlYy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7IC8vIG5vIGFscGhhIHRvIHByZS1tdWx0aXBseVxuICAgICAgICAgICAgc3BlYy5mb3JtYXQgPSBGT1JNQVRTW3NwZWMuZm9ybWF0XSA/IHNwZWMuZm9ybWF0IDogREVGQVVMVF9GT1JNQVQ7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzdGVuY2lsLWRlcHRoLCBvciBqdXN0IGRlcHRoXG4gICAgICAgICAgICBpZiAoc3BlYy5mb3JtYXQgPT09ICdERVBUSF9TVEVOQ0lMJykge1xuICAgICAgICAgICAgICAgIHNwZWMudHlwZSA9ICdVTlNJR05FRF9JTlRfMjRfOF9XRUJHTCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwZWMudHlwZSA9IERFUFRIX1RZUEVTW3NwZWMudHlwZV0gPyBzcGVjLnR5cGUgOiBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsIGJhc2UgY29uc3RydWN0b3JcbiAgICAgICAgICAgIHN1cGVyKHNwZWMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEZXB0aFRleHR1cmUyRDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG5cbiAgICBjb25zdCBUWVBFUyA9IHtcbiAgICAgICAgVU5TSUdORURfQllURTogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfU0hPUlQ6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX0lOVDogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgTU9ERVMgPSB7XG4gICAgICAgIFBPSU5UUzogdHJ1ZSxcbiAgICAgICAgTElORVM6IHRydWUsXG4gICAgICAgIExJTkVfU1RSSVA6IHRydWUsXG4gICAgICAgIExJTkVfTE9PUDogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVTOiB0cnVlLFxuICAgICAgICBUUklBTkdMRV9TVFJJUDogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVfRkFOOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBCWVRFU19QRVJfVFlQRSA9IHtcbiAgICAgICAgVU5TSUdORURfQllURTogMSxcbiAgICAgICAgVU5TSUdORURfU0hPUlQ6IDIsXG4gICAgICAgIFVOU0lHTkVEX0lOVDogNFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb21wb25lbnQgdHlwZS5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfU0hPUlQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG1vZGUgKHByaW1pdGl2ZSB0eXBlKS5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX01PREUgPSAnVFJJQU5HTEVTJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGJ5dGUgb2Zmc2V0IHRvIHJlbmRlciBmcm9tLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfQllURV9PRkZTRVQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY291bnQgb2YgaW5kaWNlcyB0byByZW5kZXIuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9DT1VOVCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgSW5kZXhCdWZmZXJcbiAgICAgKiBAY2xhc3NkZXNjIEFuIGluZGV4IGJ1ZmZlciBjbGFzcyB0byBob2xlIGluZGV4aW5nIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEluZGV4QnVmZmVyIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGFuIEluZGV4QnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxVaW50OEFycmF5fFVpbnQxNkFycmF5fFVpbjMyQXJyYXl8QXJyYXl8TnVtYmVyfSBhcmcgLSBUaGUgaW5kZXggZGF0YSB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHJlbmRlcmluZyBvcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5tb2RlIC0gVGhlIGRyYXcgbW9kZSAvIHByaW1pdGl2ZSB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGRyYXcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihhcmcsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFRZUEVTW29wdGlvbnMudHlwZV0gPyBvcHRpb25zLnR5cGUgOiBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBNT0RFU1tvcHRpb25zLm1vZGVdID8gb3B0aW9ucy5tb2RlIDogREVGQVVMVF9NT0RFO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IChvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5jb3VudCA6IERFRkFVTFRfQ09VTlQ7XG4gICAgICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAob3B0aW9ucy5ieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5ieXRlT2Zmc2V0IDogREVGQVVMVF9CWVRFX09GRlNFVDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlYkdMQnVmZmVyIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG9mIHR5cGUgV2ViR0xCdWZmZXJgIG11c3QgYmUgY29tcGxpbWVudGVkIHdpdGggYSBjb3JyZXNwb25kaW5nIGBvcHRpb25zLmJ5dGVMZW5ndGhgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBvcHRpb25zLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5dGUgbGVuZ3RoIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG9mIHR5cGUgYG51bWJlcmAgbXVzdCBiZSBjb21wbGltZW50ZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgYG9wdGlvbnMudHlwZWAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlCdWZmZXIgYXJnXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG9mIHR5cGUgYEFycmF5QnVmZmVyYCBtdXN0IGJlIGNvbXBsaW1lbnRlZCB3aXRoIGEgY29ycmVzcG9uZGluZyBgb3B0aW9ucy50eXBlYCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgb3IgQXJyYXlCdWZmZXJWaWV3IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdFbXB0eSBidWZmZXIgbXVzdCBiZSBjb21wbGltZW50ZWQgd2l0aCBhIGNvcnJlc3BvbmRpbmcgYG9wdGlvbnMudHlwZWAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGxvYWQgaW5kZXggZGF0YSB0byB0aGUgR1BVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld3xudW1iZXJ9IGFyZyAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7SW5kZXhCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKGFyZykge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gY2FzdCBhcnJheSB0byBBcnJheUJ1ZmZlclZpZXcgYmFzZWQgb24gcHJvdmlkZWQgdHlwZVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRvIHVpbnQzMlxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDMyQXJyYXkoYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX1NIT1JUJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXIgdG8gdWludDE2XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IG5ldyBVaW50MTZBcnJheShhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0byB1aW50OFxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBuZXcgVWludDhBcnJheShhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGVuc3VyZSB0eXBlIGNvcnJlc3BvbmRzIHRvIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0lOVCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnVU5TSUdORURfU0hPUlQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnVU5TSUdORURfQllURSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIShhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgIShOdW1iZXIuaXNJbnRlZ2VyKGFyZykpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsIGBBcnJheUJ1ZmZlclZpZXdgLCBvciBgbnVtYmVyYCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfSU5UJyAmJlxuICAgICAgICAgICAgICAgICFXZWJHTENvbnRleHQuY2hlY2tFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdDYW5ub3QgY3JlYXRlIEluZGV4QnVmZmVyIG9mIHR5cGUgYFVOU0lHTkVEX0lOVGAgYXMgZXh0ZW5zaW9uIGBPRVNfZWxlbWVudF9pbmRleF91aW50YCBpcyBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSB0aGUgY291bnQgaWYgaXQgaXMgYWxyZWFkeSBzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID09PSBERUZBVUxUX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gKGFyZyAvIEJZVEVTX1BFUl9UWVBFW3RoaXMudHlwZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBieXRlIGxlbmd0aFxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGFyZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYXJnLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgYnVmZmVyIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidWZmZXIgdGhlIGRhdGFcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGFyZywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIHBhcnRpYWwgaW5kZXggZGF0YSB0byB0aGUgR1BVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYXJyYXkgLSBUaGUgYXJyYXkgb2YgZGF0YSB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGF0IHdoaWNoIHRvIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7SW5kZXhCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJTdWJEYXRhKGFycmF5LCBieXRlT2Zmc2V0ID0gREVGQVVMVF9CWVRFX09GRlNFVCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRocm93ICdCdWZmZXIgaGFzIG5vdCB5ZXQgYmVlbiBhbGxvY2F0ZWQsIGFsbG9jYXRlIHdpdGggYGJ1ZmZlckRhdGFgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgdG8gQXJyYXlCdWZmZXJWaWV3IGJhc2VkIG9uIHByb3ZpZGVkIHR5cGVcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRvIHVpbnQzMlxuICAgICAgICAgICAgICAgICAgICBhcnJheSA9IG5ldyBVaW50MzJBcnJheShhcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRvIHVpbnQxNlxuICAgICAgICAgICAgICAgICAgICBhcnJheSA9IG5ldyBVaW50MTZBcnJheShhcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRvIHVpbnQ4XG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIShhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmXG4gICAgICAgICAgICAgICAgIShhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSAmJlxuICAgICAgICAgICAgICAgICEoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAhKGFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCBvciBgQXJyYXlCdWZmZXJWaWV3YCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IHdlIGFyZW4ndCBvdmVyZmxvd2luZyB0aGUgYnVmZmVyXG4gICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIGFycmF5LmJ5dGVMZW5ndGggPiB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgQXJndW1lbnQgb2YgbGVuZ3RoICR7YXJyYXkuYnl0ZUxlbmd0aH0gYnl0ZXMgd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9mZnNldCBvZiAke2J5dGVPZmZzZXR9IGJ5dGVzIG92ZXJmbG93cyB0aGUgYnVmZmVyIGAgK1xuICAgICAgICAgICAgICAgICAgICBgbGVuZ3RoIG9mICR7dGhpcy5ieXRlTGVuZ3RofSBieXRlc2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBieXRlT2Zmc2V0LCBhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSBib3VuZCBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byAnZHJhd0VsZW1lbnRzJy4gT3B0aW9uYWwuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm1vZGUgLSBUaGUgZHJhdyBtb2RlIC8gcHJpbWl0aXZlIHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmJ5dGVPZmZzZXQgLSBUaGUgYnl0ZU9mZnNldCBpbnRvIHRoZSBkcmF3biBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNvdW50IC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBkcmF3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtJbmRleEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGRyYXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBjb25zdCBtb2RlID0gZ2xbb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZV07XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZ2xbdGhpcy50eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSAob3B0aW9ucy5ieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5ieXRlT2Zmc2V0IDogdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiB0aGlzLmNvdW50O1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dGVtcHRpbmcgdG8gZHJhdyB3aXRoIGEgY291bnQgb2YgMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgLy8gZHJhdyBlbGVtZW50c1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKG1vZGUsIGNvdW50LCB0eXBlLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdW5iaW5kXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW5kZXhCdWZmZXI7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBXZWJHTENvbnRleHQgPSByZXF1aXJlKCcuL1dlYkdMQ29udGV4dCcpO1xuXG4gICAgY29uc3QgVEVYVFVSRV9UQVJHRVRTID0ge1xuICAgICAgICBURVhUVVJFXzJEOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IERFUFRIX0ZPUk1BVFMgPSB7XG4gICAgICAgIERFUFRIX0NPTVBPTkVOVDogdHJ1ZSxcbiAgICAgICAgREVQVEhfU1RFTkNJTDogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgUmVuZGVyVGFyZ2V0XG4gICAgICogQGNsYXNzZGVzYyBBIHJlbmRlclRhcmdldCBjbGFzcyB0byBhbGxvdyByZW5kZXJpbmcgdG8gdGV4dHVyZXMuXG4gICAgICovXG4gICAgY2xhc3MgUmVuZGVyVGFyZ2V0IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGEgUmVuZGVyVGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBXZWJHTENvbnRleHQuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyB0aGUgcmVuZGVyVGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyVGFyZ2V0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYmluZCgpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgZnJhbWVidWZmZXJcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmRzIHRoZSByZW5kZXJUYXJnZXQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZW5kZXJUYXJnZXR9IFRoZSByZW5kZXJUYXJnZXQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB1bmJpbmQoKSB7XG4gICAgICAgICAgICAvLyB1bmJpbmQgZnJhbWVidWZmZXJcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlcyB0aGUgcHJvdmlkZWQgdGV4dHVyZSB0byB0aGUgcHJvdmlkZWQgYXR0YWNobWVudCBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtUZXh0dXJlMkR9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBhdHRhY2guXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBhdHRhY2htZW50IGluZGV4LiAob3B0aW9uYWwpXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXQgLSBUaGUgdGV4dHVyZSB0YXJnZXQgdHlwZS4gKG9wdGlvbmFsKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZW5kZXJUYXJnZXR9IFRoZSByZW5kZXJUYXJnZXQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDb2xvclRhcmdldCh0ZXh0dXJlLCBpbmRleCwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSBhcmd1bWVudCBpcyBtaXNzaW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChURVhUVVJFX1RBUkdFVFNbaW5kZXhdICYmIHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSBjb2xvciBhdHRhY2htZW50IGluZGV4IGlzIGludmFsaWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAhVEVYVFVSRV9UQVJHRVRTW3RhcmdldF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSB0YXJnZXQgaXMgaW52YWxpZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzLnNldChgY29sb3JfJHtpbmRleH1gLCB0ZXh0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgICAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgZ2xbJ0NPTE9SX0FUVEFDSE1FTlQnICsgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGdsW3RhcmdldCB8fCAnVEVYVFVSRV8yRCddLFxuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZSxcbiAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlcyB0aGUgcHJvdmlkZWQgdGV4dHVyZSB0byB0aGUgcHJvdmlkZWQgYXR0YWNobWVudCBsb2NhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtUZXh0dXJlMkR9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBhdHRhY2guXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlbmRlclRhcmdldCBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHNldERlcHRoVGFyZ2V0KHRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdUZXh0dXJlIGFyZ3VtZW50IGlzIG1pc3NpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFERVBUSF9GT1JNQVRTW3RleHR1cmUuZm9ybWF0XSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdQcm92aWRlZCB0ZXh0dXJlIGlzIG5vdCBvZiBmb3JtYXQgYERFUFRIX0NPTVBPTkVOVGAgb3IgYERFUFRIX1NURU5DSUxgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMuc2V0KCdkZXB0aCcsIHRleHR1cmUpO1xuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgICAgICBnbC5ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50ZXh0dXJlLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZXMgdGhlIHJlbmRlclRhcmdldCBhbmQgYWxsIGF0dGFjaGVkIHRleHR1cmVzIGJ5IHRoZSBwcm92aWRlZCBoZWlnaHQgYW5kIHdpZHRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSByZW5kZXJUYXJnZXQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgcmVuZGVyVGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZW5kZXJUYXJnZXR9IFRoZSByZW5kZXJUYXJnZXQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicgfHwgKHdpZHRoIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHdpZHRoXFxgIG9mICR7d2lkdGh9IGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IChoZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgaGVpZ2h0XFxgIG9mICR7aGVpZ2h0fSBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlbmRlclRhcmdldDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFZlcnRleFBhY2thZ2UgPSByZXF1aXJlKCcuLi9jb3JlL1ZlcnRleFBhY2thZ2UnKTtcbiAgICBjb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi9jb3JlL1ZlcnRleEJ1ZmZlcicpO1xuICAgIGNvbnN0IEluZGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vY29yZS9JbmRleEJ1ZmZlcicpO1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgdmVydGV4IGJ1ZmZlcnMgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGNvdW50c1xuICAgICAqIGFyZSBub3QgZXF1YWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRleEJ1ZmZlcnMgLSBUaGUgYXJyYXkgb2YgdmVydGV4QnVmZmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja1ZlcnRleEJ1ZmZlckNvdW50cyh2ZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIGxldCBjb3VudCA9IG51bGw7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMuZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBidWZmZXIuY291bnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCAhPT0gYnVmZmVyLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBWZXJ0ZXhCdWZmZXJzIG11c3QgYWxsIGhhdmUgdGhlIHNhbWUgY291bnQgdG8gYmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgcmVuZGVyZWQgd2l0aG91dCBhbiBJbmRleEJ1ZmZlciwgbWlzbWF0Y2ggb2YgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtjb3VudH0gYW5kICR7YnVmZmVyLmNvdW50fSBmb3VuZGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBhdHRyaWJ1dGUgcG9pbnRlcnMgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgYW4gaW5kZXhcbiAgICAgKiBvY2N1cnMgbW9yZSB0aGFuIG9uY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRleEJ1ZmZlcnMgLSBUaGUgYXJyYXkgb2YgdmVydGV4QnVmZmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0luZGV4Q29sbGlzaW9ucyh2ZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMuZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICAgICAgYnVmZmVyLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBpbmRpY2VzLmdldChpbmRleCkgfHwgMDtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnNldChpbmRleCwgY291bnQgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNlcy5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTW9yZSB0aGFuIG9uZSBhdHRyaWJ1dGUgcG9pbnRlciBleGlzdHMgZm9yIGluZGV4IFxcYCR7aW5kZXh9XFxgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFJlbmRlcmFibGVcbiAgICAgKiBAY2xhc3NkZXNjIEEgY29udGFpbmVyIGZvciBvbmUgb3IgbW9yZSBWZXJ0ZXhCdWZmZXJzIGFuZCBhbiBvcHRpb25hbCBJbmRleEJ1ZmZlci5cbiAgICAgKi9cbiAgICBjbGFzcyBSZW5kZXJhYmxlIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGFuIFJlbmRlcmFibGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyAtIFRoZSByZW5kZXJhYmxlIHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gc3BlYy52ZXJ0aWNlcyAtIFRoZSB2ZXJ0aWNlcyB0byBpbnRlcmxlYXZlIGFuZCBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7VmVydGV4QnVmZmVyfSBzcGVjLnZlcnRleEJ1ZmZlciAtIEFuIGV4aXN0aW5nIHZlcnRleCBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7VmVydGV4QnVmZmVyW119IHNwZWMudmVydGV4QnVmZmVycyAtIE11bHRpcGxlIGV4aXN0aW5nIHZlcnRleCBidWZmZXJzLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fFVpbnQxNkFycmF5fFVpbnQzMkFycmF5fSBzcGVjLmluZGljZXMgLSBUaGUgaW5kaWNlcyB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7SW5kZXhCdWZmZXJ9IHNwZWMuaW5kZXhidWZmZXIgLSBBbiBleGlzdGluZyBpbmRleCBidWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30pIHtcbiAgICAgICAgICAgIGlmIChzcGVjLnZlcnRleEJ1ZmZlciB8fCBzcGVjLnZlcnRleEJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgZXhpc3RpbmcgdmVydGV4IGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVycyA9IHNwZWMudmVydGV4QnVmZmVycyB8fCBbc3BlYy52ZXJ0ZXhCdWZmZXJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHZlcnRleCBwYWNrYWdlXG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGV4UGFja2FnZSA9IG5ldyBWZXJ0ZXhQYWNrYWdlKHNwZWMudmVydGljZXMpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB2ZXJ0ZXggYnVmZmVyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVmVydGV4QnVmZmVyKHZlcnRleFBhY2thZ2UpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBleGlzdGluZyBpbmRleCBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gc3BlYy5pbmRleEJ1ZmZlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlYy5pbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGluZGV4IGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIoc3BlYy5pbmRpY2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBpbmRleCBidWZmZXIsIGNoZWNrIHRoYXQgdmVydGV4IGJ1ZmZlcnMgYWxsIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGNvdW50XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBjaGVja1ZlcnRleEJ1ZmZlckNvdW50cyh0aGlzLnZlcnRleEJ1ZmZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCBubyBhdHRyaWJ1dGUgaW5kaWNlcyBjbGFzaFxuICAgICAgICAgICAgY2hlY2tJbmRleENvbGxpc2lvbnModGhpcy52ZXJ0ZXhCdWZmZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byAnZHJhd0VsZW1lbnRzJy4gT3B0aW9uYWwuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm1vZGUgLSBUaGUgZHJhdyBtb2RlIC8gcHJpbWl0aXZlIHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmJ5dGVPZmZzZXQgLSBUaGUgYnl0ZU9mZnNldCBpbnRvIHRoZSBkcmF3biBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmluZGV4T2Zmc2V0IC0gVGhlIGluZGV4T2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGRyYXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbmRlcmFibGV9IC0gVGhlIHJlbmRlcmFibGUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgLy8gZHJhdyB0aGUgcmVuZGVyYWJsZVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgaW5kZXggYnVmZmVyIHRvIGRyYXcgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBiaW5kIHZlcnRleCBidWZmZXJzIGFuZCBlbmFibGUgYXR0cmlidXRlIHBvaW50ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzLmZvckVhY2godmVydGV4QnVmZmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IHByaW1pdGl2ZXMgdXNpbmcgaW5kZXggYnVmZmVyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kcmF3KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgYXR0cmlidXRlIHBvaW50ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzLmZvckVhY2godmVydGV4QnVmZmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIG5vIGFkdmFudGFnZSB0byB1bmJpbmRpbmcgYXMgdGhlcmUgaXMgbm8gc3RhY2sgdXNlZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBpbmRleCBidWZmZXIsIHVzZSBkcmF3IGFycmF5c1xuICAgICAgICAgICAgICAgIC8vIHNldCBhbGwgYXR0cmlidXRlIHBvaW50ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXJzLmZvckVhY2godmVydGV4QnVmZmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhCdWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyc1swXS5kcmF3KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIGFsbCBhdHRyaWJ1dGUgcG9pbnRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlcnMuZm9yRWFjaCh2ZXJ0ZXhCdWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVuZGVyYWJsZTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgY29uc3QgU2hhZGVyUGFyc2VyID0gcmVxdWlyZSgnLi9TaGFkZXJQYXJzZXInKTtcbiAgICBjb25zdCBBc3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvQXN5bmMnKTtcbiAgICBjb25zdCBYSFJMb2FkZXIgPSByZXF1aXJlKCcuLi91dGlsL1hIUkxvYWRlcicpO1xuXG4gICAgY29uc3QgVU5JRk9STV9GVU5DVElPTlMgPSB7XG4gICAgICAgICdib29sJzogJ3VuaWZvcm0xaScsXG4gICAgICAgICdib29sW10nOiAndW5pZm9ybTFpdicsXG4gICAgICAgICdmbG9hdCc6ICd1bmlmb3JtMWYnLFxuICAgICAgICAnZmxvYXRbXSc6ICd1bmlmb3JtMWZ2JyxcbiAgICAgICAgJ2ludCc6ICd1bmlmb3JtMWknLFxuICAgICAgICAnaW50W10nOiAndW5pZm9ybTFpdicsXG4gICAgICAgICd1aW50JzogJ3VuaWZvcm0xaScsXG4gICAgICAgICd1aW50W10nOiAndW5pZm9ybTFpdicsXG4gICAgICAgICd2ZWMyJzogJ3VuaWZvcm0yZnYnLFxuICAgICAgICAndmVjMltdJzogJ3VuaWZvcm0yZnYnLFxuICAgICAgICAnaXZlYzInOiAndW5pZm9ybTJpdicsXG4gICAgICAgICdpdmVjMltdJzogJ3VuaWZvcm0yaXYnLFxuICAgICAgICAndmVjMyc6ICd1bmlmb3JtM2Z2JyxcbiAgICAgICAgJ3ZlYzNbXSc6ICd1bmlmb3JtM2Z2JyxcbiAgICAgICAgJ2l2ZWMzJzogJ3VuaWZvcm0zaXYnLFxuICAgICAgICAnaXZlYzNbXSc6ICd1bmlmb3JtM2l2JyxcbiAgICAgICAgJ3ZlYzQnOiAndW5pZm9ybTRmdicsXG4gICAgICAgICd2ZWM0W10nOiAndW5pZm9ybTRmdicsXG4gICAgICAgICdpdmVjNCc6ICd1bmlmb3JtNGl2JyxcbiAgICAgICAgJ2l2ZWM0W10nOiAndW5pZm9ybTRpdicsXG4gICAgICAgICdtYXQyJzogJ3VuaWZvcm1NYXRyaXgyZnYnLFxuICAgICAgICAnbWF0MltdJzogJ3VuaWZvcm1NYXRyaXgyZnYnLFxuICAgICAgICAnbWF0Myc6ICd1bmlmb3JtTWF0cml4M2Z2JyxcbiAgICAgICAgJ21hdDNbXSc6ICd1bmlmb3JtTWF0cml4M2Z2JyxcbiAgICAgICAgJ21hdDQnOiAndW5pZm9ybU1hdHJpeDRmdicsXG4gICAgICAgICdtYXQ0W10nOiAndW5pZm9ybU1hdHJpeDRmdicsXG4gICAgICAgICdzYW1wbGVyMkQnOiAndW5pZm9ybTFpJyxcbiAgICAgICAgJ3NhbXBsZXJDdWJlJzogJ3VuaWZvcm0xaSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBtYXAgb2YgZXhpc3RpbmcgYXR0cmlidXRlcywgZmluZCB0aGUgbG93ZXN0IGluZGV4IHRoYXQgaXMgbm90XG4gICAgICogYWxyZWFkeSB1c2VkLiBJZiB0aGUgYXR0cmlidXRlIG9yZGVyaW5nIHdhcyBhbHJlYWR5IHByb3ZpZGVkLCB1c2UgdGhhdFxuICAgICAqIGluc3RlYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWFwfSBhdHRyaWJ1dGVzIC0gVGhlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgbWFwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNsYXJhdGlvbiAtIFRoZSBhdHRyaWJ1dGUgZGVjbGFyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYXR0cmlidXRlIGluZGV4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUluZGV4KGF0dHJpYnV0ZXMsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGF0dHJpYnV0ZSBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBzbywgdXNlIHRoYXQgaW5kZXhcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzKGRlY2xhcmF0aW9uLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5nZXQoZGVjbGFyYXRpb24ubmFtZSkuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIG5leHQgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlLCBwYXJzZXMgdGhlIGRlY2xhcmF0aW9ucyBhbmQgYXBwZW5kcyBpbmZvcm1hdGlvbiBwZXJ0YWluaW5nIHRvIHRoZSB1bmlmb3JtcyBhbmQgYXR0cmlidHVlcyBkZWNsYXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0U291cmNlIC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnU291cmNlIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBhdHRyaWJ1dGUgYW5kIHVuaWZvcm0gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlc0FuZFVuaWZvcm1zKHNoYWRlciwgdmVydFNvdXJjZSwgZnJhZ1NvdXJjZSkge1xuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBTaGFkZXJQYXJzZXIucGFyc2VEZWNsYXJhdGlvbnMoXG4gICAgICAgICAgICBbdmVydFNvdXJjZSwgZnJhZ1NvdXJjZV0sXG4gICAgICAgICAgICBbJ3VuaWZvcm0nLCAnYXR0cmlidXRlJ10pO1xuICAgICAgICAvLyBmb3IgZWFjaCBkZWNsYXJhdGlvbiBpbiB0aGUgc2hhZGVyXG4gICAgICAgIGRlY2xhcmF0aW9ucy5mb3JFYWNoKGRlY2xhcmF0aW9uID0+IHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0cyBhbiBhdHRyaWJ1dGUgb3IgdW5pZm9ybVxuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnF1YWxpZmllciA9PT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhdHRyaWJ1dGUsIHN0b3JlIHR5cGUgYW5kIGluZGV4XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRBdHRyaWJ1dGVJbmRleChzaGFkZXIuYXR0cmlidXRlcywgZGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLnNldChkZWNsYXJhdGlvbi5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGRlY2xhcmF0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaWYgKGRlY2xhcmF0aW9uLnF1YWxpZmllciA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdW5pZm9ybSwgc3RvcmUgdHlwZSBhbmQgYnVmZmVyIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZGVjbGFyYXRpb24udHlwZSArIChkZWNsYXJhdGlvbi5jb3VudCA+IDEgPyAnW10nIDogJycpO1xuICAgICAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy5zZXQoZGVjbGFyYXRpb24ubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkZWNsYXJhdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jOiBVTklGT1JNX0ZVTkNUSU9OU1t0eXBlXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNoYWRlciBzb3VyY2Ugc3RyaW5nIGFuZCBzaGFkZXIgdHlwZSwgY29tcGlsZXMgdGhlIHNoYWRlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIFdlYkdMU2hhZGVyIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIHdlYmdsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkZXJTb3VyY2UgLSBUaGUgc2hhZGVyIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBzaGFkZXIgdHlwZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSBUaGUgY29tcGlsZWQgc2hhZGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCBzaGFkZXJTb3VyY2UsIHR5cGUpIHtcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsW3R5cGVdKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0FuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczpcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnMgZm9yIHRoZSBTaGFkZXIgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyIC0gVGhlIFNoYWRlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEF0dHJpYnV0ZUxvY2F0aW9ucyhzaGFkZXIpIHtcbiAgICAgICAgY29uc3QgZ2wgPSBzaGFkZXIuZ2w7XG4gICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gYmluZCB0aGUgYXR0cmlidXRlIGxvY2F0aW9uXG4gICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgc2hhZGVyLnByb2dyYW0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmluZGV4LFxuICAgICAgICAgICAgICAgIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIHRoZSB3ZWJnbCByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhlIHVuaWZvcm0gbG9jYXRpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyIC0gVGhlIFNoYWRlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VW5pZm9ybUxvY2F0aW9ucyhzaGFkZXIpIHtcbiAgICAgICAgY29uc3QgZ2wgPSBzaGFkZXIuZ2w7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0gc2hhZGVyLnVuaWZvcm1zO1xuICAgICAgICB1bmlmb3Jtcy5mb3JFYWNoKCh1bmlmb3JtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHVuaWZvcm0gbG9jYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlci5wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG51bGwsIHBhcnNlIG1heSBkZXRlY3QgdW5pZm9ybSB0aGF0IGlzIGNvbXBpbGVkIG91dFxuICAgICAgICAgICAgLy8gZHVlIHRvIGEgcHJlcHJvY2Vzc29yIGV2YWx1YXRpb24uXG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggcGFyc2VyIHNvIHRoYXQgaXQgZXZhbHVhdGVzIHRoZXNlIGNvcnJlY3RseS5cbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBzaGFkZXIgc291cmNlIGZyb20gYSB1cmwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIGxvYWQgdGhlIHJlc291cmNlIGZyb20uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRvIGxvYWQgdGhlIHNoYWRlciBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZFNoYWRlclNvdXJjZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIFhIUkxvYWRlci5sb2FkKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHBhc3MgdGhyb3VnaCB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdG8gcGFzcyB0aHJvdWdoIHRoZSBzaGFkZXIgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhc3NUaHJvdWdoU291cmNlKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgZG9uZShudWxsLCBzb3VyY2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFycmF5IG9mIEdMU0wgc291cmNlIHN0cmluZ3MgYW5kIFVSTHMsIGFuZCByZXNvbHZlcyB0aGVtIGludG8gYW5kIGFycmF5IG9mIEdMU0wgc291cmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gVGhlIHNoYWRlciBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2hhZGVyIHNvdXJjZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoc291cmNlcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgdGFza3MgPSBbXTtcbiAgICAgICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzIHx8IFtdO1xuICAgICAgICAgICAgc291cmNlcyA9ICFBcnJheS5pc0FycmF5KHNvdXJjZXMpID8gW3NvdXJjZXNdIDogc291cmNlcztcbiAgICAgICAgICAgIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChTaGFkZXJQYXJzZXIuaXNHTFNMKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChwYXNzVGhyb3VnaFNvdXJjZShzb3VyY2UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRTaGFkZXJTb3VyY2Uoc291cmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBc3luYy5wYXJhbGxlbCh0YXNrcywgZG9uZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgc2hhZGVyIHByb2dyYW0gb2JqZWN0IGZyb20gc291cmNlIHN0cmluZ3MuIFRoaXMgaW5jbHVkZXM6XG4gICAgICogICAgMSkgQ29tcGlsaW5nIGFuZCBsaW5raW5nIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKiAgICAyKSBQYXJzaW5nIHNoYWRlciBzb3VyY2UgZm9yIGF0dHJpYnV0ZSBhbmQgdW5pZm9ybSBpbmZvcm1hdGlvbi5cbiAgICAgKiAgICAzKSBCaW5kaW5nIGF0dHJpYnV0ZSBsb2NhdGlvbnMsIGJ5IG9yZGVyIG9mIGRlbGNhcmF0aW9uLlxuICAgICAqICAgIDQpIFF1ZXJ5aW5nIGFuZCBzdG9yaW5nIHVuaWZvcm0gbG9jYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2hhZGVyfSBzaGFkZXIgLSBUaGUgU2hhZGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlcyAtIEEgbWFwIGNvbnRhaW5pbmcgc291cmNlcyB1bmRlciAndmVydCcgYW5kICdmcmFnJyBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2hhZGVyfSBUaGUgc2hhZGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oc2hhZGVyLCBzb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IGdsID0gc2hhZGVyLmdsO1xuICAgICAgICBjb25zdCBjb21tb24gPSBzb3VyY2VzLmNvbW1vbi5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgdmVydCA9IHNvdXJjZXMudmVydC5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgZnJhZyA9IHNvdXJjZXMuZnJhZy5qb2luKCcnKTtcbiAgICAgICAgLy8gY29tcGlsZSBzaGFkZXJzXG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGNvbW1vbiArIHZlcnQsICdWRVJURVhfU0hBREVSJyk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgY29tbW9uICsgZnJhZywgJ0ZSQUdNRU5UX1NIQURFUicpO1xuICAgICAgICAvLyBwYXJzZSBzb3VyY2UgZm9yIGF0dHJpYnV0ZSBhbmQgdW5pZm9ybXNcbiAgICAgICAgc2V0QXR0cmlidXRlc0FuZFVuaWZvcm1zKHNoYWRlciwgdmVydCwgZnJhZyk7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgc2hhZGVyIHByb2dyYW1cbiAgICAgICAgc2hhZGVyLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIC8vIGF0dGFjaCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnNcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgLy8gYmluZCB2ZXJ0ZXggYXR0cmlidXRlIGxvY2F0aW9ucyBCRUZPUkUgbGlua2luZ1xuICAgICAgICBiaW5kQXR0cmlidXRlTG9jYXRpb25zKHNoYWRlcik7XG4gICAgICAgIC8vIGxpbmsgc2hhZGVyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICAgICAgLy8gSWYgY3JlYXRpbmcgdGhlIHNoYWRlciBwcm9ncmFtIGZhaWxlZCwgYWxlcnRcbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlci5wcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIHRocm93ICdBbiBlcnJvciBvY2N1cmVkIGxpbmtpbmcgdGhlIHNoYWRlcjpcXG4nICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBzaGFkZXIgdW5pZm9ybSBsb2NhdGlvbnNcbiAgICAgICAgZ2V0VW5pZm9ybUxvY2F0aW9ucyhzaGFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBTaGFkZXJcbiAgICAgKiBAY2xhc3NkZXNjIEEgc2hhZGVyIGNsYXNzIHRvIGFzc2lzdCBpbiBjb21waWxpbmcgYW5kIGxpbmtpbmcgd2ViZ2wgc2hhZGVycywgc3RvcmluZyBhdHRyaWJ1dGUgYW5kIHVuaWZvcm0gbG9jYXRpb25zLCBhbmQgYnVmZmVyaW5nIHVuaWZvcm1zLlxuICAgICAqL1xuICAgIGNsYXNzIFNoYWRlciB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIFNoYWRlciBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNoYWRlciBzcGVjaWZpY2F0aW9uIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118T2JqZWN0fSBzcGVjLmNvbW1vbiAtIFNvdXJjZXMgLyBVUkxzIHRvIGJlIHNoYXJlZCBieSBib3RoIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118T2JqZWN0fSBzcGVjLnZlcnQgLSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2VzIC8gVVJMcy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118T2JqZWN0fSBzcGVjLmZyYWcgLSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZXMgLyBVUkxzLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBzcGVjLmF0dHJpYnV0ZXMgLSBUaGUgYXR0cmlidXRlIGluZGV4IG9yZGVyaW5ncy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzaGFkZXIgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBpbGVkIGFuZCBsaW5rZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30sIGNhbGxiYWNrID0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgc291cmNlIGFyZ3VtZW50c1xuICAgICAgICAgICAgaWYgKCFzcGVjLnZlcnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVmVydGV4IHNoYWRlciBhcmd1bWVudCBgdmVydGAgaGFzIG5vdCBiZWVuIHByb3ZpZGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3BlYy5mcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0ZyYWdtZW50IHNoYWRlciBhcmd1bWVudCBgZnJhZ2AgaGFzIG5vdCBiZWVuIHByb3ZpZGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IDA7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gc3BlYy52ZXJzaW9uIHx8ICcxLjAwJztcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBpZiBhdHRyaWJ1dGUgb3JkZXJpbmcgaXMgcHJvdmlkZWQsIHVzZSB0aG9zZSBpbmRpY2VzXG4gICAgICAgICAgICBpZiAoc3BlYy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgc3BlYy5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5zZXQoYXR0ciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBzaGFkZXJcbiAgICAgICAgICAgIEFzeW5jLnBhcmFsbGVsKHtcbiAgICAgICAgICAgICAgICBjb21tb246IHJlc29sdmVTb3VyY2VzKHNwZWMuY29tbW9uKSxcbiAgICAgICAgICAgICAgICB2ZXJ0OiByZXNvbHZlU291cmNlcyhzcGVjLnZlcnQpLFxuICAgICAgICAgICAgICAgIGZyYWc6IHJlc29sdmVTb3VyY2VzKHNwZWMuZnJhZyksXG4gICAgICAgICAgICB9LCAoZXJyLCBzb3VyY2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9uY2UgYWxsIHNoYWRlciBzb3VyY2VzIGFyZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBjcmVhdGVQcm9ncmFtKHRoaXMsIHNvdXJjZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyB0aGUgc2hhZGVyIHByb2dyYW0gZm9yIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7U2hhZGVyfSBUaGUgc2hhZGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdXNlKCkge1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBzaGFkZXJcbiAgICAgICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGEgdW5pZm9ybSB2YWx1ZSBieSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSB1bmlmb3JtIG5hbWUgaW4gdGhlIHNoYWRlciBzb3VyY2UuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdW5pZm9ybSB2YWx1ZSB0byBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1NoYWRlcn0gLSBUaGUgc2hhZGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VW5pZm9ybShuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHVuaWZvcm0gc3BlYyBleGlzdHMgZm9yIHRoZSBuYW1lXG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTm8gdW5pZm9ybSBmb3VuZCB1bmRlciBuYW1lIFxcYCR7bmFtZX1cXGBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHVuaWZvcm0gYXJndW1lbnQgaXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRocm93IGBWYWx1ZSBwYXNzZWQgZm9yIHVuaWZvcm0gXFxgJHtuYW1lfVxcYCBpcyB1bmRlZmluZWQgb3IgbnVsbGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1cbiAgICAgICAgICAgIC8vIE5PVEU6IGNoZWNraW5nIHR5cGUgYnkgc3RyaW5nIGNvbXBhcmlzb24gaXMgZmFzdGVyIHRoYW4gd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbnMuXG4gICAgICAgICAgICBpZiAodW5pZm9ybS50eXBlID09PSAnbWF0MicgfHwgdW5pZm9ybS50eXBlID09PSAnbWF0MycgfHwgdW5pZm9ybS50eXBlID09PSAnbWF0NCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsW3VuaWZvcm0uZnVuY10odW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbFt1bmlmb3JtLmZ1bmNdKHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBhIG1hcCBvZiB1bmlmb3JtIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1zIC0gVGhlIG1hcCBvZiB1bmlmb3JtcyBrZXllZCBieSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRVbmlmb3JtcyhhcmdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybShuYW1lLCBhcmdzW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNoYWRlcjtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IENPTU1FTlRTX1JFR0VYUCA9IC8oXFwvXFwqKFtcXHNcXFNdKj8pXFwqXFwvKXwoXFwvXFwvKC4qKSQpL2dtO1xuICAgIGNvbnN0IEVORExJTkVfUkVHRVhQID0gLyhcXHJcXG58XFxufFxccikvZ207XG4gICAgY29uc3QgV0hJVEVTUEFDRV9SRUdFWFAgPSAvXFxzezIsfS9nO1xuICAgIGNvbnN0IEJSQUNLRVRfV0hJVEVTUEFDRV9SRUdFWFAgPSAvKFxccyopKFxcWykoXFxzKikoXFxkKykoXFxzKikoXFxdKShcXHMqKS9nO1xuICAgIGNvbnN0IE5BTUVfQ09VTlRfUkVHRVhQID0gLyhbYS16QS1aX11bYS16QS1aMC05X10qKSg/OlxcWyhcXGQrKVxcXSk/LztcbiAgICBjb25zdCBQUkVDSVNJT05fUkVHRVggPSAvXFxicHJlY2lzaW9uXFxzK1xcdytcXHMrXFx3KzsvZztcbiAgICBjb25zdCBJTkxJTkVfUFJFQ0lTSU9OX1JFR0VYID0gL1xcYihoaWdocHxtZWRpdW1wfGxvd3ApXFxzKy9nO1xuICAgIGNvbnN0IEdMU0xfUkVHRVhQID0gL3ZvaWRcXHMrbWFpblxccypcXChcXHMqKHZvaWQpKlxccypcXClcXHMqL21pO1xuICAgIGNvbnN0IFBSRVBfUkVHRVhQID0gLyMoW1xcV1xcd1xcc1xcZF0pKD86LipcXFxccj9cXG4pKi4qJC9nbTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc3RhbmRhcmQgY29tbWVudHMgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzdHJpcCBjb21tZW50cyBmcm9tLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29tbWVudGxlc3Mgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoc3RyKSB7XG4gICAgICAgIC8vIHJlZ2V4IHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vYWdyaXVzL3N0cmlwY29tbWVudHNcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKENPTU1FTlRTX1JFR0VYUCwgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gcHJlY2lzaW9uIHN0YXRlbWVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgdW5wcm9jZXNzZWQgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwcm9jZXNzZWQgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBQcmVjaXNpb24oc291cmNlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBnbG9iYWwgcHJlY2lzaW9uIGRlY2xhcmF0aW9uc1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShQUkVDSVNJT05fUkVHRVgsICcnKTtcbiAgICAgICAgLy8gcmVtb3ZlIGlubGluZSBwcmVjaXNpb24gZGVjbGFyYXRpb25zXG4gICAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShJTkxJTkVfUFJFQ0lTSU9OX1JFR0VYLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIHdoaXRlc3BhY2UgaW50byBhIHNpbmdsZSAnICcgc3BhY2UgY2hhcmFjdGVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBub3JtYWxpemUgd2hpdGVzcGFjZSBmcm9tLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbm9ybWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplV2hpdGVzcGFjZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKEVORExJTkVfUkVHRVhQLCAnICcpIC8vIHJlbW92ZSBsaW5lIGVuZGluZ3NcbiAgICAgICAgICAgIC5yZXBsYWNlKFdISVRFU1BBQ0VfUkVHRVhQLCAnICcpIC8vIG5vcm1hbGl6ZSB3aGl0ZXNwYWNlIHRvIHNpbmdsZSAnICdcbiAgICAgICAgICAgIC5yZXBsYWNlKEJSQUNLRVRfV0hJVEVTUEFDRV9SRUdFWFAsICckMiQ0JDYnKTsgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgaW4gYnJhY2tldHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIG5hbWUgYW5kIGNvdW50IG91dCBvZiBhIG5hbWUgc3RhdGVtZW50LCByZXR1cm5pbmcgdGhlIGRlY2xhcmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHF1YWxpZmllciAtIFRoZSBxdWFsaWZpZXIgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeSAtIFRoZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWNsYXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lQW5kQ291bnQocXVhbGlmaWVyLCB0eXBlLCBlbnRyeSkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbmFtZSBhbmQgc2l6ZSBvZiB2YXJpYWJsZVxuICAgICAgICBjb25zdCBtYXRjaGVzID0gZW50cnkubWF0Y2goTkFNRV9DT1VOVF9SRUdFWFApO1xuICAgICAgICBjb25zdCBuYW1lID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgY29uc3QgY291bnQgPSAobWF0Y2hlc1syXSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWFsaWZpZXI6IHF1YWxpZmllcixcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgY291bnQ6IGNvdW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2luZ2xlICdzdGF0ZW1lbnQnLiBBICdzdGF0ZW1lbnQnIGlzIGNvbnNpZGVyZWQgYW55IHNlcXVlbmNlIG9mXG4gICAgICogY2hhcmFjdGVycyBmb2xsb3dlZCBieSBhIHNlbWktY29sb24uIFRoZXJlZm9yZSwgYSBzaW5nbGUgJ3N0YXRlbWVudCcgaW5cbiAgICAgKiB0aGlzIHNlbnNlIGNvdWxkIGNvbnRhaW4gc2V2ZXJhbCBjb21tYSBzZXBhcmF0ZWQgZGVjbGFyYXRpb25zLiBSZXR1cm5zXG4gICAgICogYWxsIHJlc3VsdGluZyBkZWNsYXJhdGlvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZW1lbnQgLSBUaGUgc3RhdGVtZW50IHRvIHBhcnNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBhcnJheSBvZiBwYXJzZWQgZGVjbGFyYXRpb24gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudChzdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gc3BsaXQgc3RhdGVtZW50IG9uIGNvbW1hc1xuICAgICAgICAvL1xuICAgICAgICAvLyBbJ3VuaWZvcm0gbWF0NCBBWzEwXScsICdCJywgJ0NbMl0nXVxuICAgICAgICAvL1xuICAgICAgICBjb25zdCBzcGxpdCA9IHN0YXRlbWVudC5zcGxpdCgnLCcpLm1hcChlbGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLnRyaW0oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3BsaXQgZGVjbGFyYXRpb24gaGVhZGVyIGZyb20gc3RhdGVtZW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFsndW5pZm9ybScsICdtYXQ0JywgJ0FbMTBdJ11cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgaGVhZGVyID0gc3BsaXQuc2hpZnQoKS5zcGxpdCgnICcpO1xuXG4gICAgICAgIC8vIHF1YWxpZmllciBpcyBhbHdheXMgZmlyc3QgZWxlbWVudFxuICAgICAgICAvL1xuICAgICAgICAvLyAndW5pZm9ybSdcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgcXVhbGlmaWVyID0gaGVhZGVyLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gdHlwZSB3aWxsIGJlIHRoZSBzZWNvbmQgZWxlbWVudFxuICAgICAgICAvL1xuICAgICAgICAvLyAnbWF0NCdcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgdHlwZSA9IGhlYWRlci5zaGlmdCgpO1xuXG4gICAgICAgIC8vIGxhc3QgcGFydCBvZiBoZWFkZXIgd2lsbCBiZSB0aGUgZmlyc3QsIGFuZCBwb3NzaWJsZSBvbmx5IHZhcmlhYmxlIG5hbWVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gWydBWzEwXScsICdCJywgJ0NbMl0nXVxuICAgICAgICAvL1xuICAgICAgICBjb25zdCBuYW1lcyA9IGhlYWRlci5jb25jYXQoc3BsaXQpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdGhlciBuYW1lcyBhZnRlciBhICcsJyBhZGQgdGhlbSBhcyB3ZWxsXG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOYW1lQW5kQ291bnQocXVhbGlmaWVyLCB0eXBlLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzb3VyY2Ugc3RyaW5nIGJ5IHNlbWktY29sb25zIGFuZCBjb25zdHJ1Y3RzIGFuIGFycmF5IG9mXG4gICAgICogZGVjbGFyYXRpb24gb2JqZWN0cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcXVhbGlmaWVyIGtleXdvcmRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHNoYWRlciBzb3VyY2Ugc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBrZXl3b3JkcyAtIFRoZSBxdWFsaWZpZXIgZGVjbGFyYXRpb24ga2V5d29yZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHF1YWxpZmllciBkZWNsYXJhdGlvbiBvYmplY3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlKHNvdXJjZSwga2V5d29yZHMpIHtcbiAgICAgICAgLy8gZ2V0IGluZGl2aWR1YWwgc3RhdGVtZW50cyAoYW55IHNlcXVlbmNlIGVuZGluZyBpbiA7KVxuICAgICAgICBjb25zdCBzdGF0ZW1lbnRzID0gc291cmNlLnNwbGl0KCc7Jyk7XG4gICAgICAgIC8vIGJ1aWxkIHJlZ2V4IGZvciBwYXJzaW5nIHN0YXRlbWVudHMgd2l0aCB0YXJnZXR0ZWQga2V5d29yZHNcbiAgICAgICAgY29uc3Qga2V5d29yZFN0ciA9IGtleXdvcmRzLmpvaW4oJ3wnKTtcbiAgICAgICAgY29uc3Qga2V5d29yZFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXGIoJyArIGtleXdvcmRTdHIgKyAnKVxcXFxiLionKTtcbiAgICAgICAgLy8gcGFyc2UgYW5kIHN0b3JlIGdsb2JhbCBwcmVjaXNpb24gc3RhdGVtZW50cyBhbmQgYW55IGRlY2xhcmF0aW9uc1xuICAgICAgICBsZXQgbWF0Y2hlZCA9IFtdO1xuICAgICAgICAvLyBmb3IgZWFjaCBzdGF0ZW1lbnRcbiAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKHN0YXRlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBbJ3VuaWZvcm0gZmxvYXQgdVRpbWUnXVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGttYXRjaCA9IHN0YXRlbWVudC5tYXRjaChrZXl3b3JkUmVnZXgpO1xuICAgICAgICAgICAgaWYgKGttYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHN0YXRlbWVudCBhbmQgYWRkIHRvIGFycmF5XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoZWQuY29uY2F0KHBhcnNlU3RhdGVtZW50KGttYXRjaFswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyBvdXQgZHVwbGljYXRlIGRlY2xhcmF0aW9ucyBwcmVzZW50IGJldHdlZW4gc2hhZGVycy4gQ3VycmVudGx5XG4gICAgICoganVzdCByZW1vdmVzIGFsbCAjIHN0YXRlbWVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRlY2xhcmF0aW9ucyAtIFRoZSBhcnJheSBvZiBkZWNsYXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZpbHRlcmVkIGFycmF5IG9mIGRlY2xhcmF0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJEdXBsaWNhdGVzQnlOYW1lKGRlY2xhcmF0aW9ucykge1xuICAgICAgICAvLyBpbiBjYXNlcyB3aGVyZSB0aGUgc2FtZSBkZWNsYXJhdGlvbnMgYXJlIHByZXNlbnQgaW4gbXVsdGlwbGVcbiAgICAgICAgLy8gc291cmNlcywgdGhpcyBmdW5jdGlvbiB3aWxsIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIHJlc3VsdHNcbiAgICAgICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25zLmZpbHRlcihkZWNsYXJhdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAoc2VlbltkZWNsYXJhdGlvbi5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5bZGVjbGFyYXRpb24ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHByZXByb2Nlc3NvciBvbiB0aGUgZ2xzbCBjb2RlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHVucHJvY2Vzc2VkIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcHJvY2Vzc2VkIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3Moc291cmNlKSB7XG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCB0aGlzIGNvcnJlY3RseS4uLlxuICAgICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoUFJFUF9SRUdFWFAsICcnKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIHRoZSBwcm92aWRlZCBHTFNMIHNvdXJjZSwgYW5kIHJldHVybnMgYWxsIGRlY2xhcmF0aW9uIHN0YXRlbWVudHMgdGhhdCBjb250YWluIHRoZSBwcm92aWRlZCBxdWFsaWZpZXIgdHlwZS4gVGhpcyBjYW4gYmUgdXNlZCB0byBleHRyYWN0IGFsbCBhdHRyaWJ1dGVzIGFuZCB1bmlmb3JtIG5hbWVzIGFuZCB0eXBlcyBmcm9tIGEgc2hhZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBwcm92aWRlZCBhICd1bmlmb3JtJyBxdWFsaWZpZXJzLCB0aGUgZGVjbGFyYXRpb246XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAndW5pZm9ybSBoaWdocCB2ZWMzIHVTcGVjdWxhckNvbG9yOydcbiAgICAgICAgICpcbiAgICAgICAgICogV291bGQgYmUgcGFyc2VkIHRvOlxuICAgICAgICAgKiAgICAge1xuICAgICAgICAgKiAgICAgICAgIHF1YWxpZmllcjogJ3VuaWZvcm0nLFxuICAgICAgICAgKiAgICAgICAgIHR5cGU6ICd2ZWMzJyxcbiAgICAgICAgICogICAgICAgICBuYW1lOiAndVNwZWN1bGFyQ29sb3InLFxuICAgICAgICAgKiAgICAgICAgIGNvdW50OiAxXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZXMgLSBUaGUgc2hhZGVyIHNvdXJjZXMuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHF1YWxpZmllcnMgLSBUaGUgcXVhbGlmaWVycyB0byBleHRyYWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHF1YWxpZmllciBkZWNsYXJhdGlvbiBzdGF0ZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2VEZWNsYXJhdGlvbnM6IGZ1bmN0aW9uKHNvdXJjZXMgPSBbXSwgcXVhbGlmaWVycyA9IFtdKSB7XG4gICAgICAgICAgICAvLyBpZiBubyBzb3VyY2VzIG9yIHF1YWxpZmllcnMgYXJlIHByb3ZpZGVkLCByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCB8fCBxdWFsaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZXMgPSBBcnJheS5pc0FycmF5KHNvdXJjZXMpID8gc291cmNlcyA6IFtzb3VyY2VzXTtcbiAgICAgICAgICAgIHF1YWxpZmllcnMgPSBBcnJheS5pc0FycmF5KHF1YWxpZmllcnMpID8gcXVhbGlmaWVycyA6IFtxdWFsaWZpZXJzXTtcbiAgICAgICAgICAgIC8vIHBhcnNlIG91dCB0YXJnZXR0ZWQgZGVjbGFyYXRpb25zXG4gICAgICAgICAgICBsZXQgZGVjbGFyYXRpb25zID0gW107XG4gICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBydW4gcHJlcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgc291cmNlID0gcHJlcHJvY2Vzcyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwcmVjaXNpb24gc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHN0cmlwUHJlY2lzaW9uKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgc291cmNlID0gc3RyaXBDb21tZW50cyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIGZpbmFsbHksIG5vcm1hbGl6ZSB0aGUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG5vcm1hbGl6ZVdoaXRlc3BhY2Uoc291cmNlKTtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBvdXQgZGVjbGFyYXRpb25zXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zLmNvbmNhdChwYXJzZVNvdXJjZShzb3VyY2UsIHF1YWxpZmllcnMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIHJldHVyblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckR1cGxpY2F0ZXNCeU5hbWUoZGVjbGFyYXRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0cyBiYXNlZCBvbiB0aGUgZXhpc3RlbmNlIG9mIGEgJ3ZvaWQgbWFpbigpIHsnIHN0YXRlbWVudCwgaWYgdGhlIHN0cmluZyBpcyBnbHNsIHNvdXJjZSBjb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIGlucHV0IHN0cmluZyB0byB0ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGdsc2wgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzR0xTTDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gR0xTTF9SRUdFWFAudGVzdChzdHIpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgV2ViR0xDb250ZXh0ID0gcmVxdWlyZSgnLi9XZWJHTENvbnRleHQnKTtcbiAgICBjb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG5cbiAgICBjb25zdCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBNSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9MSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IE5PTl9NSVBNQVBfTUlOX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IE1JUE1BUF9NSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBXUkFQX01PREVTID0ge1xuICAgICAgICBSRVBFQVQ6IHRydWUsXG4gICAgICAgIE1JUlJPUkVEX1JFUEVBVDogdHJ1ZSxcbiAgICAgICAgQ0xBTVBfVE9fRURHRTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgREVQVEhfVFlQRVMgPSB7XG4gICAgICAgIERFUFRIX0NPTVBPTkVOVDogdHJ1ZSxcbiAgICAgICAgREVQVEhfU1RFTkNJTDogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX1RZUEUgPSAnVU5TSUdORURfQllURSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfRk9STUFUID0gJ1JHQkEnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgd3JhcCBtb2RlIGZvciB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX1dSQVAgPSAnUkVQRUFUJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1pbiAvIG1hZyBmaWx0ZXIgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfRklMVEVSID0gJ0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEEgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgbWlwbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfTUlQTUFQID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9JTlZFUlRfWSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaXAtbWFwcGluZyBmaWx0ZXIgc3VmZml4LlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfTUlQTUFQX01JTl9GSUxURVJfU1VGRklYID0gJ19NSVBNQVBfTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUZXh0dXJlMkRcbiAgICAgKiBAY2xhc3NkZXNjIEEgdGV4dHVyZSBjbGFzcyB0byByZXByZXNlbnQgYSAyRCB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGNsYXNzIFRleHR1cmUyRCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIFRleHR1cmUyRCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VWludDhBcnJheXxVaW50MTZBcnJheXxVaW50MzJBcnJheXxGbG9hdDMyQXJyYXl8SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc3BlYy5zcmMgLSBUaGUgZGF0YSB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLndpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy53cmFwIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciBib3RoIFMgYW5kIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy53cmFwUyAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFMgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy53cmFwVCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5maWx0ZXIgLSBUaGUgbWluIC8gbWFnIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5taW5GaWx0ZXIgLSBUaGUgbWluaWZpY2F0aW9uIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5tYWdGaWx0ZXIgLSBUaGUgbWFnbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBzcGVjLm1pcE1hcCAtIFdoZXRoZXIgb3Igbm90IG1pcC1tYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5pbnZlcnRZIC0gV2hldGhlciBvciBub3QgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBzcGVjLnByZW11bHRpcGx5QWxwaGEgLSBXaGV0aGVyIG9yIG5vdCBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLnR5cGUgLSBUaGUgdGV4dHVyZSBwaXhlbCBjb21wb25lbnQgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHNwZWMgPSB7fSkge1xuICAgICAgICAgICAgLy8gZ2V0IHNwZWNpZmljIHBhcmFtc1xuICAgICAgICAgICAgc3BlYy53cmFwUyA9IHNwZWMud3JhcFMgfHwgc3BlYy53cmFwO1xuICAgICAgICAgICAgc3BlYy53cmFwVCA9IHNwZWMud3JhcFQgfHwgc3BlYy53cmFwO1xuICAgICAgICAgICAgc3BlYy5taW5GaWx0ZXIgPSBzcGVjLm1pbkZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIHNwZWMubWFnRmlsdGVyID0gc3BlYy5tYWdGaWx0ZXIgfHwgc3BlYy5maWx0ZXI7XG4gICAgICAgICAgICAvLyBzZXQgY29udGV4dFxuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIC8vIGVtcHR5IHRleHR1cmVcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBzZXQgdGV4dHVyZSBwYXJhbXNcbiAgICAgICAgICAgIHRoaXMud3JhcFMgPSBzcGVjLndyYXBTIHx8IERFRkFVTFRfV1JBUDtcbiAgICAgICAgICAgIHRoaXMud3JhcFQgPSBzcGVjLndyYXBUIHx8IERFRkFVTFRfV1JBUDtcbiAgICAgICAgICAgIHRoaXMubWluRmlsdGVyID0gc3BlYy5taW5GaWx0ZXIgfHwgREVGQVVMVF9GSUxURVI7XG4gICAgICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHNwZWMubWFnRmlsdGVyIHx8IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgLy8gc2V0IG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMubWlwTWFwID0gc3BlYy5taXBNYXAgIT09IHVuZGVmaW5lZCA/IHNwZWMubWlwTWFwIDogREVGQVVMVF9NSVBNQVA7XG4gICAgICAgICAgICB0aGlzLmludmVydFkgPSBzcGVjLmludmVydFkgIT09IHVuZGVmaW5lZCA/IHNwZWMuaW52ZXJ0WSA6IERFRkFVTFRfSU5WRVJUX1k7XG4gICAgICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzcGVjLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCA/IHNwZWMucHJlbXVsdGlwbHlBbHBoYSA6IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEE7XG4gICAgICAgICAgICAvLyBzZXQgZm9ybWF0XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IHNwZWMuZm9ybWF0IHx8IERFRkFVTFRfRk9STUFUO1xuICAgICAgICAgICAgaWYgKERFUFRIX1RZUEVTW3RoaXMuZm9ybWF0XSAmJiAhV2ViR0xDb250ZXh0LmNoZWNrRXh0ZW5zaW9uKCdXRUJHTF9kZXB0aF90ZXh0dXJlJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgQ2Fubm90IGNyZWF0ZSBUZXh0dXJlMkQgb2YgZm9ybWF0IFxcYCR7dGhpcy5mb3JtYXR9XFxgIGFzIFxcYFdFQkdMX2RlcHRoX3RleHR1cmVcXGAgZXh0ZW5zaW9uIGlzIHVuc3VwcG9ydGVkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB0eXBlXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcGVjLnR5cGUgfHwgREVGQVVMVF9UWVBFO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ0ZMT0FUJyAmJiAhV2ViR0xDb250ZXh0LmNoZWNrRXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYENhbm5vdCBjcmVhdGUgVGV4dHVyZTJEIG9mIHR5cGUgXFxgRkxPQVRcXGAgYXMgXFxgT0VTX3RleHR1cmVfZmxvYXRcXGAgZXh0ZW5zaW9uIGlzIHVuc3VwcG9ydGVkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCB3aWxsIG5vdCBiZSByZXNvbHZlZCB5ZXQsIHNvIGRvbid0IGJ1ZmZlciBpbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYy5zcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgc2l6ZVxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5pc0NhbnZhc1R5cGUoc3BlYy5zcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhIGNhbnZhcyB0eXBlLCBkaW1lbnNpb25zIE1VU1QgYmUgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYy53aWR0aCAhPT0gJ251bWJlcicgfHwgc3BlYy53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnYHdpZHRoYCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYy5oZWlnaHQgIT09ICdudW1iZXInIHx8IHNwZWMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdgaGVpZ2h0YCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLm11c3RCZVBvd2VyT2ZUd28odGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVXRpbC5pc1Bvd2VyT2ZUd28oc3BlYy53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBgUGFyYW1ldGVycyByZXF1aXJlIGEgcG93ZXItb2YtdHdvIHRleHR1cmUsIHlldCBwcm92aWRlZCB3aWR0aCBvZiBcXGAke3NwZWMud2lkdGh9XFxgIGlzIG5vdCBhIHBvd2VyIG9mIHR3b2A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVV0aWwuaXNQb3dlck9mVHdvKHNwZWMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGBQYXJhbWV0ZXJzIHJlcXVpcmUgYSBwb3dlci1vZi10d28gdGV4dHVyZSwgeWV0IHByb3ZpZGVkIGhlaWdodCBvZiBcXGAke3NwZWMuaGVpZ2h0fVxcYCBpcyBub3QgYSBwb3dlciBvZiB0d29gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YShzcGVjLnNyYyB8fCBudWxsLCBzcGVjLndpZHRoLCBzcGVjLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSB0ZXh0dXJlIG9iamVjdCB0byB0aGUgcHJvdmlkZWQgdGV4dHVyZSB1bml0IGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBUaGUgdGV4dHVyZSB1bml0IGxvY2F0aW9uIGluZGV4LiBEZWZhdWx0cyB0byAwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlMkR9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYmluZChsb2NhdGlvbiA9IDApIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2NhdGlvbikgfHwgbG9jYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFRleHR1cmUgdW5pdCBsb2NhdGlvbiBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyBsb2NhdGlvbl0pO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZHMgdGhlIHRleHR1cmUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlMkR9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdW5iaW5kKCkge1xuICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGRhdGEgaW50byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlclZpZXd8bnVsbH0gZGF0YSAtIFRoZSBkYXRhIGFycmF5IHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZTJEfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlckRhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRleHR1cmUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBpbnZlcnQgeSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuaW52ZXJ0WSk7XG4gICAgICAgICAgICAvLyBwcmVtdWx0aXBseSBhbHBoYSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgYXJnXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ0ZMT0FUJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGVuc3VyZSB0eXBlIGNvcnJlc3BvbmRzIHRvIGRhdGFcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9CWVRFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX1NIT1JUJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0lOVCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnRkxPQVQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiAhVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEFycmF5QnVmZmVyVmlld2AsIGBJbWFnZURhdGFgLCBgSFRNTEltYWdlRWxlbWVudGAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEhUTUxDYW52YXNFbGVtZW50YCwgYEhUTUxWaWRlb0VsZW1lbnRgLCBvciBudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChVdGlsLmlzQ2FudmFzVHlwZShkYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIG1pcC1tYXAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIHRleHR1cmUgZGF0YVxuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIG1pcC1tYXAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAwLCAvLyBib3JkZXIsIG11c3QgYmUgMFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMudHlwZV0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbWlwIG1hcHNcbiAgICAgICAgICAgIGlmICh0aGlzLm1pcE1hcCkge1xuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIHBhcnRpYWwgZGF0YSBpbnRvIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyVmlld3xudWxsfSBkYXRhIC0gVGhlIGRhdGEgYXJyYXkgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geE9mZnNldCAtIFRoZSB4IG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5T2Zmc2V0IC0gVGhlIHkgb2Zmc2V0IGF0IHdoaWNoIHRvIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZTJEfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlclN1YkRhdGEoZGF0YSwgeE9mZnNldCA9IDAsIHlPZmZzZXQgPSAwLCB3aWR0aCA9IHVuZGVmaW5lZCwgaGVpZ2h0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBjYXN0IGFycmF5IGFyZ1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnVU5TSUdORURfU0hPUlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9JTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdGTE9BVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBlbnN1cmUgdHlwZSBjb3JyZXNwb25kcyB0byBkYXRhXG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnVU5TSUdORURfQllURScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgYFVpbnQ4QXJyYXlgIGRvZXMgbm90IG1hdGNoIHR5cGUgb2YgYFVOU0lHTkVEX0JZVEVgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgYFVpbnQxNkFycmF5YCBkb2VzIG5vdCBtYXRjaCB0eXBlIG9mIGBVTlNJR05FRF9TSE9SVGAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgYFVpbnQzMkFycmF5YCBkb2VzIG5vdCBtYXRjaCB0eXBlIG9mIGBVTlNJR05FRF9JTlRgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnRkxPQVQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdQcm92aWRlZCBhcmd1bWVudCBvZiB0eXBlIGBGbG9hdDMyQXJyYXlgIGRvZXMgbm90IG1hdGNoIHR5cGUgb2YgYEZMT0FUYCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiYgIVV0aWwuaXNDYW52YXNUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBgQXJyYXlgLCBgQXJyYXlCdWZmZXJgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BBcnJheUJ1ZmZlclZpZXdgLCBgSW1hZ2VEYXRhYCwgYEhUTUxJbWFnZUVsZW1lbnRgLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BIVE1MQ2FudmFzRWxlbWVudGAsIG9yIGBIVE1MVmlkZW9FbGVtZW50YCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIHRleHR1cmVcbiAgICAgICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgICAgICAgICAgICAwLCAvLyBtaXAtbWFwIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIHhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHlPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgd2lkdGggaXMgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCB3aWR0aCBvZiBcXGAke3dpZHRofVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCBoZWlnaHQgaXMgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgaGVpZ2h0IG9mIFxcYCR7aGVpZ2h0fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBhcmVuJ3Qgb3ZlcmZsb3dpbmcgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCArIHhPZmZzZXQgPiB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCB3aWR0aCBvZiBcXGAke3dpZHRofVxcYCBhbmQgeE9mZnNldCBvZiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAgXFxgJHt4T2Zmc2V0fVxcYCBvdmVyZmxvd3MgdGhlIHRleHR1cmUgd2lkdGggb2YgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxgJHt0aGlzLndpZHRofVxcYGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgKyB5T2Zmc2V0ID4gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIHdpZHRoIG9mIFxcYCR7aGVpZ2h0fVxcYCBhbmQgeE9mZnNldCBvZiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAgXFxgJHt5T2Zmc2V0fVxcYCBvdmVyZmxvd3MgdGhlIHRleHR1cmUgd2lkdGggb2YgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxgJHt0aGlzLmhlaWdodH1cXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgdGhlIHRleHR1cmUgZGF0YVxuICAgICAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIG1pcC1tYXAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgeE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgeU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLnR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIG1pcCBtYXBzXG4gICAgICAgICAgICBpZiAodGhpcy5taXBNYXApIHtcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuYmluZCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdGV4dHVyZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgYnkgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53cmFwIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciBib3RoIFMgYW5kIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndyYXBTIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciB0aGUgUyBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5maWx0ZXIgLSBUaGUgbWluIC8gbWFnIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1pbkZpbHRlciAtIFRoZSBtaW5pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1RleHR1cmUyRH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gYmluZCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgLy8gc2V0IHdyYXAgUyBwYXJhbWV0ZXJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHBhcmFtcy53cmFwUyB8fCBwYXJhbXMud3JhcDtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChXUkFQX01PREVTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBTID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsW3RoaXMud3JhcFNdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBgVGV4dHVyZSBwYXJhbWV0ZXIgXFxgJHtwYXJhbX1cXGAgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFxcYFRFWFRVUkVfV1JBUF9TXFxgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgd3JhcCBUIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXMud3JhcFQgfHwgcGFyYW1zLndyYXA7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoV1JBUF9NT0RFU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwVCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbFt0aGlzLndyYXBUXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRleHR1cmUgcGFyYW1ldGVyIFxcYCR7cGFyYW19XFxgIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBcXGBURVhUVVJFX1dSQVBfVFxcYGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IG1hZyBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtcy5tYWdGaWx0ZXIgfHwgcGFyYW1zLmZpbHRlcjtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChNQUdfRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsW3RoaXMubWFnRmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRleHR1cmUgcGFyYW1ldGVyIFxcYCR7cGFyYW19XFxgIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciAnVEVYVFVSRV9NQUdfRklMVEVSXFxgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbWluIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zLm1pbkZpbHRlciB8fCBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlwTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOT05fTUlQTUFQX01JTl9GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBncmFkZSB0byBtaXAtbWFwIG1pbiBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtICs9IERFRkFVTFRfTUlQTUFQX01JTl9GSUxURVJfU1VGRklYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChNSVBNQVBfTUlOX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkZpbHRlciA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW3RoaXMubWluRmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRleHR1cmUgcGFyYW1ldGVyIFxcYCR7cGFyYW19XFxgIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBcXGBURVhUVVJFX01JTl9GSUxURVJcXGBgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1JTl9GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbFt0aGlzLm1pbkZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRleHR1cmUgcGFyYW1ldGVyIFxcYCR7cGFyYW19XFxgIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBcXGBURVhUVVJFX01JTl9GSUxURVJcXGBgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemUgdGhlIHVuZGVybHlpbmcgdGV4dHVyZS4gVGhpcyBjbGVhcnMgdGhlIHRleHR1cmUgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlMkR9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8ICh3aWR0aCA8PSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCB3aWR0aCBvZiBcXGAke3dpZHRofVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJyB8fCAoaGVpZ2h0IDw9IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIGhlaWdodCBvZiBcXGAke2hlaWdodH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEobnVsbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTJEO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgV2ViR0xDb250ZXh0ID0gcmVxdWlyZSgnLi9XZWJHTENvbnRleHQnKTtcbiAgICBjb25zdCBBc3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvQXN5bmMnKTtcbiAgICBjb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyk7XG4gICAgY29uc3QgSW1hZ2VMb2FkZXIgPSByZXF1aXJlKCcuLi91dGlsL0ltYWdlTG9hZGVyJyk7XG5cbiAgICBjb25zdCBGQUNFUyA9IFtcbiAgICAgICAgJy14JywgJyt4JyxcbiAgICAgICAgJy15JywgJyt5JyxcbiAgICAgICAgJy16JywgJyt6J1xuICAgIF07XG4gICAgY29uc3QgRkFDRV9UQVJHRVRTID0ge1xuICAgICAgICAnK3onOiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aJyxcbiAgICAgICAgJy16JzogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWicsXG4gICAgICAgICcreCc6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gnLFxuICAgICAgICAnLXgnOiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YJyxcbiAgICAgICAgJyt5JzogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWScsXG4gICAgICAgICcteSc6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1knXG4gICAgfTtcbiAgICBjb25zdCBUQVJHRVRTID0ge1xuICAgICAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1o6IHRydWUsXG4gICAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWjogdHJ1ZSxcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YOiB0cnVlLFxuICAgICAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1g6IHRydWUsXG4gICAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWTogdHJ1ZSxcbiAgICAgICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBNQUdfRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBNSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IHRydWUsXG4gICAgICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9MSU5FQVI6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IE5PTl9NSVBNQVBfTUlOX0ZJTFRFUlMgPSB7XG4gICAgICAgIE5FQVJFU1Q6IHRydWUsXG4gICAgICAgIExJTkVBUjogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IE1JUE1BUF9NSU5fRklMVEVSUyA9IHtcbiAgICAgICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogdHJ1ZSxcbiAgICAgICAgTElORUFSX01JUE1BUF9ORUFSRVNUOiB0cnVlLFxuICAgICAgICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IHRydWUsXG4gICAgICAgIExJTkVBUl9NSVBNQVBfTElORUFSOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBXUkFQX01PREVTID0ge1xuICAgICAgICBSRVBFQVQ6IHRydWUsXG4gICAgICAgIE1JUlJPUkVEX1JFUEVBVDogdHJ1ZSxcbiAgICAgICAgQ0xBTVBfVE9fRURHRTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgRk9STUFUUyA9IHtcbiAgICAgICAgUkdCOiB0cnVlLFxuICAgICAgICBSR0JBOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfVFlQRSA9ICdVTlNJR05FRF9CWVRFJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCBmb3IgdGV4dHVyZXMuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9GT1JNQVQgPSAnUkdCQSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB3cmFwIG1vZGUgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfV1JBUCA9ICdDTEFNUF9UT19FREdFJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1pbiAvIG1hZyBmaWx0ZXIgZm9yIHRleHR1cmVzLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfRklMVEVSID0gJ0xJTkVBUic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3Igd2hldGhlciBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEEgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIHdoZXRoZXIgbWlwbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfTUlQTUFQID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvciB3aGV0aGVyIGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgY29uc3QgREVGQVVMVF9JTlZFUlRfWSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBtaXAtbWFwcGluZyBmaWx0ZXIgc3VmZml4LlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfTUlQTUFQX01JTl9GSUxURVJfU1VGRklYID0gJ19NSVBNQVBfTElORUFSJztcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY3ViZW1hcCBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAqIGl0IGRvZXMgbm90IG1lZXQgcmVxdWlyZW1lbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVDdWJlTWFwfSBjdWJlTWFwIC0gVGhlIGN1YmUgbWFwIHRleHR1cmUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrRGltZW5zaW9ucyhjdWJlTWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3ViZU1hcC53aWR0aCAhPT0gJ251bWJlcicgfHwgY3ViZU1hcC53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnYHdpZHRoYCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3ViZU1hcC5oZWlnaHQgIT09ICdudW1iZXInIHx8IGN1YmVNYXAuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93ICdgaGVpZ2h0YCBhcmd1bWVudCBpcyBtaXNzaW5nIG9yIGludmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdWJlTWFwLndpZHRoICE9PSBjdWJlTWFwLmhlaWdodCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Byb3ZpZGVkIGB3aWR0aGAgbXVzdCBiZSBlcXVhbCB0byBgaGVpZ2h0YCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWwubXVzdEJlUG93ZXJPZlR3byhjdWJlTWFwKSAmJiAhVXRpbC5pc1Bvd2VyT2ZUd28oY3ViZU1hcC53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IGBQYXJhbWV0ZXJzIHJlcXVpcmUgYSBwb3dlci1vZi10d28gdGV4dHVyZSwgeWV0IHByb3ZpZGVkIHNpemUgb2YgJHtjdWJlTWFwLndpZHRofSBpcyBub3QgYSBwb3dlciBvZiB0d29gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGxvYWQgYSBmYWNlIGZyb20gYSB1cmwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUN1YmVNYXB9IGN1YmVNYXAgLSBUaGUgY3ViZSBtYXAgdGV4dHVyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldCAtIFRoZSB0ZXh0dXJlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIHVybCB0byBsb2FkIHRoZSBmYWNlIGZyb20uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmFjZVVSTChjdWJlTWFwLCB0YXJnZXQsIHVybCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcHV0IGV4dGVuc2lvbiBoYW5kbGluZyBmb3IgYXJyYXlidWZmZXIgLyBpbWFnZSAvIHZpZGVvIGRpZmZlcmVudGlhdGlvblxuICAgICAgICAgICAgSW1hZ2VMb2FkZXIubG9hZCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogaW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IFV0aWwucmVzaXplQ2FudmFzKGN1YmVNYXAsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY3ViZU1hcC5idWZmZXJEYXRhKHRhcmdldCwgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBhIGZhY2UgZnJvbSBhIGNhbnZhcyB0eXBlIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQ3ViZU1hcH0gY3ViZU1hcCAtIFRoZSBjdWJlIG1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRleHR1cmUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyB0eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIFRoZSBsb2FkZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZEZhY2VDYW52YXMoY3ViZU1hcCwgdGFyZ2V0LCBjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IFV0aWwucmVzaXplQ2FudmFzKGN1YmVNYXAsIGNhbnZhcyk7XG4gICAgICAgICAgICBjdWJlTWFwLmJ1ZmZlckRhdGEodGFyZ2V0LCBjYW52YXMpO1xuICAgICAgICAgICAgZG9uZShudWxsKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gbG9hZCBhIGZhY2UgZnJvbSBhbiBhcnJheSB0eXBlIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQ3ViZU1hcH0gY3ViZU1hcCAtIFRoZSBjdWJlIG1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRleHR1cmUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhcnIgLSBUaGUgYXJyYXkgdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRmFjZUFycmF5KGN1YmVNYXAsIHRhcmdldCwgYXJyKSB7XG4gICAgICAgIGNoZWNrRGltZW5zaW9ucyhjdWJlTWFwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGN1YmVNYXAuYnVmZmVyRGF0YSh0YXJnZXQsIGFycik7XG4gICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUZXh0dXJlQ3ViZU1hcFxuICAgICAqIEBjbGFzc2Rlc2MgQSB0ZXh0dXJlIGNsYXNzIHRvIHJlcHJlc2VudCBhIGN1YmUgbWFwIHRleHR1cmUuXG4gICAgICovXG4gICAgY2xhc3MgVGV4dHVyZUN1YmVNYXAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBUZXh0dXJlQ3ViZU1hcCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHNwZWNpZmljYXRpb24gYXJndW1lbnRzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjLmZhY2VzIC0gVGhlIGZhY2VzIHRvIGJ1ZmZlciwgdW5kZXIga2V5cyAnK3gnLCAnK3knLCAnK3onLCAnLXgnLCAnLXknLCBhbmQgJy16Jy5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGZhY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBmYWNlcy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMud3JhcFQgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBUIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMubWFnRmlsdGVyIC0gVGhlIG1hZ25pZmljYXRpb24gZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5taXBNYXAgLSBXaGV0aGVyIG9yIG5vdCBtaXAtbWFwcGluZyBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHNwZWMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gc3BlYy5wcmVtdWx0aXBseUFscGhhIC0gV2hldGhlciBvciBub3QgYWxwaGEgcHJlbXVsdGlwbHlpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuZm9ybWF0IC0gVGhlIHRleHR1cmUgcGl4ZWwgZm9ybWF0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihzcGVjID0ge30sIGNhbGxiYWNrID0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IFdlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBnZXQgc3BlY2lmaWMgcGFyYW1zXG4gICAgICAgICAgICBzcGVjLndyYXBTID0gc3BlYy53cmFwUyB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLndyYXBUID0gc3BlYy53cmFwVCB8fCBzcGVjLndyYXA7XG4gICAgICAgICAgICBzcGVjLm1pbkZpbHRlciA9IHNwZWMubWluRmlsdGVyIHx8IHNwZWMuZmlsdGVyO1xuICAgICAgICAgICAgc3BlYy5tYWdGaWx0ZXIgPSBzcGVjLm1hZ0ZpbHRlciB8fCBzcGVjLmZpbHRlcjtcbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlIHBhcmFtc1xuICAgICAgICAgICAgdGhpcy53cmFwUyA9IFdSQVBfTU9ERVNbc3BlYy53cmFwU10gPyBzcGVjLndyYXBTIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgdGhpcy53cmFwVCA9IFdSQVBfTU9ERVNbc3BlYy53cmFwVF0gPyBzcGVjLndyYXBUIDogREVGQVVMVF9XUkFQO1xuICAgICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBNSU5fRklMVEVSU1tzcGVjLm1pbkZpbHRlcl0gPyBzcGVjLm1pbkZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgdGhpcy5tYWdGaWx0ZXIgPSBNQUdfRklMVEVSU1tzcGVjLm1hZ0ZpbHRlcl0gPyBzcGVjLm1hZ0ZpbHRlciA6IERFRkFVTFRfRklMVEVSO1xuICAgICAgICAgICAgLy8gc2V0IG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMubWlwTWFwID0gc3BlYy5taXBNYXAgIT09IHVuZGVmaW5lZCA/IHNwZWMubWlwTWFwIDogREVGQVVMVF9NSVBNQVA7XG4gICAgICAgICAgICB0aGlzLmludmVydFkgPSBzcGVjLmludmVydFkgIT09IHVuZGVmaW5lZCA/IHNwZWMuaW52ZXJ0WSA6IERFRkFVTFRfSU5WRVJUX1k7XG4gICAgICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzcGVjLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCA/IHNwZWMucHJlbXVsdGlwbHlBbHBoYSA6IERFRkFVTFRfUFJFTVVMVElQTFlfQUxQSEE7XG4gICAgICAgICAgICAvLyBzZXQgZm9ybWF0IGFuZCB0eXBlXG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IEZPUk1BVFNbc3BlYy5mb3JtYXRdID8gc3BlYy5mb3JtYXQgOiBERUZBVUxUX0ZPUk1BVDtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNwZWMudHlwZSB8fCBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnRkxPQVQnICYmICFXZWJHTENvbnRleHQuY2hlY2tFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGNyZWF0ZSBUZXh0dXJlMkQgb2YgdHlwZSBgRkxPQVRgIGFzIGBPRVNfdGV4dHVyZV9mbG9hdGAgZXh0ZW5zaW9uIGlzIHVuc3VwcG9ydGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBkaW1lbnNpb25zIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3BlYy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3BlYy5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBzZXQgYnVmZmVyZWQgZmFjZXNcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRGYWNlcyA9IFtdO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGN1YmUgbWFwIGJhc2VkIG9uIGlucHV0XG4gICAgICAgICAgICBpZiAoc3BlYy5mYWNlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgICAgICAgICAgICAgRkFDRVMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY2UgPSBzcGVjLmZhY2VzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gRkFDRV9UQVJHRVRTW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9hZCBiYXNlZCBvbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChsb2FkRmFjZVVSTCh0aGlzLCB0YXJnZXQsIGZhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzQ2FudmFzVHlwZShmYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRGYWNlQ2FudmFzKHRoaXMsIHRhcmdldCwgZmFjZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgLyBhcnJheWJ1ZmZlciBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGxvYWRGYWNlQXJyYXkodGhpcywgdGFyZ2V0LCBmYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBBc3luYy5wYXJhbGxlbCh0YXNrcywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVsbFxuICAgICAgICAgICAgICAgIGNoZWNrRGltZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgICAgICAgICBGQUNFUy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKEZBQ0VfVEFSR0VUU1tpZF0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHNldCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSB0ZXh0dXJlIG9iamVjdCB0byB0aGUgcHJvdmlkZWQgdGV4dHVyZSB1bml0IGxvY2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBUaGUgdGV4dHVyZSB1bml0IGxvY2F0aW9uIGluZGV4LiBEZWZhdWx0cyB0byAwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtUZXh0dXJlQ3ViZU1hcH0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kKGxvY2F0aW9uID0gMCkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvY2F0aW9uKSB8fCBsb2NhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGV4dHVyZSB1bml0IGxvY2F0aW9uIGlzIGludmFsaWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmluZCBjdWJlIG1hcCB0ZXh0dXJlXG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsWydURVhUVVJFJyArIGxvY2F0aW9uXSk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kcyB0aGUgdGV4dHVyZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1RleHR1cmVDdWJlTWFwfSAtIFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdW5iaW5kKCkge1xuICAgICAgICAgICAgLy8gdW5iaW5kIGN1YmUgbWFwIHRleHR1cmVcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGRhdGEgaW50byB0aGUgcmVzcGVjdGl2ZSBjdWJlIG1hcCBmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIGZhY2UgdGFyZ2V0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBkYXRhIC0gVGhlIGZhY2UgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZUN1YmVNYXB9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYnVmZmVyRGF0YSh0YXJnZXQsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghVEFSR0VUU1t0YXJnZXRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHRhcmdldFxcYCBvZiAke3RhcmdldH0gIGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRleHR1cmUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAvLyBpbnZlcnQgeSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuaW52ZXJ0WSk7XG4gICAgICAgICAgICAvLyBwcmVtdWx0aXBseSBhbHBoYSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgICAgIC8vIGNhc3QgYXJyYXkgYXJnXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdVTlNJR05FRF9TSE9SVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1VOU0lHTkVEX0lOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ0ZMT0FUJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGVuc3VyZSB0eXBlIGNvcnJlc3BvbmRzIHRvIGRhdGFcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdVTlNJR05FRF9CWVRFJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX1NIT1JUJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ1VOU0lHTkVEX0lOVCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnRkxPQVQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiAhVXRpbC5pc0NhbnZhc1R5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBBcnJheWAsIGBBcnJheUJ1ZmZlcmAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEFycmF5QnVmZmVyVmlld2AsIGBJbWFnZURhdGFgLCBgSFRNTEltYWdlRWxlbWVudGAsICcgK1xuICAgICAgICAgICAgICAgICAgICAnYEhUTUxDYW52YXNFbGVtZW50YCwgYEhUTUxWaWRlb0VsZW1lbnRgLCBvciBudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNDYW52YXNUeXBlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8gbWlwLW1hcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG4gICAgICAgICAgICAgICAgICAgIGdsW3RoaXMuZm9ybWF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbdGhpcy50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmFjayB0aGUgZmFjZSB0aGF0IHdhcyBidWZmZXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyZWRGYWNlcy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJlZEZhY2VzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGFsbCBmYWNlcyBidWZmZXJlZCwgZ2VuZXJhdGUgbWlwbWFwc1xuICAgICAgICAgICAgaWYgKHRoaXMubWlwTWFwICYmIHRoaXMuYnVmZmVyZWRGYWNlcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGdlbmVyYXRlIG1pcG1hcHMgaWYgYWxsIGZhY2VzIGFyZSBidWZmZXJlZFxuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5iaW5kIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBieSBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud3JhcFMgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIHRoZSBTIGRpbWVuc2lvbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53cmFwVCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgdGhlIFQgZGltZW5zaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWluRmlsdGVyIC0gVGhlIG1pbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tYWdGaWx0ZXIgLSBUaGUgbWFnbmlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VGV4dHVyZUN1YmVNYXB9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIGJpbmQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgIC8vIHNldCB3cmFwIFMgcGFyYW1ldGVyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSBwYXJhbXMud3JhcFMgfHwgcGFyYW1zLndyYXA7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoV1JBUF9NT0RFU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwUyA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbFt0aGlzLndyYXBTXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRleHR1cmUgcGFyYW1ldGVyIFxcYCR7cGFyYW19XFxgIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBcXGBURVhUVVJFX1dSQVBfU1xcYGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHdyYXAgVCBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW1zLndyYXBUIHx8IHBhcmFtcy53cmFwO1xuICAgICAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFdSQVBfTU9ERVNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xbdGhpcy53cmFwVF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9XUkFQX1RcXGBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBtYWcgZmlsdGVyIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXMubWFnRmlsdGVyIHx8IHBhcmFtcy5maWx0ZXI7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoTUFHX0ZJTFRFUlNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFnRmlsdGVyID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbFt0aGlzLm1hZ0ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgJ1RFWFRVUkVfTUFHX0ZJTFRFUlxcYGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IG1pbiBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtcy5taW5GaWx0ZXIgfHwgcGFyYW1zLmZpbHRlcjtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTk9OX01JUE1BUF9NSU5fRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZ3JhZGUgdG8gbWlwLW1hcCBtaW4gZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSArPSBERUZBVUxUX01JUE1BUF9NSU5fRklMVEVSX1NVRkZJWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoTUlQTUFQX01JTl9GSUxURVJTW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbFt0aGlzLm1pbkZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9NSU5fRklMVEVSXFxgYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNSU5fRklMVEVSU1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluRmlsdGVyID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbdGhpcy5taW5GaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGBUZXh0dXJlIHBhcmFtZXRlciBcXGAke3BhcmFtfVxcYCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgXFxgVEVYVFVSRV9NSU5fRklMVEVSXFxgYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuYmluZCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlQ3ViZU1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFdlYkdMQ29udGV4dCA9IHJlcXVpcmUoJy4vV2ViR0xDb250ZXh0Jyk7XG4gICAgY29uc3QgVmVydGV4UGFja2FnZSA9IHJlcXVpcmUoJy4vVmVydGV4UGFja2FnZScpO1xuXG4gICAgY29uc3QgTU9ERVMgPSB7XG4gICAgICAgIFBPSU5UUzogdHJ1ZSxcbiAgICAgICAgTElORVM6IHRydWUsXG4gICAgICAgIExJTkVfU1RSSVA6IHRydWUsXG4gICAgICAgIExJTkVfTE9PUDogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVTOiB0cnVlLFxuICAgICAgICBUUklBTkdMRV9TVFJJUDogdHJ1ZSxcbiAgICAgICAgVFJJQU5HTEVfRkFOOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBUWVBFUyA9IHtcbiAgICAgICAgQllURTogdHJ1ZSxcbiAgICAgICAgVU5TSUdORURfQllURTogdHJ1ZSxcbiAgICAgICAgU0hPUlQ6IHRydWUsXG4gICAgICAgIFVOU0lHTkVEX1NIT1JUOiB0cnVlLFxuICAgICAgICBGSVhFRDogdHJ1ZSxcbiAgICAgICAgRkxPQVQ6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IEJZVEVTX1BFUl9UWVBFID0ge1xuICAgICAgICBCWVRFOiAxLFxuICAgICAgICBVTlNJR05FRF9CWVRFOiAxLFxuICAgICAgICBTSE9SVDogMixcbiAgICAgICAgVU5TSUdORURfU0hPUlQ6IDIsXG4gICAgICAgIEZJWEVEOiA0LFxuICAgICAgICBGTE9BVDogNFxuICAgIH07XG4gICAgY29uc3QgU0laRVMgPSB7XG4gICAgICAgIDE6IHRydWUsXG4gICAgICAgIDI6IHRydWUsXG4gICAgICAgIDM6IHRydWUsXG4gICAgICAgIDQ6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgYXR0cmlidXRlIHBvaW50IGJ5dGUgb2Zmc2V0LlxuICAgICAqL1xuICAgIGNvbnN0IERFRkFVTFRfQllURV9PRkZTRVQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG1vZGUgKHByaW1pdGl2ZSB0eXBlKS5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX01PREUgPSAnVFJJQU5HTEVTJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGluZGV4IG9mZnNldCB0byByZW5kZXIgZnJvbS5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX0lOREVYX09GRlNFVCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb3VudCBvZiBpbmRpY2VzIHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICBjb25zdCBERUZBVUxUX0NPVU5UID0gMDtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBhdHRyaWJ1dGUgcG9pbnRlcnMgYW5kIGRldGVybWluZSB0aGUgYnl0ZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0ZVBvaW50ZXJzIC0gVGhlIGF0dHJpYnV0ZSBwb2ludGVyIG1hcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJ5dGUgc3RyaWRlIG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3RyaWRlKGF0dHJpYnV0ZVBvaW50ZXJzKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGF0dHJpYnV0ZSBwb2ludGVyIGFzc2lnbmVkIHRvIHRoaXMgYnVmZmVyLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIGZvciBzdHJpZGUsIHNldCB0byBkZWZhdWx0IG9mIDBcbiAgICAgICAgaWYgKGF0dHJpYnV0ZVBvaW50ZXJzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhCeXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGJ5dGVTaXplU3VtID0gMDtcbiAgICAgICAgbGV0IGJ5dGVTdHJpZGUgPSAwO1xuICAgICAgICBhdHRyaWJ1dGVQb2ludGVycy5mb3JFYWNoKHBvaW50ZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHBvaW50ZXIuYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwb2ludGVyLnNpemU7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcG9pbnRlci50eXBlO1xuICAgICAgICAgICAgLy8gdHJhY2sgdGhlIHN1bSBvZiBlYWNoIGF0dHJpYnV0ZSBzaXplXG4gICAgICAgICAgICBieXRlU2l6ZVN1bSArPSBzaXplICogQllURVNfUEVSX1RZUEVbdHlwZV07XG4gICAgICAgICAgICAvLyB0cmFjayB0aGUgbGFyZ2VzdCBvZmZzZXQgdG8gZGV0ZXJtaW5lIHRoZSBieXRlIHN0cmlkZSBvZiB0aGUgYnVmZmVyXG4gICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCA+IG1heEJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXhCeXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBieXRlU3RyaWRlID0gYnl0ZU9mZnNldCArIChzaXplICogQllURVNfUEVSX1RZUEVbdHlwZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG1heCBieXRlIG9mZnNldCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRoZSBzdW0gb2ZcbiAgICAgICAgLy8gdGhlIHNpemVzLiBJZiBzbyB0aGlzIGJ1ZmZlciBpcyBub3QgaW50ZXJsZWF2ZWQgYW5kIGRvZXMgbm90IG5lZWQgYVxuICAgICAgICAvLyBzdHJpZGUuXG4gICAgICAgIGlmIChtYXhCeXRlT2Zmc2V0ID49IGJ5dGVTaXplU3VtKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB0ZXN0IHdoYXQgc3RyaWRlID09PSAwIGRvZXMgZm9yIGFuIGludGVybGVhdmVkIGJ1ZmZlciBvZlxuICAgICAgICAgICAgLy8gbGVuZ3RoID09PSAxLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVTdHJpZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGF0dHJpYnV0ZSBwb2ludGVycyB0byBlbnN1cmUgdGhleSBhcmUgdmFsaWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVQb2ludGVycyAtIFRoZSBhdHRyaWJ1dGUgcG9pbnRlciBtYXAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB2YWxpZGF0ZWQgYXR0cmlidXRlIHBvaW50ZXIgbWFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVBvaW50ZXJzKGF0dHJpYnV0ZVBvaW50ZXJzKSB7XG4gICAgICAgIC8vIHBhcnNlIHBvaW50ZXJzIHRvIGVuc3VyZSB0aGV5IGFyZSB2YWxpZFxuICAgICAgICBjb25zdCBwb2ludGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlUG9pbnRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGtleSBpcyBhbiB2YWxpZCBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYEF0dHJpYnV0ZSBpbmRleCBcXGAke2tleX1cXGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGludGVnZXJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IGF0dHJpYnV0ZVBvaW50ZXJzW2tleV07XG4gICAgICAgICAgICBjb25zdCBzaXplID0gcG9pbnRlci5zaXplO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHBvaW50ZXIudHlwZTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBwb2ludGVyLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAvLyBjaGVjayBzaXplXG4gICAgICAgICAgICBpZiAoIVNJWkVTW3NpemVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dHJpYnV0ZSBwb2ludGVyIGBzaXplYCBwYXJhbWV0ZXIgaXMgaW52YWxpZCwgbXVzdCBiZSBvbmUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKFNJWkVTKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0eXBlXG4gICAgICAgICAgICBpZiAoIVRZUEVTW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dHJpYnV0ZSBwb2ludGVyIGB0eXBlYCBwYXJhbWV0ZXIgaXMgaW52YWxpZCwgbXVzdCBiZSBvbmUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKFRZUEVTKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVycy5zZXQoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogKGJ5dGVPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBieXRlT2Zmc2V0IDogREVGQVVMVF9CWVRFX09GRlNFVFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZlcnRleEJ1ZmZlclxuICAgICAqIEBjbGFzc2Rlc2MgQSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbGFzcyBWZXJ0ZXhCdWZmZXIge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYW4gVmVydGV4QnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxWZXJ0ZXhQYWNrYWdlfEZsb2F0MzJBcnJheXxBcnJheXxOdW1iZXJ9IGFyZyAtIFRoZSBidWZmZXIgb3IgbGVuZ3RoIG9mIHRoZSBidWZmZXIuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVQb2ludGVycyAtIFRoZSBhcnJheSBwb2ludGVyIG1hcCwgb3IgaW4gdGhlIGNhc2Ugb2YgYSB2ZXJ0ZXggcGFja2FnZSBhcmcsIHRoZSBvcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIGluZGljZXMgdG8gZHJhdy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGFyZywgYXR0cmlidXRlUG9pbnRlcnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gTU9ERVNbb3B0aW9ucy5tb2RlXSA/IG9wdGlvbnMubW9kZSA6IERFRkFVTFRfTU9ERTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY291bnQgOiBERUZBVUxUX0NPVU5UO1xuICAgICAgICAgICAgdGhpcy5pbmRleE9mZnNldCA9IChvcHRpb25zLmluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5pbmRleE9mZnNldCA6IERFRkFVTFRfSU5ERVhfT0ZGU0VUO1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGZpcnN0LCBzZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVyc1xuICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcuYnVmZmVyICYmIGFyZy5wb2ludGVycykge1xuICAgICAgICAgICAgICAgIC8vIFZlcnRleFBhY2thZ2UgYXJndW1lbnQsIHVzZSBpdHMgYXR0cmlidXRlIHBvaW50ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycyA9IGFyZy5wb2ludGVycztcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCBvcHRpb25zIGFyZyBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vIGF0dHJpYiBwb2ludGVycyBhcmdcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXR0cmlidXRlUG9pbnRlcnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcnMgPSBnZXRBdHRyaWJ1dGVQb2ludGVycyhhdHRyaWJ1dGVQb2ludGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGJ5dGUgc3RyaWRlXG4gICAgICAgICAgICB0aGlzLmJ5dGVTdHJpZGUgPSBnZXRTdHJpZGUodGhpcy5wb2ludGVycyk7XG4gICAgICAgICAgICAvLyB0aGVuIGJ1ZmZlciB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBWZXJ0ZXhQYWNrYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRleFBhY2thZ2UgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhKGFyZy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViR0xCdWZmZXIgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQXJndW1lbnQgb2YgdHlwZSBgV2ViR0xCdWZmZXJgIG11c3QgYmUgY29tcGxpbWVudGVkIHdpdGggYSBjb3JyZXNwb25kaW5nIGBvcHRpb25zLmJ5dGVMZW5ndGhgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gb3B0aW9ucy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IG9yIEFycmF5QnVmZmVyIG9yIG51bWJlciBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEoYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fG51bWJlcn0gYXJnIC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLCBvciBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJEYXRhKGFyZykge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGFyZ3VtZW50IGlzIHZhbGlkXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzdCBhcnJheSBpbnRvIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgIGFyZyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIShhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICAgICAhKEFycmF5QnVmZmVyLmlzVmlldyhhcmcpKSAmJlxuICAgICAgICAgICAgICAgICEoTnVtYmVyLmlzSW50ZWdlcihhcmcpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhcnJheWJ1ZmZlciBvciBhIG51bWVyaWMgc2l6ZVxuICAgICAgICAgICAgICAgIHRocm93ICdBcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYEFycmF5YCwgYEFycmF5QnVmZmVyYCwgYEFycmF5QnVmZmVyVmlld2AsIG9yIGBOdW1iZXJgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBieXRlIGxlbmd0aFxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGFyZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYXJnLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgYnVmZmVyIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidWZmZXIgdGhlIGRhdGFcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJnLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIHBhcnRpYWwgdmVydGV4IGRhdGEgdG8gdGhlIEdQVS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFycmF5IC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJTdWJEYXRhKGFycmF5LCBieXRlT2Zmc2V0ID0gREVGQVVMVF9CWVRFX09GRlNFVCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBidWZmZXIgZXhpc3RzXG4gICAgICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0J1ZmZlciBoYXMgbm90IHlldCBiZWVuIGFsbG9jYXRlZCwgYWxsb2NhdGUgd2l0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BidWZmZXJEYXRhYCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbnN1cmUgYXJndW1lbnQgaXMgdmFsaWRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICEoYXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGFycmF5KVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93ICdBcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYEFycmF5YCwgYEFycmF5QnVmZmVyYCwgJyArXG4gICAgICAgICAgICAgICAgICAgICdvciBgQXJyYXlCdWZmZXJWaWV3YCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IHdlIGFyZW4ndCBvdmVyZmxvd2luZyB0aGUgYnVmZmVyXG4gICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIGFycmF5LmJ5dGVMZW5ndGggPiB0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgQXJndW1lbnQgb2YgbGVuZ3RoICR7YXJyYXkuYnl0ZUxlbmd0aH0gYnl0ZXMgd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9mZnNldCBvZiAke2J5dGVPZmZzZXR9IGJ5dGVzIG92ZXJmbG93cyB0aGUgYnVmZmVyIGAgK1xuICAgICAgICAgICAgICAgICAgICBgbGVuZ3RoIG9mICR7dGhpcy5ieXRlTGVuZ3RofSBieXRlc2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ5dGVPZmZzZXQsIGFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVydGV4QnVmZmVyfSAtIFJldHVybnMgdGhlIHZlcnRleCBidWZmZXIgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBwb2ludGVyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2xbcG9pbnRlci50eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5ieXRlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBlbmFibGUgYXR0cmlidXRlIGluZGV4XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmRzIHRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHVuYmluZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIC8vIHVuYmluZCBidWZmZXJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBhdHRyaWJ1dGUgaW5kZXhcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSBib3VuZCBidWZmZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byAnZHJhd0FycmF5cycuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5tb2RlIC0gVGhlIGRyYXcgbW9kZSAvIHByaW1pdGl2ZSB0eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5pbmRleE9mZnNldCAtIFRoZSBpbmRleCBvZmZzZXQgaW50byB0aGUgZHJhd24gYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jb3VudCAtIFRoZSBudW1iZXIgb2YgaW5kaWNlcyB0byBkcmF3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZHJhdyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBnbFtvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gKG9wdGlvbnMuaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmluZGV4T2Zmc2V0IDogdGhpcy5pbmRleE9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gKG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNvdW50IDogdGhpcy5jb3VudDtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdBdHRlbXB0aW5nIHRvIGRyYXcgd2l0aCBhIGNvdW50IG9mIDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZHJhdyBlbGVtZW50c1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhtb2RlLCBpbmRleE9mZnNldCwgY291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZlcnRleEJ1ZmZlcjtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IENPTVBPTkVOVF9UWVBFID0gJ0ZMT0FUJztcbiAgICBjb25zdCBCWVRFU19QRVJfQ09NUE9ORU5UID0gNDtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgaW52YWxpZCBhdHRyaWJ1dGUgYXJndW1lbnRzLiBBIHZhbGlkIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgbGVuZ3RoID4gMCBrZXkgYnkgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGludC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBUaGUgbWFwIG9mIHZlcnRleCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSB2YWxpZCBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVNYXAoYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBnb29kQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlRmxvYXQoa2V5KTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQga2V5IGlzIGFuIHZhbGlkIGludGVnZXJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbmRleCkgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYEF0dHJpYnV0ZSBpbmRleCBcXGAke2tleX1cXGAgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsaWQgaW50ZWdlcmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBhdHRyaWJ1dGUgaXMgdmFsaWRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZlcnRpY2VzKSAmJiB2ZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGF0dHJpYnV0ZSBkYXRhIGFuZCBpbmRleFxuICAgICAgICAgICAgICAgIGdvb2RBdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGBFcnJvciBwYXJzaW5nIGF0dHJpYnV0ZSBvZiBpbmRleCBcXGAke2luZGV4fVxcYGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzb3J0IGF0dHJpYnV0ZXMgYXNjZW5kaW5nIGJ5IGluZGV4XG4gICAgICAgIGdvb2RBdHRyaWJ1dGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnb29kQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcG9uZW50J3MgYnl0ZSBzaXplLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCB0byBtZWFzdXJlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYnl0ZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50U2l6ZShjb21wb25lbnQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYXJyYXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdmVjdG9yXG4gICAgICAgIGlmIChjb21wb25lbnQueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyAxIGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gMiBjb21wb25lbnQgdmVjdG9yXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMyBjb21wb25lbnQgdmVjdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQudyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0IGNvbXBvbmVudCB2ZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpbmdsZSBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdHlwZSwgc2l6ZSwgYW5kIG9mZnNldCBmb3IgZWFjaCBhdHRyaWJ1dGUgaW4gdGhlIGF0dHJpYnV0ZSBhcnJheSBhbG9uZyB3aXRoIHRoZSBsZW5ndGggYW5kIHN0cmlkZSBvZiB0aGUgcGFja2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtWZXJ0ZXhQYWNrYWdlfSB2ZXJ0ZXhQYWNrYWdlIC0gVGhlIFZlcnRleFBhY2thZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGF0dHJpYnV0ZXMgVGhlIGFycmF5IG9mIHZlcnRleCBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJzQW5kU3RyaWRlKHZlcnRleFBhY2thZ2UsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IHNob3J0ZXN0QXJyYXkgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gZm9yIGVhY2ggYXR0cmlidXRlXG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCh2ZXJ0aWNlcyA9PiB7XG4gICAgICAgICAgICAvLyBzZXQgc2l6ZSB0byBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0Q29tcG9uZW50U2l6ZSh2ZXJ0aWNlcy5kYXRhWzBdKTtcbiAgICAgICAgICAgIC8vIGxlbmd0aCBvZiB0aGUgcGFja2FnZSB3aWxsIGJlIHRoZSBzaG9ydGVzdCBhdHRyaWJ1dGUgYXJyYXkgbGVuZ3RoXG4gICAgICAgICAgICBzaG9ydGVzdEFycmF5ID0gTWF0aC5taW4oc2hvcnRlc3RBcnJheSwgdmVydGljZXMuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gc3RvcmUgcG9pbnRlciB1bmRlciBpbmRleFxuICAgICAgICAgICAgdmVydGV4UGFja2FnZS5wb2ludGVycy5zZXQodmVydGljZXMuaW5kZXgsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDT01QT05FTlRfVFlQRSxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldCAqIEJZVEVTX1BFUl9DT01QT05FTlRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSBhdHRyaWJ1dGUgb2Zmc2V0XG4gICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCBzdHJpZGUgdG8gdG90YWwgb2Zmc2V0XG4gICAgICAgIHZlcnRleFBhY2thZ2Uuc3RyaWRlID0gb2Zmc2V0OyAvLyBub3QgaW4gYnl0ZXNcbiAgICAgICAgLy8gc2V0IGxlbmd0aCBvZiBwYWNrYWdlIHRvIHRoZSBzaG9ydGVzdCBhdHRyaWJ1dGUgYXJyYXkgbGVuZ3RoXG4gICAgICAgIHZlcnRleFBhY2thZ2UubGVuZ3RoID0gc2hvcnRlc3RBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSBhcnJheWJ1ZmZlciB3aXRoIGEgc2luZ2xlIGNvbXBvbmVudCBhdHRyaWJ1dGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBidWZmZXIgLSBUaGUgYXJyYXlidWZmZXIgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0ZXggYXR0cmlidXRlIGFycmF5IHRvIGNvcHkgZnJvbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIHRvIGNvcHkgZnJvbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB0byB0aGUgYXR0cmlidXRlLCBub3QgaW4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSAtIFRoZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlciwgbm90IGluIGJ5dGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldDFDb21wb25lbnRBdHRyKGJ1ZmZlciwgdmVydGljZXMsIGxlbmd0aCwgb2Zmc2V0LCBzdHJpZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciB0byB0aGUgcGFydGljdWxhciB2ZXJ0ZXhcbiAgICAgICAgICAgIGNvbnN0IGogPSBvZmZzZXQgKyAoc3RyaWRlICogaSk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqXSA9IHZlcnRleC54O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJ0ZXhbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqXSA9IHZlcnRleFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2pdID0gdmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgYXJyYXlidWZmZXIgd2l0aCBhIGRvdWJsZSBjb21wb25lbnQgYXR0cmlidXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gVGhlIGFycmF5YnVmZmVyIHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gdGhlIGF0dHJpYnV0ZSwgbm90IGluIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIG9mIHRoZSBidWZmZXIsIG5vdCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQyQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGluIHRoZSBidWZmZXIgdG8gdGhlIHBhcnRpY3VsYXIgdmVydGV4XG4gICAgICAgICAgICBjb25zdCBqID0gb2Zmc2V0ICsgKHN0cmlkZSAqIGkpO1xuICAgICAgICAgICAgYnVmZmVyW2pdID0gKHZlcnRleC54ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnggOiB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICBidWZmZXJbaisxXSA9ICh2ZXJ0ZXgueSAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC55IDogdmVydGV4WzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgYXJyYXlidWZmZXIgd2l0aCBhIHRyaXBsZSBjb21wb25lbnQgYXR0cmlidXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gVGhlIGFycmF5YnVmZmVyIHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBhcnJheSB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byBjb3B5IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gdGhlIGF0dHJpYnV0ZSwgbm90IGluIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIG9mIHRoZSBidWZmZXIsIG5vdCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQzQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGluIHRoZSBidWZmZXIgdG8gdGhlIHBhcnRpY3VsYXIgdmVydGV4XG4gICAgICAgICAgICBjb25zdCBqID0gb2Zmc2V0ICsgKHN0cmlkZSAqIGkpO1xuICAgICAgICAgICAgYnVmZmVyW2pdID0gKHZlcnRleC54ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnggOiB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICBidWZmZXJbaisxXSA9ICh2ZXJ0ZXgueSAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC55IDogdmVydGV4WzFdO1xuICAgICAgICAgICAgYnVmZmVyW2orMl0gPSAodmVydGV4LnogIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgueiA6IHZlcnRleFsyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIGFycmF5YnVmZmVyIHdpdGggYSBxdWFkcnVwbGUgY29tcG9uZW50IGF0dHJpYnV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGJ1ZmZlciAtIFRoZSBhcnJheWJ1ZmZlciB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgYXJyYXkgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gY29weSBmcm9tLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHRoZSBhdHRyaWJ1dGUsIG5vdCBpbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIC0gVGhlIHN0cmlkZSBvZiB0aGUgYnVmZmVyLCBub3QgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0NENvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcywgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBpbiB0aGUgYnVmZmVyIHRvIHRoZSBwYXJ0aWN1bGFyIHZlcnRleFxuICAgICAgICAgICAgY29uc3QgaiA9IG9mZnNldCArIChzdHJpZGUgKiBpKTtcbiAgICAgICAgICAgIGJ1ZmZlcltqXSA9ICh2ZXJ0ZXgueCAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC54IDogdmVydGV4WzBdO1xuICAgICAgICAgICAgYnVmZmVyW2orMV0gPSAodmVydGV4LnkgIT09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgueSA6IHZlcnRleFsxXTtcbiAgICAgICAgICAgIGJ1ZmZlcltqKzJdID0gKHZlcnRleC56ICE9PSB1bmRlZmluZWQpID8gdmVydGV4LnogOiB2ZXJ0ZXhbMl07XG4gICAgICAgICAgICBidWZmZXJbaiszXSA9ICh2ZXJ0ZXgudyAhPT0gdW5kZWZpbmVkKSA/IHZlcnRleC53IDogdmVydGV4WzNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZlcnRleFBhY2thZ2VcbiAgICAgKiBAY2xhc3NkZXNjIEEgdmVydGV4IHBhY2thZ2UgdG8gYXNzaXN0IGluIGludGVybGVhdmluZyB2ZXJ0ZXggZGF0YSBhbmQgYnVpbGRpbmcgdGhlIGFzc29jaWF0ZWQgdmVydGV4IGF0dHJpYnV0ZSBwb2ludGVycy5cbiAgICAgKi9cbiAgICBjbGFzcyBWZXJ0ZXhQYWNrYWdlIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGEgVmVydGV4UGFja2FnZSBvYmplY3QuXG4gICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIFRoZSBhdHRyaWJ1dGVzIHRvIGludGVybGVhdmUga2V5ZWQgYnkgaW5kZXguXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlkZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRhdGEgdG8gYmUgaW50ZXJsZWF2ZWQgaW5zaWRlIHRoZSBwYWNrYWdlLiBUaGlzIGNsZWFycyBhbnkgcHJldmlvdXNseSBleGlzdGluZyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIFRoZSBhdHRyaWJ1dGVzIHRvIGludGVybGVhdmVkLCBrZXllZCBieSBpbmRleC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7VmVydGV4UGFja2FnZX0gVGhlIHZlcnRleCBwYWNrYWdlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBiYWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlTWFwKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBwb2ludGVycyBhbmQgc3RyaWRlXG4gICAgICAgICAgICBzZXRQb2ludGVyc0FuZFN0cmlkZSh0aGlzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIC8vIHNldCBzaXplIG9mIGRhdGEgdmVjdG9yXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuc3RyaWRlOyAvLyBub3QgaW4gYnl0ZXNcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGggKiBzdHJpZGUpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggdmVydGV4IGF0dHJpYnV0ZSBhcnJheVxuICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKHZlcnRpY2VzID0+IHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnMuZ2V0KHZlcnRpY2VzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBvaW50ZXJzIG9mZnNldFxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBvaW50ZXIuYnl0ZU9mZnNldCAvIEJZVEVTX1BFUl9DT01QT05FTlQ7XG4gICAgICAgICAgICAgICAgLy8gY29weSB2ZXJ0ZXggZGF0YSBpbnRvIGFycmF5YnVmZmVyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb2ludGVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0MkNvbXBvbmVudEF0dHIoYnVmZmVyLCB2ZXJ0aWNlcy5kYXRhLCBsZW5ndGgsIG9mZnNldCwgc3RyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQzQ29tcG9uZW50QXR0cihidWZmZXIsIHZlcnRpY2VzLmRhdGEsIGxlbmd0aCwgb2Zmc2V0LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDRDb21wb25lbnRBdHRyKGJ1ZmZlciwgdmVydGljZXMuZGF0YSwgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDFDb21wb25lbnRBdHRyKGJ1ZmZlciwgdmVydGljZXMuZGF0YSwgbGVuZ3RoLCBvZmZzZXQsIHN0cmlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhQYWNrYWdlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgV2ViR0xDb250ZXh0ID0gcmVxdWlyZSgnLi9XZWJHTENvbnRleHQnKTtcblxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhlIHZpZXdwb3J0IHRvIHRoZSByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Vmlld3BvcnR9IHZpZXdwb3J0IC0gVGhlIHZpZXdwb3J0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb3ZlcnJpZGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb3ZlcnJpZGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgb3ZlcnJpZGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgb2Zmc2V0IG92ZXJyaWRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldCh2aWV3cG9ydCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBjb25zdCBnbCA9IHZpZXdwb3J0LmdsO1xuICAgICAgICB4ID0gKHggIT09IHVuZGVmaW5lZCkgPyB4IDogdmlld3BvcnQueDtcbiAgICAgICAgeSA9ICh5ICE9PSB1bmRlZmluZWQpID8geSA6IHZpZXdwb3J0Lnk7XG4gICAgICAgIHdpZHRoID0gKHdpZHRoICE9PSB1bmRlZmluZWQpID8gd2lkdGggOiB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gKGhlaWdodCAhPT0gdW5kZWZpbmVkKSA/IGhlaWdodCA6IHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFZpZXdwb3J0XG4gICAgICogQGNsYXNzZGVzYyBBIHZpZXdwb3J0IGNsYXNzIGZvciBtYW5hZ2luZyBXZWJHTCB2aWV3cG9ydHMuXG4gICAgICovXG4gICAgY2xhc3MgVmlld3BvcnQge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBWaWV3cG9ydCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHZpZXdwb3J0IHNwZWNpZmljYXRpb24gb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BlYy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVjLmhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Ioc3BlYyA9IHt9KSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gV2ViR0xDb250ZXh0LmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gc2V0IHNpemVcbiAgICAgICAgICAgIHRoaXMucmVzaXplKFxuICAgICAgICAgICAgICAgIHNwZWMud2lkdGggfHwgdGhpcy5nbC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgc3BlYy5oZWlnaHQgfHwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydHMgd2lkdGggYW5kIGhlaWdodC4gVGhpcyByZXNpemVzIHRoZSB1bmRlcmx5aW5nIGNhbnZhcyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemUod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJyB8fCB3aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHdpZHRoXFxgIG9mIFxcYCR7d2lkdGh9XFxgIGlzIGludmFsaWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYGhlaWdodFxcYCBvZiBcXGAke2hlaWdodH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2wuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmdsLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbi4gVGhlIHVuZGVybHlpbmcgY2FudmFzIGVsZW1lbnQgaXMgbm90IGFmZmVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb3ZlcnJpZGUuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG92ZXJyaWRlLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIG9mZnNldCBvdmVycmlkZS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgb2Zmc2V0IG92ZXJyaWRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtWaWV3cG9ydH0gLSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdXNoKHggPSAwLCB5ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IGBQcm92aWRlZCBcXGB4XFxgIG9mIFxcYCR7eH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYFByb3ZpZGVkIFxcYHlcXGAgb2YgXFxgJHt5fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8IHdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgd2lkdGhcXGAgb2YgXFxgJHt3aWR0aH1cXGAgaXMgaW52YWxpZGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgUHJvdmlkZWQgXFxgaGVpZ2h0XFxgIG9mIFxcYCR7aGVpZ2h0fVxcYCBpcyBpbnZhbGlkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB1c2ggb250byBzdGFja1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB2aWV3cG9ydFxuICAgICAgICAgICAgc2V0KHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9wcyBjdXJyZW50IHRoZSB2aWV3cG9ydCBvYmplY3QgYW5kIHNldHMgdGhlIHZpZXdwb3J0IGJlbmVhdGggaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwb3AoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVmlld3BvcnQgc3RhY2sgaXMgZW1wdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgc2V0KHRoaXMsIHRvcC54LCB0b3AueSwgdG9wLndpZHRoLCB0b3AuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgRVhURU5TSU9OUyA9IFtcbiAgICAgICAgLy8gcmF0aWZpZWRcbiAgICAgICAgJ09FU190ZXh0dXJlX2Zsb2F0JyxcbiAgICAgICAgJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLFxuICAgICAgICAnV0VCR0xfbG9zZV9jb250ZXh0JyxcbiAgICAgICAgJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycsXG4gICAgICAgICdPRVNfdmVydGV4X2FycmF5X29iamVjdCcsXG4gICAgICAgICdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyxcbiAgICAgICAgJ1dFQkdMX2RlYnVnX3NoYWRlcnMnLFxuICAgICAgICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnLFxuICAgICAgICAnV0VCR0xfZGVwdGhfdGV4dHVyZScsXG4gICAgICAgICdPRVNfZWxlbWVudF9pbmRleF91aW50JyxcbiAgICAgICAgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycsXG4gICAgICAgICdFWFRfZnJhZ19kZXB0aCcsXG4gICAgICAgICdXRUJHTF9kcmF3X2J1ZmZlcnMnLFxuICAgICAgICAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsXG4gICAgICAgICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInLFxuICAgICAgICAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLFxuICAgICAgICAnRVhUX2JsZW5kX21pbm1heCcsXG4gICAgICAgICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyxcbiAgICAgICAgLy8gY29tbXVuaXR5XG4gICAgICAgICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjJyxcbiAgICAgICAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycsXG4gICAgICAgICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnLFxuICAgICAgICAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyxcbiAgICAgICAgJ0VYVF9zUkdCJyxcbiAgICAgICAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyxcbiAgICAgICAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScsXG4gICAgICAgICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0J1xuICAgIF07XG5cbiAgICBjb25zdCBfY29udGV4dHMgPSBuZXcgTWFwKCk7XG5cbiAgICBsZXQgX2JvdW5kQ29udGV4dCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIHJmYzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudCBVVUlELlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gVGhlIFVVSUQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2UgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYyA9PT0gJ3gnKSA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIHJlcGxhY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBIVE1MQ2FudmFzRWxlbWVudCBlbGVtZW50LiBJZiB0aGVyZSBpcyBubyBpZCwgaXQgZ2VuZXJhdGVzIG9uZSBhbmQgYXBwZW5kcyBpdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIENhbnZhcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBDYW52YXMgaWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElkKGNhbnZhcykge1xuICAgICAgICBpZiAoIWNhbnZhcy5pZCkge1xuICAgICAgICAgICAgY2FudmFzLmlkID0gZ2V0VVVJRCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENhbnZhcyBlbGVtZW50IG9iamVjdCBmcm9tIGVpdGhlciBhbiBleGlzdGluZyBvYmplY3QsIG9yIGlkZW50aWZpY2F0aW9uIHN0cmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZCBvciBzZWxlY3RvciBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYW52YXMoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFyZykgfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcmV0cmlldmUgYSB3cmFwcGVkIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGhlIGNvbnRleHQgdW5kZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZXh0IHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKF9ib3VuZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbGFzdCBib3VuZCBjb250ZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9ib3VuZENvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoYXJnKTtcbiAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHRzLmdldChnZXRJZChjYW52YXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyBib3VuZCBjb250ZXh0IG9yIGFyZ3VtZW50XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGtub3duIGV4dGVuc2lvbnMgZm9yIGEgcHJvdmlkZWQgV2ViR0xSZW5kZXJpbmdDb250ZXh0LiBTdG9yZXMgdGhlIHJlc3VsdHMgaW4gdGhlIGNvbnRleHQgd3JhcHBlciBmb3IgbGF0ZXIgcXVlcmllcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRXcmFwcGVyIC0gVGhlIGNvbnRleHQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9ucyhjb250ZXh0V3JhcHBlcikge1xuICAgICAgICBjb25zdCBnbCA9IGNvbnRleHRXcmFwcGVyLmdsO1xuICAgICAgICBFWFRFTlNJT05TLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgY29udGV4dFdyYXBwZXIuZXh0ZW5zaW9ucy5zZXQoaWQsIGdsLmdldEV4dGVuc2lvbihpZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBjcmVhdGUgYSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgYW5kIGxvYWQgYWxsIGV4dGVuc2lvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IC0gVGhlIENhbnZhcyBlbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGhlIGNvbnRleHQgdW5kZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9fSBvcHRpb25zIC0gUGFyYW1ldGVycyB0byB0aGUgd2ViZ2wgY29udGV4dCwgb25seSB1c2VkIGR1cmluZyBpbnN0YW50aWF0aW9uLiBPcHRpb25hbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRleHQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0V3JhcHBlcihjYW52YXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyk7XG4gICAgICAgIC8vIHdyYXAgY29udGV4dFxuICAgICAgICBjb25zdCBjb250ZXh0V3JhcHBlciA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRJZChjYW52YXMpLFxuICAgICAgICAgICAgZ2w6IGdsLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIGxvYWQgV2ViR0wgZXh0ZW5zaW9uc1xuICAgICAgICBsb2FkRXh0ZW5zaW9ucyhjb250ZXh0V3JhcHBlcik7XG4gICAgICAgIC8vIGFkZCBjb250ZXh0IHdyYXBwZXIgdG8gbWFwXG4gICAgICAgIF9jb250ZXh0cy5zZXQoZ2V0SWQoY2FudmFzKSwgY29udGV4dFdyYXBwZXIpO1xuICAgICAgICAvLyBiaW5kIHRoZSBjb250ZXh0XG4gICAgICAgIF9ib3VuZENvbnRleHQgPSBjb250ZXh0V3JhcHBlcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRXcmFwcGVyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW4gZXhpc3RpbmcgV2ViR0wgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGFuZCBiaW5kcyBpdC4gV2hpbGUgYm91bmQsIHRoZSBhY3RpdmUgY29udGV4dCB3aWxsIGJlIHVzZWQgaW1wbGljaXRseSBieSBhbnkgaW5zdGFudGlhdGVkIGBlc3BlcmAgY29uc3RydWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dlYkdMQ29udGV4dH0gVGhlIG5hbWVzcGFjZSwgdXNlZCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBfYm91bmRDb250ZXh0ID0gd3JhcHBlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGV4aXN0cyBmb3IgcHJvdmlkZWQgYXJndW1lbnQgJyR7YXJnfSdgO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW4gZXhpc3RpbmcgV2ViR0wgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50LiBJZiBubyBjb250ZXh0IGV4aXN0cywgb25lIGlzIGNyZWF0ZWQuXG4gICAgICAgICAqIER1cmluZyBjcmVhdGlvbiBhdHRlbXB0cyB0byBsb2FkIGFsbCBleHRlbnNpb25zIGZvdW5kIGF0OiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zLy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBhcmFtZXRlcnMgdG8gdGhlIHdlYmdsIGNvbnRleHQsIG9ubHkgdXNlZCBkdXJpbmcgaW5zdGFudGlhdGlvbi4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGFyZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IGdldENvbnRleHRXcmFwcGVyKGFyZyk7XG4gICAgICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBuYXRpdmUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlci5nbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdldCBjYW52YXMgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGFyZyk7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBvciBjcmVhdGUgY29udGV4dFxuICAgICAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgY29udGV4dFxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRleHRXcmFwcGVyKGNhbnZhcywgb3B0aW9ucykuZ2w7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgV2ViR0wgY29udGV4dCBvYmplY3QgZm9yIHRoZSBwcm92aWRlZCBvciBjdXJyZW50bHkgYm91bmQgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8U3RyaW5nfSBhcmcgLSBUaGUgQ2FudmFzIG9iamVjdCBvciBDYW52YXMgaWRlbnRpZmljYXRpb24gc3RyaW5nLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9fSBvcHRpb25zIC0gUGFyYW1ldGVycyB0byB0aGUgd2ViZ2wgY29udGV4dCwgb25seSB1c2VkIGR1cmluZyBpbnN0YW50aWF0aW9uLiBPcHRpb25hbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgX2NvbnRleHRzLmRlbGV0ZSh3cmFwcGVyLmlkKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaWYgY3VycmVudGx5IGJvdW5kXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgPT09IF9ib3VuZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2JvdW5kQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHN1cHBvcnRlZCBleHRlbnNpb25zIGZvciB0aGUgcHJvdmlkZWQgb3IgY3VycmVudGx5IGJvdW5kIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fFN0cmluZ30gYXJnIC0gVGhlIENhbnZhcyBvYmplY3Qgb3IgQ2FudmFzIGlkZW50aWZpY2F0aW9uIHN0cmluZy4gT3B0aW9uYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBbGwgc3VwcG9ydGVkIGV4dGVuc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdXBwb3J0ZWRFeHRlbnNpb25zOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb25zID0gd3JhcHBlci5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBgTm8gY29udGV4dCBpcyBjdXJyZW50bHkgYm91bmQgb3IgY291bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgYXJnfWA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHVuc3VwcG9ydGVkIGV4dGVuc2lvbnMgZm9yIHRoZSBwcm92aWRlZCBvciBjdXJyZW50bHkgYm91bmQgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8U3RyaW5nfSBhcmcgLSBUaGUgQ2FudmFzIG9iamVjdCBvciBDYW52YXMgaWRlbnRpZmljYXRpb24gc3RyaW5nLiBPcHRpb25hbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFsbCB1bnN1cHBvcnRlZCBleHRlbnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdW5zdXBwb3J0ZWRFeHRlbnNpb25zOiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBnZXRDb250ZXh0V3JhcHBlcihhcmcpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb25zID0gd3JhcHBlci5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc3VwcG9ydGVkID0gW107XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKChleHRlbnNpb24sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuc3VwcG9ydGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgYE5vIGNvbnRleHQgaXMgY3VycmVudGx5IGJvdW5kIG9yIGNvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGFyZ31gO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgYW4gZXh0ZW5zaW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQgZm9yIHRoZSBwcm92aWRlZCBvciBjdXJyZW50bHkgYm91bmQgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8U3RyaW5nfSBhcmcgLSBUaGUgQ2FudmFzIG9iamVjdCBvciBDYW52YXMgaWRlbnRpZmljYXRpb24gc3RyaW5nLiBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV4dGVuc2lvbiAtIFRoZSBleHRlbnNpb24gbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGV4dGVuc2lvbiBoYXMgYmVlbiBsb2FkZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tFeHRlbnNpb246IGZ1bmN0aW9uKGFyZywgZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbm8gY2FudmFzIGFyZyBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGFyZztcbiAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHdyYXBwZXIuZXh0ZW5zaW9ucztcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoZXh0ZW5zaW9uKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGBObyBjb250ZXh0IGlzIGN1cnJlbnRseSBib3VuZCBvciBjb3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBhcmd9YDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBleHRlbnNpb24gaWYgaXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmb3IgdGhlIHByb3ZpZGVkIG9yIGN1cnJlbnRseSBib3VuZCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxTdHJpbmd9IGFyZyAtIFRoZSBDYW52YXMgb2JqZWN0IG9yIENhbnZhcyBpZGVudGlmaWNhdGlvbiBzdHJpbmcuIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgZXh0ZW5zaW9uIGhhcyBiZWVuIGxvYWRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnNpb246IGZ1bmN0aW9uKGFyZywgZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbm8gY2FudmFzIGFyZyBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGFyZztcbiAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZ2V0Q29udGV4dFdyYXBwZXIoYXJnKTtcbiAgICAgICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHdyYXBwZXIuZXh0ZW5zaW9ucztcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoZXh0ZW5zaW9uKSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgYE5vIGNvbnRleHQgaXMgY3VycmVudGx5IGJvdW5kIG9yIGNvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGFyZ31gO1xuICAgICAgICB9XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgSW5kZXhCdWZmZXI6IHJlcXVpcmUoJy4vY29yZS9JbmRleEJ1ZmZlcicpLFxyXG4gICAgICAgIFJlbmRlcmFibGU6IHJlcXVpcmUoJy4vY29yZS9SZW5kZXJhYmxlJyksXHJcbiAgICAgICAgUmVuZGVyVGFyZ2V0OiByZXF1aXJlKCcuL2NvcmUvUmVuZGVyVGFyZ2V0JyksXHJcbiAgICAgICAgU2hhZGVyOiByZXF1aXJlKCcuL2NvcmUvU2hhZGVyJyksXHJcbiAgICAgICAgVGV4dHVyZTJEOiByZXF1aXJlKCcuL2NvcmUvVGV4dHVyZTJEJyksXHJcbiAgICAgICAgQ29sb3JUZXh0dXJlMkQ6IHJlcXVpcmUoJy4vY29yZS9Db2xvclRleHR1cmUyRCcpLFxyXG4gICAgICAgIERlcHRoVGV4dHVyZTJEOiByZXF1aXJlKCcuL2NvcmUvRGVwdGhUZXh0dXJlMkQnKSxcclxuICAgICAgICBUZXh0dXJlQ3ViZU1hcDogcmVxdWlyZSgnLi9jb3JlL1RleHR1cmVDdWJlTWFwJyksXHJcbiAgICAgICAgVmVydGV4QnVmZmVyOiByZXF1aXJlKCcuL2NvcmUvVmVydGV4QnVmZmVyJyksXHJcbiAgICAgICAgVmVydGV4UGFja2FnZTogcmVxdWlyZSgnLi9jb3JlL1ZlcnRleFBhY2thZ2UnKSxcclxuICAgICAgICBWaWV3cG9ydDogcmVxdWlyZSgnLi9jb3JlL1ZpZXdwb3J0JyksXHJcbiAgICAgICAgV2ViR0xDb250ZXh0OiByZXF1aXJlKCcuL2NvcmUvV2ViR0xDb250ZXh0JylcclxuICAgIH07XHJcblxyXG59KCkpO1xyXG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvcihhcmcpIHtcbiAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBpIDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBrZXlzW2ldIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgY29tcGxldGVkID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgICAgY29tcGxldGVkLS07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBudWxsICYmIGNvbXBsZXRlZCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYga2V5IGlzIG51bGwgaW4gY2FzZSBpdGVyYXRvciBpc24ndCBleGhhdXN0ZWQgYW5kIGRvbmVcbiAgICAgICAgICAgICAgICAvLyB3YXMgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVyID0gZ2V0SXRlcmF0b3Iob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKChrZXkgPSBpdGVyKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXksIGRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wbGV0ZWQgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgYSBzZXQgb2YgZnVuY3Rpb25zIGFzeW5jaHJvbm91c2x5LCBvbmNlIGFsbCBoYXZlIGJlZW5cbiAgICAgICAgICogY29tcGxldGVkLCBleGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi4gSm9icyBtYXkgYmUgcGFzc2VkXG4gICAgICAgICAqIGFzIGFuIGFycmF5IG9yIG9iamVjdC4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRoZVxuICAgICAgICAgKiByZXN1bHRzIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgdGFza3MuIEFsbCB0YXNrcyBtdXN0IGhhdmUgYWNjZXB0XG4gICAgICAgICAqIGFuZCBleGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdXBvbiBjb21wbGV0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdGFza3MgLSBUaGUgc2V0IG9mIGZ1bmN0aW9ucyB0byBleGVjdXRlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB1cG9uIGNvbXBsZXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbGxlbDogZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IEFycmF5LmlzQXJyYXkodGFza3MpID8gW10gOiB7fTtcbiAgICAgICAgICAgIGVhY2godGFza3MsIGZ1bmN0aW9uKHRhc2ssIGtleSwgZG9uZSkge1xuICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYW4gR0VUIHJlcXVlc3QgY3JlYXRlIGFuIEltYWdlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgWEhSIG9wdGlvbnMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFRoZSBVUkwgZm9yIHRoZSByZXNvdXJjZS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyb3NzT3JpZ2luIC0gRW5hYmxlIGNyb3NzLW9yaWdpbiByZXF1ZXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnN1Y2Nlc3MgLSBUaGUgc3VjY2VzcyBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lcnJvciAtIFRoZSBlcnJvciBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoaW1hZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gYFVuYWJsZSB0byBsb2FkIGltYWdlIGZyb20gVVJMOiBcXGAke2V2ZW50LnBhdGhbMF0uY3VycmVudFNyYyB9XFxgYDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gPyAnYW5vbnltb3VzJyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IG9wdGlvbnMudXJsO1xuICAgICAgICB9XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFV0aWwgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgb25lIG9mIHRoZSBXZWJHTCBgdGV4SW1hZ2UyRGAgb3ZlcnJpZGRlblxuICAgICAqIGNhbnZhcyB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gVGhlIGFyZ3VtZW50IHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sfSAtIFdoZXRoZXIgb3Igbm90IGl0IGlzIGEgY2FudmFzIHR5cGUuXG4gICAgICovXG4gICAgVXRpbC5pc0NhbnZhc1R5cGUgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fFxuICAgICAgICAgICAgYXJnIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgICAgICAgYXJnIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgICAgICAgIGFyZyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dHVyZSBNVVNUIGJlIGEgcG93ZXItb2YtdHdvLiBPdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgdGV4dHVyZSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2x9IC0gV2hldGhlciBvciBub3QgdGhlIHRleHR1cmUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICAgKi9cbiAgICBVdGlsLm11c3RCZVBvd2VyT2ZUd28gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0bzpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9UdXRvcmlhbC9Vc2luZ190ZXh0dXJlc19pbl9XZWJHTCNOb25fcG93ZXItb2YtdHdvX3RleHR1cmVzXG4gICAgICAgIC8vIE4tUE9UIHRleHR1cmVzIGNhbm5vdCBiZSB1c2VkIHdpdGggbWlwbWFwcGluZyBhbmQgdGhleSBtdXN0IG5vdCBcIlJFUEVBVFwiXG4gICAgICAgIHJldHVybiBzcGVjLm1pcE1hcCB8fFxuICAgICAgICAgICAgc3BlYy53cmFwUyA9PT0gJ1JFUEVBVCcgfHxcbiAgICAgICAgICAgIHNwZWMud3JhcFMgPT09ICdNSVJST1JFRF9SRVBFQVQnIHx8XG4gICAgICAgICAgICBzcGVjLndyYXBUID09PSAnUkVQRUFUJyB8fFxuICAgICAgICAgICAgc3BlYy53cmFwVCA9PT0gJ01JUlJPUkVEX1JFUEVBVCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgaW50ZWdlciBpcyBhIHBvd2VyIG9mIHR3by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d28uXG4gICAgICovXG4gICAgVXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgcmV0dXJuIChudW0gIT09IDApID8gKG51bSAmIChudW0gLSAxKSkgPT09IDAgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBmb3IgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBFeC5cbiAgICAgKlxuICAgICAqICAgICAyMDAgLT4gMjU2XG4gICAgICogICAgIDI1NiAtPiAyNTZcbiAgICAgKiAgICAgMjU3IC0+IDUxMlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gbW9kaWZ5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIE5leHQgaGlnaGVzdCBwb3dlciBvZiB0d28uXG4gICAgICovXG4gICAgVXRpbC5uZXh0SGlnaGVzdFBvd2VyT2ZUd28gPSBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgaWYgKG51bSAhPT0gMCkge1xuICAgICAgICAgICAgbnVtID0gbnVtLTE7XG4gICAgICAgIH1cbiAgICAgICAgbnVtIHw9IG51bSA+PiAxO1xuICAgICAgICBudW0gfD0gbnVtID4+IDI7XG4gICAgICAgIG51bSB8PSBudW0gPj4gNDtcbiAgICAgICAgbnVtIHw9IG51bSA+PiA4O1xuICAgICAgICBudW0gfD0gbnVtID4+IDE2O1xuICAgICAgICByZXR1cm4gbnVtICsgMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRleHR1cmUgbXVzdCBiZSBhIFBPVCwgcmVzaXplcyBhbmQgcmV0dXJucyB0aGUgaW1hZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIC0gVGhlIHRleHR1cmUgc3BlY2lmaWNhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWcgLSBUaGUgaW1hZ2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gLSBUaGUgb3JpZ2luYWwgaW1hZ2UsIG9yIHRoZSByZXNpemVkIGNhbnZhcyBlbGVtZW50LlxuICAgICAqL1xuICAgIFV0aWwucmVzaXplQ2FudmFzID0gZnVuY3Rpb24oc3BlYywgaW1nKSB7XG4gICAgICAgIGlmICghVXRpbC5tdXN0QmVQb3dlck9mVHdvKHNwZWMpIHx8XG4gICAgICAgICAgICAoVXRpbC5pc1Bvd2VyT2ZUd28oaW1nLndpZHRoKSAmJiBVdGlsLmlzUG93ZXJPZlR3byhpbWcuaGVpZ2h0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IGNhbnZhcyBlbGVtZW50XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBVdGlsLm5leHRIaWdoZXN0UG93ZXJPZlR3byhpbWcud2lkdGgpO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gVXRpbC5uZXh0SGlnaGVzdFBvd2VyT2ZUd28oaW1nLmhlaWdodCk7XG4gICAgICAgIC8vIGNvcHkgdGhlIGltYWdlIGNvbnRlbnRzIHRvIHRoZSBjYW52YXNcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVXRpbDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhbiBYTUxIdHRwUmVxdWVzdCBHRVQgcmVxdWVzdCB0byB0aGUgc3VwcGxpZWQgdXJsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBYSFIgb3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXJsIC0gVGhlIFVSTCBmb3IgdGhlIHJlc291cmNlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3Jvc3NPcmlnaW4gLSBFbmFibGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3QuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc3VjY2VzcyAtIFRoZSBzdWNjZXNzIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmVycm9yIC0gVGhlIGVycm9yIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnJlc3BvbnNlVHlwZSAtIFRoZSByZXNwb25zZVR5cGUgb2YgdGhlIFhIUi5cbiAgICAgICAgICovXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIG9wdGlvbnMudXJsLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yKGBHRVQgJHtyZXF1ZXN0LnJlc3BvbnNlVVJMfSAke3JlcXVlc3Quc3RhdHVzfSAoJHtyZXF1ZXN0LnN0YXR1c1RleHR9KWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy5jcm9zc09yaWdpbiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxufSgpKTtcbiIsInZhciBqc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBvcHRzID0geyBjbXA6IG9wdHMgfTtcbiAgICB2YXIgc3BhY2UgPSBvcHRzLnNwYWNlIHx8ICcnO1xuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSBzcGFjZSA9IEFycmF5KHNwYWNlKzEpLmpvaW4oJyAnKTtcbiAgICB2YXIgY3ljbGVzID0gKHR5cGVvZiBvcHRzLmN5Y2xlcyA9PT0gJ2Jvb2xlYW4nKSA/IG9wdHMuY3ljbGVzIDogZmFsc2U7XG4gICAgdmFyIHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKHBhcmVudCwga2V5LCBub2RlLCBsZXZlbCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc3BhY2UgPyAoJ1xcbicgKyBuZXcgQXJyYXkobGV2ZWwgKyAxKS5qb2luKHNwYWNlKSkgOiAnJztcbiAgICAgICAgdmFyIGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudG9KU09OICYmIHR5cGVvZiBub2RlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudG9KU09OKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0cmluZ2lmeShub2RlLCBpLCBub2RlW2ldLCBsZXZlbCsxKSB8fCBqc29uLnN0cmluZ2lmeShudWxsKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjeWNsZXMpIHJldHVybiBqc29uLnN0cmluZ2lmeSgnX19jeWNsZV9fJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBzZWVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhub2RlKS5zb3J0KGNtcCAmJiBjbXAobm9kZSkpO1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyaW5naWZ5KG5vZGUsIGtleSwgbm9kZVtrZXldLCBsZXZlbCsxKTtcblxuICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXG4gICAgICAgICAgICAgICAgICAgICsgY29sb25TZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBrZXlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9KSh7ICcnOiBvYmogfSwgJycsIG9iaiwgMCk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcbiIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbiIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcbiIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjE1LjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIHV0aWxzX2hvb2tzX19ob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAvLyBldmVuIGlmIGl0cyBub3Qgb3duIHByb3BlcnR5IEknZCBzdGlsbCBjYWxsIGl0IG5vbi1lbXB0eVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfc2V0X19zZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccyspK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRocztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml0c19tb250aF9faGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy90aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRheV9vZl93ZWVrX19oYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIG9yZGluYWxQYXJzZTogZGVmYXVsdE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgYXMgaWYgdGhlcmUgaXMgbm8gYmFzZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdwYXJlbnRMb2NhbGVVbmRlZmluZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGVjaWZpZWQgcGFyZW50TG9jYWxlIGlzIG5vdCBkZWZpbmVkIHlldC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvcGFyZW50LWxvY2FsZS8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcikgfHwgW10pO1xuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG5cbiAgICAgICAgICAgIGlmICh0Wm9uZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKGMuX2EpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC0pPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24gLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIGdldF9zZXRfX3NldChtb20sICdEYXRlJywgZ2V0X3NldF9fZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXRfc2V0X19nZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JPSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICAvLyBIb3Vyc1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBpc29fc3RyaW5nX190b0lTT1N0cmluZygpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xNS4xJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICB1dGlsc19ob29rc19faG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVJblpvbmU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICB1dGlsc19ob29rc19faG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJ0aWFsU29ydDtcblxuLy8gRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG06XG4vLyBSZWFycmFuZ2UgaXRlbXMgc28gdGhhdCBhbGwgaXRlbXMgaW4gdGhlIFtsZWZ0LCBrXSByYW5nZSBhcmUgc21hbGxlciB0aGFuIGFsbCBpdGVtcyBpbiAoaywgcmlnaHRdO1xuLy8gVGhlIGstdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIChrIC0gbGVmdCArIDEpdGggc21hbGxlc3QgdmFsdWUgaW4gW2xlZnQsIHJpZ2h0XVxuXG5mdW5jdGlvbiBwYXJ0aWFsU29ydChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgICByaWdodCA9IHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSk7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmU7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgcGFydGlhbFNvcnQoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzdHJhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBjb21wYXJlTm9kZU1pblgsXG4gICAgY29tcGFyZU1pblk6IGNvbXBhcmVOb2RlTWluWSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsXG4gICAgICAgICAgICAncmV0dXJuIHttaW5YOiBhJyArIGZvcm1hdFswXSArXG4gICAgICAgICAgICAnLCBtaW5ZOiBhJyArIGZvcm1hdFsxXSArXG4gICAgICAgICAgICAnLCBtYXhYOiBhJyArIGZvcm1hdFsyXSArXG4gICAgICAgICAgICAnLCBtYXhZOiBhJyArIGZvcm1hdFszXSArICd9OycpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbikge1xuICAgIGlmICghZXF1YWxzRm4pIHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzRm4oaXRlbSwgaXRlbXNbaV0pKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoZGVzdE5vZGUsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3ROb2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGEubWluWCA9IE1hdGgubWluKGEubWluWCwgYi5taW5YKTtcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIGEubWF4WSA9IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICogKGEubWF4WSAtIGEubWluWSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiLm1heFksIGEubWF4WSkgLSBNYXRoLm1pbihiLm1pblksIGEubWluWSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBHcmFwaCA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24vR3JhcGgnKTtcblxuICAgIEwuQ1JTLkdyYXBoID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XG5cbiAgICAgICAgcHJvamVjdGlvbjogR3JhcGgsXG5cbiAgICAgICAgdHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDEsIDAsIDEsIDApLFxuXG4gICAgICAgIGluZmluaXRlOiBmYWxzZSxcblxuICAgICAgICBzY2FsZTogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHpvb206IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uKGxhdGxuZzEsIGxhdGxuZzIpIHtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZztcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEwuQ1JTLkdyYXBoO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoJylcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIE1hcDogcmVxdWlyZSgnLi9tYXAvTWFwJyksXG4gICAgICAgIFByb2plY3Rpb246IHJlcXVpcmUoJy4vcHJvamVjdGlvbi9leHBvcnRzJyksXG4gICAgICAgIENSUzogcmVxdWlyZSgnLi9DUlMvZXhwb3J0cycpLFxuICAgICAgICBUaWxlTGF5ZXI6IHJlcXVpcmUoJy4vbGF5ZXIvZXhwb3J0cycpLFxuICAgICAgICBSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9leHBvcnRzJyksXG4gICAgICAgIFRpbGVSZXF1ZXN0b3I6IHJlcXVpcmUoJy4vcmVxdWVzdC9UaWxlUmVxdWVzdG9yJyksXG4gICAgICAgIE1ldGFSZXF1ZXN0b3I6IHJlcXVpcmUoJy4vcmVxdWVzdC9NZXRhUmVxdWVzdG9yJyksXG4gICAgICAgIENvbG9yUmFtcDoge1xuICAgICAgICAgICAgLy8gZXhwb3NlIGFzIHN0YXRpYyBtZXRob2RcbiAgICAgICAgICAgIGdldENvbG9yUmFtcDogcmVxdWlyZSgnLi9yZW5kZXJlci9taXhpbi9Db2xvclJhbXAnKS5nZXRDb2xvclJhbXBcbiAgICAgICAgfVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgc2V0Q3VzdG9tQWdncyA9IGZ1bmN0aW9uKGFnZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmN1c3RvbV9hZ2dzID0ge1xuICAgICAgICAgICAgYWdnczogYWdnc1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc2V0Q3VzdG9tQWdnczogc2V0Q3VzdG9tQWdnc1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBzZXREYXRlSGlzdG9ncmFtID0gZnVuY3Rpb24oZmllbGQsIGZyb20sIHRvLCBpbnRlcnZhbCkge1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnRGF0ZUhpc3RvZ3JhbSBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0RhdGVIaXN0b2dyYW0gYGZyb21gIGFyZSBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnRGF0ZUhpc3RvZ3JhbSBgdG9gIGFyZSBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcmFtcy5kYXRlX2hpc3RvZ3JhbSA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICBpbnRlcnZhbDogaW50ZXJ2YWxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldERhdGVIaXN0b2dyYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5kYXRlX2hpc3RvZ3JhbTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNldERhdGVIaXN0b2dyYW06IHNldERhdGVIaXN0b2dyYW0sXG4gICAgICAgIGdldERhdGVIaXN0b2dyYW06IGdldERhdGVIaXN0b2dyYW1cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdIaXN0b2dyYW0gYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSGlzdG9ncmFtIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldEhpc3RvZ3JhbSA9IGZ1bmN0aW9uKGZpZWxkLCBpbnRlcnZhbCkge1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnSGlzdG9ncmFtIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgICAgICB0aHJvdyAnSGlzdG9ncmFtIGBpbnRlcnZhbGAgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZCh0aGlzLl9tZXRhW2ZpZWxkXSwgZmllbGQpO1xuICAgICAgICB0aGlzLl9wYXJhbXMuaGlzdG9ncmFtID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRIaXN0b2dyYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5oaXN0b2dyYW07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRIaXN0b2dyYW06IHNldEhpc3RvZ3JhbSxcbiAgICAgICAgZ2V0SGlzdG9ncmFtOiBnZXRIaXN0b2dyYW1cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTUVUUklDUyA9IHtcbiAgICAgICAgJ21pbic6IHRydWUsXG4gICAgICAgICdtYXgnOiB0cnVlLFxuICAgICAgICAnc3VtJzogdHJ1ZSxcbiAgICAgICAgJ2F2Zyc6IHRydWVcbiAgICB9O1xuXG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdNZXRyaXggYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnTWV0cmljIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldE1ldHJpYyA9IGZ1bmN0aW9uKGZpZWxkLCB0eXBlKSB7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdNZXRyaWMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgJ01ldHJpYyBgdHlwZWAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKHRoaXMuX21ldGFbZmllbGRdLCBmaWVsZCk7XG4gICAgICAgIGlmICghTUVUUklDU1t0eXBlXSkge1xuICAgICAgICAgICAgdGhyb3cgJ01ldHJpYyB0eXBlIGAnICsgdHlwZSArICdgIGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcmFtcy5tZXRyaWMgPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRNZXRyaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5tZXRyaWM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvLyB0aWxpbmdcbiAgICAgICAgc2V0TWV0cmljOiBzZXRNZXRyaWMsXG4gICAgICAgIGdldE1ldHJpYzogZ2V0TWV0cmljLFxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3Qgb2YgdHlwZSBgc3RyaW5nYCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldFRlcm1zID0gZnVuY3Rpb24oZmllbGQsIHNpemUpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50JztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKHRoaXMuX21ldGFbZmllbGRdLCBmaWVsZCk7XG4gICAgICAgIHRoaXMuX3BhcmFtcy50ZXJtcyA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFRlcm1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMudGVybXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUZXJtczogc2V0VGVybXMsXG4gICAgICAgIGdldFRlcm1zOiBnZXRUZXJtc1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3Qgb2YgdHlwZSBgc3RyaW5nYCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNldFRlcm1zRmlsdGVyID0gZnVuY3Rpb24oZmllbGQsIHRlcm1zKSB7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdUZXJtcyBgdGVybXNgIGFyZSBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQodGhpcy5fbWV0YVtmaWVsZF0sIGZpZWxkKTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLnRlcm1zX2ZpbHRlciA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIHRlcm1zOiB0ZXJtc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0VGVybXNGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy50ZXJtc19maWx0ZXI7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUZXJtc0ZpbHRlcjogc2V0VGVybXNGaWx0ZXIsXG4gICAgICAgIGdldFRlcm1zRmlsdGVyOiBnZXRUZXJtc0ZpbHRlclxuICAgIH07XG5cbn0oKSk7XG4iLCIvLyBQcm92aWRlcyB0b3AgaGl0cyBxdWVyeSBmdW5jdGlvbmFsaXR5LiAnc2l6ZScgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgdG9wXG4vLyBoaXRzIHRvIHJldHVybiwgJ2luY2x1ZGUnIGlzIHRoZSBsaXN0IG9mIGZpZWxkcyB0byBpbmNsdWRlIGluIHRoZSByZXR1cm5lZFxuLy8gZGF0YSwgJ3NvcnQnIGlzIHRoZSBmaWVsZCB0byB1c2UgZm9yIHNvcnQgY3JpdGVyYSwgYW5kICdvcmRlcicgaXMgdmFsdWUgb2Zcbi8vICdhc2MnIG9yICdkZXNjJyB0byBpbmRpY2F0ZSBzb3J0IG9yZGVyaW5nLlxuKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdSYW5nZSBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9yZGluYWwgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnVG9wVGVybXMgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YSc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0VG9wSGl0cyA9IGZ1bmN0aW9uKHNpemUsIGluY2x1ZGUsIHNvcnQsIG9yZGVyKSB7XG4gICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICBjaGVja0ZpZWxkKHRoaXMuX21ldGFbc29ydF0sIHNvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcmFtcy50b3BfaGl0cyA9IHtcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlLFxuICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgIG9yZGVyOiBvcmRlclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0VG9wSGl0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnRvcF9oaXRzO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIHBvaW50IGZvciBleHRlcm5hbCBjb250cm9sc1xuICAgIGNvbnN0IHNldFNvcnRGaWVsZCA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgICAgICAgaWYgKCFzb3J0KSB7XG4gICAgICAgICAgICB0aHJvdyAnVG9wSGl0cyBgc29ydGAgYXJndW1lbnQgaXMgbWlzc2luZyc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZCh0aGlzLl9tZXRhW3NvcnRdLCBzb3J0KTtcbiAgICAgICAgaWYgKHNvcnQgIT09IHRoaXMuX3BhcmFtcy50b3BfaGl0cy5zb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMudG9wX2hpdHMuc29ydCA9IHNvcnQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIHBvaW50IGZvciBleHRlcm5hbCBjb250cm9sc1xuICAgIGNvbnN0IGdldFNvcnRGaWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnRvcF9oaXRzLnNvcnQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUb3BIaXRzOiBzZXRUb3BIaXRzLFxuICAgICAgICBnZXRUb3BIaXRzOiBnZXRUb3BIaXRzLFxuICAgICAgICBzZXRTb3J0RmllbGQ6IHNldFNvcnRGaWVsZCxcbiAgICAgICAgZ2V0U29ydEZpZWxkOiBnZXRTb3J0RmllbGRcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IHJlY29nbml6ZWQgaW4gbWV0YSBkYXRhJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzZXRUb3BUZXJtcyA9IGZ1bmN0aW9uKGZpZWxkLCBzaXplKSB7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdUb3BUZXJtcyBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZCh0aGlzLl9tZXRhW2ZpZWxkXSwgZmllbGQpO1xuICAgICAgICB0aGlzLl9wYXJhbXMudG9wX3Rlcm1zID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0VG9wVGVybXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy50b3BfdGVybXM7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRUb3BUZXJtczogc2V0VG9wVGVybXMsXG4gICAgICAgIGdldFRvcFRlcm1zOiBnZXRUb3BUZXJtc1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgbSkge1xuICAgICAgICByZXR1cm4gKChuICUgbSkgKyBtKSAlIG07XG4gICAgfVxuXG4gICAgY29uc3QgQmFzZSA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdG1zOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9wcmV2TWFwLmFkZExheWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRCcmlnaHRuZXNzOiBmdW5jdGlvbihicmlnaHRuZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9icmlnaHRuZXNzID0gYnJpZ2h0bmVzcztcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5jc3MoJy13ZWJraXQtZmlsdGVyJywgJ2JyaWdodG5lc3MoJyArICh0aGlzLl9icmlnaHRuZXNzICogMTAwKSArICclKScpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmNzcygnZmlsdGVyJywgJ2JyaWdodG5lc3MoJyArICh0aGlzLl9icmlnaHRuZXNzICogMTAwKSArICclKScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJyaWdodG5lc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9icmlnaHRuZXNzICE9PSB1bmRlZmluZWQpID8gdGhpcy5fYnJpZ2h0bmVzcyA6IDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUYXJnZXRMYXllcjogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIgPT09IGVsZW0gfHwgJC5jb250YWlucyh0aGlzLl9jb250YWluZXIsIGVsZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRMYXllclBvaW50RnJvbUxvbkxhdDogZnVuY3Rpb24obG9ubGF0UG9pbnQsIHpvb20pIHtcbiAgICAgICAgICAgIHpvb20gPSAoem9vbSAhPT0gdW5kZWZpbmVkKSA/IHpvb20gOiB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9tYXAucHJvamVjdChsb25sYXRQb2ludCwgem9vbSk7XG4gICAgICAgICAgICBjb25zdCBwb3cgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QocGl4ZWwueCwgcG93ICogdGlsZVNpemUpLFxuICAgICAgICAgICAgICAgIHk6IG1vZChwaXhlbC55LCBwb3cgKiB0aWxlU2l6ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGF5ZXJQb2ludEZyb21FdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgbG9ubGF0ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xhdExuZyhlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMYXllclBvaW50RnJvbUxvbkxhdChsb25sYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRpbGVDb29yZEZyb21MYXllclBvaW50OiBmdW5jdGlvbihsYXllclBvaW50KSB7XG4gICAgICAgICAgICBjb25zdCB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5mbG9vcihsYXllclBvaW50LnggLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcihsYXllclBvaW50LnkgLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICAgICAgejogdGhpcy5fbWFwLmdldFpvb20oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCaW5Db29yZEZyb21MYXllclBvaW50OiBmdW5jdGlvbihsYXllclBvaW50LCByZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHJlcyB8fCB0aGlzLmdldFJlc29sdXRpb24oKSB8fCB0aWxlU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gbW9kKGxheWVyUG9pbnQueCwgdGlsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMub3B0aW9ucy50bXMgPyByZXNvbHV0aW9uIC0gbGF5ZXJQb2ludC55IDogbGF5ZXJQb2ludC55O1xuICAgICAgICAgICAgY29uc3QgdHkgPSBtb2QoeSwgdGlsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxTaXplID0gdGlsZVNpemUgLyByZXNvbHV0aW9uO1xuICAgICAgICAgICAgY29uc3QgYnggPSBNYXRoLmZsb29yKHR4IC8gcGl4ZWxTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5ID0gTWF0aC5mbG9vcih0eSAvIHBpeGVsU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGJ4LFxuICAgICAgICAgICAgICAgIHk6IGJ5LFxuICAgICAgICAgICAgICAgIGluZGV4OiBieCArIChieSAqIHJlc29sdXRpb24pLFxuICAgICAgICAgICAgICAgIHNpemU6IHBpeGVsU2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkVGlsZTogZnVuY3Rpb24oY29vcmRzLCBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3Jkcyk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHNvIHRoYXQgd2UgZG9uJ3QgcGFzcyBpbiB3cmFwcGVkIGNvb3JkcyBoZXJlXG4gICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKGNvb3JkcywgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0VGlsZSh0aWxlKTtcbiAgICAgICAgICAgIC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG4gICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG4gICAgICAgICAgICBpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuICAgICAgICAgICAgICAgIEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuICAgICAgICAgICAgLy8gc2F2ZSB0aWxlIGluIGNhY2hlXG4gICAgICAgICAgICB0aGlzLl90aWxlc1trZXldID0ge1xuICAgICAgICAgICAgICAgIGVsOiB0aWxlLFxuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG4gICAgICAgICAgICAvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICAgICAgdmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuICAgICAgICAgICAgaWYgKCFjcnMuaW5maW5pdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKCgoIWNycy53cmFwTG5nIHx8IHRoaXMub3B0aW9ucy5ub1dyYXApICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoIWNycy53cmFwTGF0IHx8IHRoaXMub3B0aW9ucy5ub1dyYXApICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICAgICAgLy8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuICAgICAgICAgICAgdmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcbiAgICAgICAgICAgIHJldHVybiBMLmxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRUb0NvcHkoZnVuY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmNOYW1lICE9PSAnY29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBmdW5jTmFtZSAhPT0gJ29uJyAmJlxuICAgICAgICAgICAgZnVuY05hbWUgIT09ICdvZmYnICYmXG4gICAgICAgICAgICBmdW5jTmFtZSAhPT0gJ3NldFF1ZXJ5JyAmJlxuICAgICAgICAgICAgZnVuY05hbWUgIT09ICdjbGVhclF1ZXJ5JyAmJlxuICAgICAgICAgICAgZnVuY05hbWVbMF0gIT09ICdfJztcbiAgICB9XG5cbiAgICBjb25zdCBDb21wb3NpdGUgPSBMLkNsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obGF5ZXJzID0gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBhbGwgZnVuY3Rpb25zIGZvciBlYWNoIGxheWVyXG4gICAgICAgICAgICBsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgICAgICAgXy5mb3JJbihsYXllciwgKHZhbCwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odmFsKSAmJiB2YWxpZFRvQ29weShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XSA9IGZ1bmN0aW9uc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zW2tleV0ucHVzaChsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2V0IHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IGxheWVycztcbiAgICAgICAgICAgIHRoaXMuX2Z1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9xdWVyeSA9IG51bGw7XG4gICAgICAgICAgICAvLyBleHRlbmQgdGhpcyBjb21wb3NpdGUgY2xhc3MgZm9yIGVhY2ggZnVuY3Rpb25cbiAgICAgICAgICAgIF8uZm9ySW4oZnVuY3Rpb25zLCAobGF5ZXJzLCBmdW5jKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0ZW5kKGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2dCwgZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICAgICAgICAgIGxheWVyLm9uKGV2dCwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2dF0gPSB0aGlzLl9oYW5kbGVyc1tldnRdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZ0XS5wdXNoKGZ1bmMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9mZjogZnVuY3Rpb24oZXZ0LCBmdW5jKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2dF07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIub2ZmKGV2dCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZXZ0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRRdWVyeTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICBsYXllci5zZXRRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5jbGVhclF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9leHRlbmQ6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHRoaXMuX2Z1bmN0aW9ucztcbiAgICAgICAgICAgIHRoaXNbZnVuY10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcnMgPSBmdW5jdGlvbnNbZnVuY107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbGF5ZXJbZnVuY10uYXBwbHkobGF5ZXIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRTdWJMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHRoaXMuX2Z1bmN0aW9ucztcbiAgICAgICAgICAgIF8uZm9ySW4obGF5ZXIsICh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgZnVuY3Rpb24gYW5kIHZhbGlkIHRvIGNvcHlcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbCkgJiYgdmFsaWRUb0NvcHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbGF5ZXIgdG8gZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1trZXldID0gZnVuY3Rpb25zW2tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1trZXldLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25zW2tleV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIG5ldyBmdW5jdGlvbiwgZXh0ZW5kIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVuZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhZGQgdG8gbGF5ZXJzXG4gICAgICAgICAgICB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICAvLyBhZGQgaGFuZGxlcnMgdG8gbGF5ZXJcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5faGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXJzLCBldnQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIub24oZXZ0LCBmdW5jKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHF1ZXJ5IHRvIGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIuc2V0UXVlcnkodGhpcy5fcXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVN1YkxheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9sYXllcnMuaW5kZXhPZihsYXllcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBmdW5jdGlvbnMgdXNlZCBleGNsdXNpdmVseSBieSB0aGlzIGxheWVyXG4gICAgICAgICAgICBfLmZvckluKGxheWVyLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbCkgJiYgdmFsaWRUb0NvcHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZ1bmN0aW9uc1trZXldLmluZGV4T2YobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBmdW5jdGlvbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGV4Y2x1c2l2ZSBvd25lciBvZiBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25zW2tleV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBtb3JlIHVzZSBmb3IgdGhpcyBmdW5jdGlvbiwgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgbGF5ZXJcbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGhhbmRsZXJzIGZyb20gbGF5ZXJcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5faGFuZGxlcnMsIChoYW5kbGVycywgZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIub2ZmKGV2dCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBxdWVyeSBmcm9tIHRoZSBsYXllclxuICAgICAgICAgICAgbGF5ZXIuY2xlYXJRdWVyeSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0ZTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuICAgIGNvbnN0IERlYnVnID0gQmFzZS5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHVubG9hZEludmlzaWJsZVRpbGVzOiB0cnVlLFxuICAgICAgICAgICAgekluZGV4OiA1MDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gc2V0IHJlbmRlcmVyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVuZGVyZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBgcmVuZGVyZXJDbGFzc2Agb3B0aW9uIGZvdW5kLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGV4dGVuZFxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIG9wdGlvbnMucmVuZGVyZXJDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSA8ZGl2PiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAgICAgICAgICBjb25zdCB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZScpO1xuICAgICAgICAgICAgLy8gZHJhdyB0byBpdFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGUsIGNvb3JkKTtcbiAgICAgICAgICAgIC8vIHBhc3MgdGlsZSB0byBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRGVidWc7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBJbWFnZSA9IEwuVGlsZUxheWVyLmV4dGVuZCh7XG5cbiAgICAgICAgZ2V0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXAuYWRkTGF5ZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJldk1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0hpZGRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEJyaWdodG5lc3M6IGZ1bmN0aW9uKGJyaWdodG5lc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2JyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmNzcygnLXdlYmtpdC1maWx0ZXInLCAnYnJpZ2h0bmVzcygnICsgKHRoaXMuX2JyaWdodG5lc3MgKiAxMDApICsgJyUpJyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuY3NzKCdmaWx0ZXInLCAnYnJpZ2h0bmVzcygnICsgKHRoaXMuX2JyaWdodG5lc3MgKiAxMDApICsgJyUpJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2JyaWdodG5lc3MgIT09IHVuZGVmaW5lZCkgPyB0aGlzLl9icmlnaHRuZXNzIDogMTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW1hZ2U7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBib29sUXVlcnlDaGVjayA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0Jvb2wnKTtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBjb25zdCBMaXZlID0gTC5DbGFzcy5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdmFsID0+IHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1ldGEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgLy8gc2V0IHJlbmRlcmVyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGV4dGVuZCBhbmQgaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbmRlcmVyQ2xhc3MucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IG9wdGlvbnMucmVuZGVyZXJDbGFzcygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlckNsYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgdGhpcyBvYmplY3RcbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLCByZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgLy8gY29weSBwcm90b3R5cGUgb3B0aW9ucyBwcm9wZXJ0eSBieSB2YWx1ZSwgdGhpcyBpcyBpbXBvcnRhbnRcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5yZW5kZXJlckNsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHNldCBtZXRhXG4gICAgICAgICAgICB0aGlzLl9tZXRhID0gbWV0YTtcbiAgICAgICAgICAgIC8vIHNldCBwYXJhbXNcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBiaW5uaW5nOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHNldCBleHRyZW1hIC8gY2FjaGVcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyRXh0cmVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9leHRyZW1hID0ge1xuICAgICAgICAgICAgICAgIG1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgICAgICBtYXg6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RXh0cmVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXh0cmVtYTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVFeHRyZW1hOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHRyZW1hID0gdGhpcy5leHRyYWN0RXh0cmVtYShkYXRhKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXh0cmVtYS5taW4gPCB0aGlzLl9leHRyZW1hLm1pbikge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJlbWEubWluID0gZXh0cmVtYS5taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmVtYS5tYXggPiB0aGlzLl9leHRyZW1hLm1heCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJlbWEubWF4ID0gZXh0cmVtYS5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKGRhdGEpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoZGF0YSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UXVlcnk6IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5Lm11c3QgJiYgIXF1ZXJ5Lm11c3Rfbm90ICYmICFxdWVyeS5zaG91bGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnUm9vdCBxdWVyeSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGBtdXN0YCwgYG11c3Rfbm90YCwgb3IgYHNob3VsZGAgYXJndW1lbnQuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHF1ZXJ5IGlzIHZhbGlkXG4gICAgICAgICAgICBib29sUXVlcnlDaGVjayh0aGlzLl9tZXRhLCBxdWVyeSk7XG4gICAgICAgICAgICAvLyBzZXQgcXVlcnlcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5tdXN0ID0gcXVlcnkubXVzdDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5tdXN0X25vdCA9IHF1ZXJ5Lm11c3Rfbm90O1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnNob3VsZCA9IHF1ZXJ5LnNob3VsZDtcbiAgICAgICAgICAgIC8vIGNsZWF0IGV4dHJlbWFcbiAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtdXN0OiB0aGlzLl9wYXJhbXMubXVzdCxcbiAgICAgICAgICAgICAgICBtdXN0X25vdDogdGhpcy5fcGFyYW1zLm11c3Rfbm90LFxuICAgICAgICAgICAgICAgIHNob3VsZDogdGhpcy5fcGFyYW1zLnNob3VsZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBxdWVyeVxuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLm11c3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMubXVzdF9ub3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMuc2hvdWxkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gY2xlYXQgZXh0cmVtYVxuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRNZXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE5vcm1hbGl6ZWRDb29yZHM6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgY29uc3QgcG93ID0gTWF0aC5wb3coMiwgY29vcmRzLnopO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QoY29vcmRzLngsIHBvdyksXG4gICAgICAgICAgICAgICAgeTogbW9kKGNvb3Jkcy55LCBwb3cpLFxuICAgICAgICAgICAgICAgIHo6IGNvb3Jkcy56XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhY2hlS2V5RnJvbUNvb3JkOiBmdW5jdGlvbihjb29yZHMsIG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGxlYWZsZXQgbGF5ZXIgeCBhbmQgeSBtYXkgYmUgPiBuXjIsIGFuZCA8IDAgaW4gdGhlIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBvZiBhIHdyYXBhcm91bmQuIElmIG5vcm1hbGl6ZSBpcyB0cnVlLCBtb2QgdGhlIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb3Jkcy56ICsgJzonICsgY29vcmRzLnggKyAnOicgKyBjb29yZHMueTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb29yZEZyb21DYWNoZUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBrZXkuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcGFyc2VJbnQoYXJyWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgeTogcGFyc2VJbnQoYXJyWzJdLCAxMCksXG4gICAgICAgICAgICAgICAgejogcGFyc2VJbnQoYXJyWzBdLCAxMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25UaWxlVW5sb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IGV2ZW50LmNvb3JkcztcbiAgICAgICAgICAgIC8vIHJlc3BlY3QgdGhlIFRNUyBzZXR0aW5nIGluIHRoZSBvcHRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRtcykge1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZlbnQuY29vcmRzLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGgucG93KDIsIGV2ZW50LmNvb3Jkcy56KSAtIDEgLSBldmVudC5jb29yZHMueSxcbiAgICAgICAgICAgICAgICAgICAgejogZXZlbnQuY29vcmRzLnpcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FjaGUga2V5IGZyb20gY29vcmRzXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3Jkcyk7XG4gICAgICAgICAgICAvLyBjYWNoZSBrZXkgZnJvbSBub3JtYWxpemVkIGNvb3Jkc1xuICAgICAgICAgICAgY29uc3QgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAvLyBjb3VsZCB0aGUgYmUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgaXMgY2xlYXJlZCBiZWZvcmUgdGlsZXMgYXJlXG4gICAgICAgICAgICAvLyB1bmxvYWRlZFxuICAgICAgICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRpbGUgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZWQudGlsZXNba2V5XTtcbiAgICAgICAgICAgIC8vIGRvbid0IHJlbW92ZSBjYWNoZSBlbnRyeSB1bmxlc3MgdG8gdGlsZXMgdXNlIGl0IGFueW1vcmVcbiAgICAgICAgICAgIGlmIChfLmtleXMoY2FjaGVkLnRpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHRpbGUgYmVpbmcgZGVsZXRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBjYWNoZWQudGlsZXNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBubyBtb3JlIHRpbGVzIHVzZSB0aGlzIGNhY2hlZCBkYXRhLCBzbyBkZWxldGUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NhY2hldW5sb2FkJywge1xuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgZW50cnk6IGNhY2hlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfcmVxdWVzdFRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgdGlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlc3BlY3QgdGhlIFRNUyBzZXR0aW5nIGluIHRoZSBvcHRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRtcykge1xuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29vcmRzLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGgucG93KDIsIGNvb3Jkcy56KSAtIDEgLSBjb29yZHMueSxcbiAgICAgICAgICAgICAgICAgICAgejogY29vcmRzLnpcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgLy8gY2FjaGUga2V5IGZyb20gY29vcmRzXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3Jkcyk7XG4gICAgICAgICAgICAvLyBjYWNoZSBrZXkgZnJvbSBub3JtYWxpemVkIGNvb3Jkc1xuICAgICAgICAgICAgY29uc3QgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGlsZSB1bmRlciBub3JtYWxpemUgY29vcmRzXG4gICAgICAgICAgICAgICAgY2FjaGVkLnRpbGVzW2tleV0gPSB0aWxlO1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBlbnRyeSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NhY2hlaGl0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZTogdGlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnk6IGNhY2hlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aWxlIGlzIGFscmVhZHkgcGVuZGluZywgYWRkIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZC5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW25rZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBpc1BlbmRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbIGNhbGxiYWNrIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0aWxlIHRvIHRoZSBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW25rZXldLnRpbGVzW2tleV0gPSB0aWxlO1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgdGhlIHRpbGVcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RUaWxlKG5jb29yZHMsIGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRpbGUgaXMgbm8gbG9uZ2VyIGJlaW5nIHRyYWNrZWQsIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgYXMgbm8gbG9uZ2VyIHBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYW5kIHN0b3JlIHRpbGUgZGF0YSBpbiBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuZGF0YSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgcGVuZGluZyBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLmNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQuY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgaXMgbG9hZGVkIGludG8gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjYWNoZWxvYWQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZXh0cmVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRXh0cmVtYShjYWNoZWQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBleHRyZW1hIGNoYW5nZWQsIGZpcmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2V4dHJlbWFjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXF1ZXN0VGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGl2ZTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gICAgICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAgICB9XG5cbiAgICBjb25zdCBQZW5kaW5nID0gQmFzZS5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHVubG9hZEludmlzaWJsZVRpbGVzOiB0cnVlLFxuICAgICAgICAgICAgekluZGV4OiA1MDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RpbGVzID0ge307XG4gICAgICAgICAgICAvLyBzZXQgcmVuZGVyZXJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZW5kZXJlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ05vIGByZW5kZXJlckNsYXNzYCBvcHRpb24gZm91bmQuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZXh0ZW5kXG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgb3B0aW9ucy5yZW5kZXJlckNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBvcHRpb25zXG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIuX2luY3JlbWVudEhhbmRsZXIgPSB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQodGlsZS5jb29yZHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyID0gdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVjcmVtZW50KHRpbGUuY29vcmRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYXllci5vbigndGlsZXN0YXJ0bG9hZCcsIGxheWVyLl9pbmNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9uKCd0aWxlbG9hZCcsIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9uKCd0aWxlZXJyb3InLCBsYXllci5fZGVjcmVtZW50SGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIub2ZmKCd0aWxlc3RhcnRsb2FkJywgbGF5ZXIuX2luY3JlbWVudEhhbmRsZXIpO1xuICAgICAgICAgICAgbGF5ZXIub2ZmKCd0aWxlbG9hZCcsIGxheWVyLl9kZWNyZW1lbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGxheWVyLm9mZigndGlsZWVycm9yJywgbGF5ZXIuX2RlY3JlbWVudEhhbmRsZXIpO1xuICAgICAgICAgICAgbGF5ZXIuX2luY3JlbWVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgbGF5ZXIuX2RlY3JlbWVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbmNyZW1lbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5fZ2V0VGlsZUhhc2goY29vcmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdID0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlcyA9IHRoaXMuX2dldFRpbGVzV2l0aEhhc2goaGFzaCk7XG4gICAgICAgICAgICAgICAgdGlsZXMuZm9yRWFjaCh0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZShjb29yZCwgdGlsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZWNyZW1lbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5fZ2V0VGlsZUhhc2goY29vcmQpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdLS07XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1RpbGVzW2hhc2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlcyA9IHRoaXMuX2dldFRpbGVzV2l0aEhhc2goaGFzaCk7XG4gICAgICAgICAgICAgICAgdGlsZXMuZm9yRWFjaCh0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZShjb29yZCwgdGlsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFRpbGVDbGFzczogZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuICdsZWFmbGV0LXBlbmRpbmctJyArIGhhc2g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldE5vcm1hbGl6ZWRDb29yZHM6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgY29uc3QgcG93ID0gTWF0aC5wb3coMiwgY29vcmRzLnopO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtb2QoY29vcmRzLngsIHBvdyksXG4gICAgICAgICAgICAgICAgeTogbW9kKGNvb3Jkcy55LCBwb3cpLFxuICAgICAgICAgICAgICAgIHo6IGNvb3Jkcy56XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUaWxlSGFzaDogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICBjb25zdCBuY29vcmRzID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5jb29yZHMueiArICctJyArIG5jb29yZHMueCArICctJyArIG5jb29yZHMueTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0VGlsZXNXaXRoSGFzaDogZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5fZ2V0VGlsZUNsYXNzKGhhc2gpO1xuICAgICAgICAgICAgY29uc3QgdGlsZXMgPSBbXTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5maW5kKCcuJyArIGNsYXNzTmFtZSkuZWFjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGlsZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVUaWxlOiBmdW5jdGlvbihjb29yZCwgdGlsZSkge1xuICAgICAgICAgICAgLy8gZ2V0IGhhc2hcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9nZXRUaWxlSGFzaChjb29yZCk7XG4gICAgICAgICAgICAkKHRpbGUpLmFkZENsYXNzKHRoaXMuX2dldFRpbGVDbGFzcyhoYXNoKSArICcgcGVuZGluZycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdUaWxlc1toYXNoXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRpbGUpLnJlbW92ZUNsYXNzKCdwZW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgdGlsZS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgPGRpdj4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgICAgICAgICAgY29uc3QgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUgbGVhZmxldC10aWxlLXBlbmRpbmcnKTtcbiAgICAgICAgICAgIC8vIGdldCBoYXNoXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlKGNvb3JkLCB0aWxlKTtcbiAgICAgICAgICAgIC8vIHBhc3MgdGlsZSB0byBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIGRlYnVnIHRpbGUgbGF5ZXJcbiAgICBsZXQgRGVidWcgPSByZXF1aXJlKCcuL2NvcmUvRGVidWcnKTtcblxuICAgIC8vIHBlbmRpbmcgdGlsZSBsYXllclxuICAgIGxldCBQZW5kaW5nID0gcmVxdWlyZSgnLi9jb3JlL1BlbmRpbmcnKTtcblxuICAgIC8vIGltYWdlIGxheWVyXG4gICAgbGV0IEltYWdlID0gcmVxdWlyZSgnLi9jb3JlL0ltYWdlJyk7XG5cbiAgICAvLyBjb21wb3NpdGUgbGF5ZXJcbiAgICBsZXQgQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9jb3JlL0NvbXBvc2l0ZScpO1xuXG4gICAgLy8gbGl2ZSBsYXllciAtIGJhc2UgdHlwZSBmb3IgZXh0ZW5zaW9uXG4gICAgbGV0IExpdmUgPSByZXF1aXJlKCcuL2NvcmUvTGl2ZScpO1xuXG4gICAgLy8gbGl2ZSB0aWxlIGxheWVyc1xuICAgIGxldCBIZWF0bWFwID0gcmVxdWlyZSgnLi90eXBlL0hlYXRtYXAnKTtcbiAgICBsZXQgVG9wVHJhaWxzID0gcmVxdWlyZSgnLi90eXBlL1RvcFRyYWlscycpO1xuICAgIGxldCBUb3BDb3VudCA9IHJlcXVpcmUoJy4vdHlwZS9Ub3BDb3VudCcpO1xuICAgIGxldCBUb3BGcmVxdWVuY3kgPSByZXF1aXJlKCcuL3R5cGUvVG9wRnJlcXVlbmN5Jyk7XG4gICAgbGV0IEZyZXF1ZW5jeSA9IHJlcXVpcmUoJy4vdHlwZS9GcmVxdWVuY3knKTtcbiAgICBsZXQgVG9waWNDb3VudCA9IHJlcXVpcmUoJy4vdHlwZS9Ub3BpY0NvdW50Jyk7XG4gICAgbGV0IFRvcGljRnJlcXVlbmN5ID0gcmVxdWlyZSgnLi90eXBlL1RvcGljRnJlcXVlbmN5Jyk7XG4gICAgbGV0IFByZXZpZXcgPSByZXF1aXJlKCcuL3R5cGUvUHJldmlldycpO1xuICAgIGxldCBNYWNybyA9IHJlcXVpcmUoJy4vdHlwZS9NYWNybycpO1xuICAgIGxldCBNaWNybyA9IHJlcXVpcmUoJy4vdHlwZS9NaWNybycpO1xuICAgIGxldCBDb3VudCA9IHJlcXVpcmUoJy4vdHlwZS9Db3VudCcpO1xuICAgIGxldCBDb21tdW5pdHkgPSByZXF1aXJlKCcuL3R5cGUvQ29tbXVuaXR5Jyk7XG4gICAgbGV0IEN1c3RvbSA9IHJlcXVpcmUoJy4vdHlwZS9DdXN0b20nKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBEZWJ1ZzogRGVidWcsXG4gICAgICAgIFBlbmRpbmc6IFBlbmRpbmcsXG4gICAgICAgIEltYWdlOiBJbWFnZSxcbiAgICAgICAgQ29tcG9zaXRlOiBDb21wb3NpdGUsXG4gICAgICAgIExpdmU6IExpdmUsXG4gICAgICAgIEhlYXRtYXA6IEhlYXRtYXAsXG4gICAgICAgIFRvcENvdW50OiBUb3BDb3VudCxcbiAgICAgICAgVG9wVHJhaWxzOiBUb3BUcmFpbHMsXG4gICAgICAgIFRvcEZyZXF1ZW5jeTogVG9wRnJlcXVlbmN5LFxuICAgICAgICBGcmVxdWVuY3k6IEZyZXF1ZW5jeSxcbiAgICAgICAgVG9waWNDb3VudDogVG9waWNDb3VudCxcbiAgICAgICAgVG9waWNGcmVxdWVuY3k6IFRvcGljRnJlcXVlbmN5LFxuICAgICAgICBQcmV2aWV3OiBQcmV2aWV3LFxuICAgICAgICBNYWNybzogTWFjcm8sXG4gICAgICAgIE1pY3JvOiBNaWNybyxcbiAgICAgICAgQ291bnQ6IENvdW50LFxuICAgICAgICBDb21tdW5pdHk6IENvbW11bml0eSxcbiAgICAgICAgQ3VzdG9tOiBDdXN0b21cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgREVGQVVMVF9SRVNPTFVUSU9OID0gMjU2O1xuXG4gICAgY29uc3QgVGlsaW5nID0gcmVxdWlyZSgnLi9UaWxpbmcnKTtcblxuICAgIGNvbnN0IHNldFJlc29sdXRpb24gPSBmdW5jdGlvbihyZXNvbHV0aW9uKSB7XG4gICAgICAgIGlmIChyZXNvbHV0aW9uICE9PSB0aGlzLl9wYXJhbXMuYmlubmluZy5yZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFJlc29sdXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnJlc29sdXRpb24gfHwgREVGQVVMVF9SRVNPTFVUSU9OO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLy8gdGlsaW5nXG4gICAgICAgIHNldFhGaWVsZDogVGlsaW5nLnNldFhGaWVsZCxcbiAgICAgICAgZ2V0WEZpZWxkOiBUaWxpbmcuZ2V0WEZpZWxkLFxuICAgICAgICBzZXRZRmllbGQ6IFRpbGluZy5zZXRZRmllbGQsXG4gICAgICAgIGdldFlGaWVsZDogVGlsaW5nLmdldFlGaWVsZCxcbiAgICAgICAgZ2V0TGF5ZXJQb2ludEZyb21EYXRhUG9pbnQ6IFRpbGluZy5nZXRMYXllclBvaW50RnJvbURhdGFQb2ludCxcbiAgICAgICAgZ2V0RGF0YVBvaW50RnJvbUxheWVyUG9pbnQ6IFRpbGluZy5nZXREYXRhUG9pbnRGcm9tTGF5ZXJQb2ludCxcbiAgICAgICAgREVGQVVMVF9YX0ZJRUxEOiBUaWxpbmcuREVGQVVMVF9YX0ZJRUxELFxuICAgICAgICBERUZBVUxUX1lfRklFTEQ6IFRpbGluZy5ERUZBVUxUX1lfRklFTEQsXG4gICAgICAgIERFRkFVTFRfUElYRUxfTUFYOiBUaWxpbmcuREVGQVVMVF9QSVhFTF9NQVgsXG4gICAgICAgIC8vIGJpbm5pbmdcbiAgICAgICAgc2V0UmVzb2x1dGlvbjogc2V0UmVzb2x1dGlvbixcbiAgICAgICAgZ2V0UmVzb2x1dGlvbjogZ2V0UmVzb2x1dGlvbixcbiAgICAgICAgREVGQVVMVF9SRVNPTFVUSU9OOiBERUZBVUxUX1JFU09MVVRJT05cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgZ2V0VHlwZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5lbGFzdGljID8gdGhpcy5fcGFyYW1zLmVsYXN0aWMudHlwZSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0VHlwZXMgPSBmdW5jdGlvbih0eXBlcykge1xuICAgICAgICBpZiAoIXR5cGVzKSB7XG4gICAgICAgICAgICB0aHJvdyAnUXVlcnlTdHJpbmcgYHR5cGVzYCBhcmUgbm90IHByb3ZpZGVkLic7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZXMgPSBBcnJheS5pc0FycmF5KHR5cGVzKSA/IHR5cGVzIDogWyB0eXBlcyBdO1xuICAgICAgICB0aGlzLl9wYXJhbXMuZWxhc3RpYyA9IHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc2V0VHlwZXM6IHNldFR5cGVzLFxuICAgICAgICBnZXRUeXBlczogZ2V0VHlwZXNcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbiAgICBjb25zdCBERUZBVUxUX1RJTEVfU0laRSA9IDI1NjtcbiAgICBjb25zdCBERUZBVUxUX1hfRklFTEQgPSAncGl4ZWwueCc7XG4gICAgY29uc3QgREVGQVVMVF9ZX0ZJRUxEID0gJ3BpeGVsLnknO1xuICAgIGNvbnN0IERFRkFVTFRfUElYRUxfTUlOID0gMDtcbiAgICBjb25zdCBERUZBVUxUX1BJWEVMX01BWCA9IE1hdGgucG93KDIsIDMyKTtcblxuICAgIGNvbnN0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGEuZXh0cmVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRmllbGQgYCcgKyBmaWVsZCArICdgIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0ZpZWxkIGAnICsgZmllbGQgKyAnYCBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldFhGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkLCB0eXBlLCByZWxhdGlvbnNoaXApIHtcbiAgICAgICAgaWYgKGZpZWxkICE9PSB0aGlzLl9wYXJhbXMuYmlubmluZy54KSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuaW5kZXhPZihERUZBVUxUX1hfRklFTEQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGlmIGRlZmF1bHRcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy54ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcubGVmdCA9IERFRkFVTFRfUElYRUxfTUlOO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnJpZ2h0ID0gREVGQVVMVF9QSVhFTF9NQVg7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFbZmllbGRdO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0ZpZWxkKG1ldGEsIGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy54ID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLmxlZnQgPSBtZXRhLmV4dHJlbWEubWluO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5yaWdodCA9IG1ldGEuZXh0cmVtYS5tYXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnhUeXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcueFJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFhGaWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zLmJpbm5pbmcueDtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0WUZpZWxkID0gZnVuY3Rpb24oZmllbGQsIHR5cGUsIHJlbGF0aW9uc2hpcCkge1xuICAgICAgICBpZiAoZmllbGQgIT09IHRoaXMuX3BhcmFtcy5iaW5uaW5nLnkpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pbmRleE9mKERFRkFVTFRfWV9GSUVMRCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaWYgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnkgPSBmaWVsZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy5ib3R0b20gPSBERUZBVUxUX1BJWEVMX01BWDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy50b3AgPSBERUZBVUxUX1BJWEVMX01JTjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRXh0cmVtYSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YVtmaWVsZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRmllbGQobWV0YSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5iaW5uaW5nLnkgPSBmaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcuYm90dG9tID0gbWV0YS5leHRyZW1hLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcudG9wID0gbWV0YS5leHRyZW1hLm1heDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyYW1zLmJpbm5pbmcueVR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9wYXJhbXMuYmlubmluZy55UmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0WUZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXMuYmlubmluZy55O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRMYXllclBvaW50RnJvbURhdGFQb2ludCA9IGZ1bmN0aW9uKHgsIHksIHpvb20pIHtcbiAgICAgICAgY29uc3QgYmlubmluZyA9IHRoaXMuX3BhcmFtcy5iaW5uaW5nO1xuICAgICAgICBjb25zdCB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSB8fCBERUZBVUxUX1RJTEVfU0laRTtcbiAgICAgICAgY29uc3QgcG93ID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IHRpbGVTaXplICogcG93O1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cbiAgICAgICAgbGV0IGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcDtcbiAgICAgICAgaWYgKG1ldGFbYmlubmluZy54XS50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtb21lbnQoYmlubmluZy5sZWZ0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICByaWdodCA9IG1vbWVudChiaW5uaW5nLnJpZ2h0KS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB4ID0gbW9tZW50KHgpLnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBiaW5uaW5nLmxlZnQ7XG4gICAgICAgICAgICByaWdodCA9IGJpbm5pbmcucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFbYmlubmluZy55XS50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1vbWVudChiaW5uaW5nLmJvdHRvbSkudmFsdWVPZigpO1xuICAgICAgICAgICAgdG9wID0gbW9tZW50KGJpbm5pbmcudG9wKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB5ID0gbW9tZW50KHkpLnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdHRvbSA9IGJpbm5pbmcuYm90dG9tO1xuICAgICAgICAgICAgdG9wID0gYmlubmluZy50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4UmFuZ2UgPSBNYXRoLmFicyhyaWdodCAtIGxlZnQpO1xuICAgICAgICBjb25zdCB5UmFuZ2UgPSBNYXRoLmFicyhib3R0b20gLSB0b3ApO1xuICAgICAgICBsZXQgbngsIG55O1xuICAgICAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgICAgICBueCA9IDEgLSAoKHggLSByaWdodCkgLyB4UmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnggPSAoeCAtIGxlZnQpIC8geFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3AgPiBib3R0b20pIHtcbiAgICAgICAgICAgIG55ID0gMSAtICgoeSAtIGJvdHRvbSkgLyB5UmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnkgPSAoeSAtIHRvcCkgLyB5UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGV4dGVudCAqIG54LFxuICAgICAgICAgICAgeTogZXh0ZW50ICogbnlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0RGF0YVBvaW50RnJvbUxheWVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCB6b29tKSB7XG4gICAgICAgIGNvbnN0IGJpbm5pbmcgPSB0aGlzLl9wYXJhbXMuYmlubmluZztcbiAgICAgICAgY29uc3QgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUgfHwgREVGQVVMVF9USUxFX1NJWkU7XG4gICAgICAgIGNvbnN0IHBvdyA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICBjb25zdCBleHRlbnQgPSB0aWxlU2l6ZSAqIHBvdztcbiAgICAgICAgY29uc3QgbnggPSB4IC8gZXh0ZW50O1xuICAgICAgICBjb25zdCBueSA9IHkgLyBleHRlbnQ7XG4gICAgICAgIGNvbnN0IHhSYW5nZSA9IE1hdGguYWJzKGJpbm5pbmcucmlnaHQgLSBiaW5uaW5nLmxlZnQpO1xuICAgICAgICBjb25zdCB5UmFuZ2UgPSBNYXRoLmFicyhiaW5uaW5nLmJvdHRvbSAtIGJpbm5pbmcudG9wKTtcbiAgICAgICAgbGV0IHB4LCBweTtcbiAgICAgICAgaWYgKGJpbm5pbmcubGVmdCA+IGJpbm5pbmcucmlnaHQpIHtcbiAgICAgICAgICAgIHB4ID0gYmlubmluZy5yaWdodCArICgxIC0gbngpICogeFJhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHggPSBiaW5uaW5nLmxlZnQgKyBueCAqIHhSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmlubmluZy50b3AgPiBiaW5uaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgcHkgPSBiaW5uaW5nLmJvdHRvbSArICgxIC0gbnkpICogeVJhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHkgPSBiaW5uaW5nLnRvcCArIG55ICogeVJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBweCxcbiAgICAgICAgICAgIHk6IHB5XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzZXRYRmllbGQ6IHNldFhGaWVsZCxcbiAgICAgICAgZ2V0WEZpZWxkOiBnZXRYRmllbGQsXG4gICAgICAgIHNldFlGaWVsZDogc2V0WUZpZWxkLFxuICAgICAgICBnZXRZRmllbGQ6IGdldFlGaWVsZCxcbiAgICAgICAgZ2V0TGF5ZXJQb2ludEZyb21EYXRhUG9pbnQ6IGdldExheWVyUG9pbnRGcm9tRGF0YVBvaW50LFxuICAgICAgICBnZXREYXRhUG9pbnRGcm9tTGF5ZXJQb2ludDogZ2V0RGF0YVBvaW50RnJvbUxheWVyUG9pbnQsXG4gICAgICAgIERFRkFVTFRfWF9GSUVMRDogREVGQVVMVF9YX0ZJRUxELFxuICAgICAgICBERUZBVUxUX1lfRklFTEQ6IERFRkFVTFRfWV9GSUVMRCxcbiAgICAgICAgREVGQVVMVF9QSVhFTF9NQVg6IERFRkFVTFRfUElYRUxfTUFYXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBjaGVjaztcblxuICAgIGZ1bmN0aW9uIGNoZWNrUXVlcnkobWV0YSwgcXVlcnkpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IF8ua2V5cyhxdWVyeSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgJ0Jvb2wgc3ViLXF1ZXJ5IG11c3Qgb25seSBoYXZlIGEgc2luZ2xlIGtleSwgcXVlcnkgaGFzIG11bHRpcGxlIGtleXM6IGAnICsgSlNPTi5zdHJpbmdpZnkoa2V5cykgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBrZXlzWzBdO1xuICAgICAgICBjb25zdCBjaGVja0Z1bmMgPSBjaGVja1t0eXBlXTtcbiAgICAgICAgaWYgKCFjaGVja0Z1bmMpIHtcbiAgICAgICAgICAgIHRocm93ICdRdWVyeSB0eXBlIGAnICsgdHlwZSArICdgIGlzIG5vdCByZWNvZ25pemVkLic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgcXVlcnkgYnkgdHlwZVxuICAgICAgICBjaGVja1t0eXBlXShtZXRhLCBxdWVyeVt0eXBlXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tRdWVyaWVzKG1ldGEsIHF1ZXJpZXMpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheShxdWVyaWVzKSkge1xuICAgICAgICAgICAgcXVlcmllcy5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgICAgICAgICBjaGVja1F1ZXJ5KG1ldGEscXVlcnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBjaGVja1F1ZXJ5KG1ldGEsIHF1ZXJpZXMpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcXVlcmllc1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrQm9vbChtZXRhLCBxdWVyeSkge1xuICAgICAgICBpZiAoIXF1ZXJ5Lm11c3QgJiYgIXF1ZXJ5Lm11c3Rfbm90ICYmICFxdWVyeS5zaG91bGQpIHtcbiAgICAgICAgICAgIHRocm93ICdCb29sIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYG11c3RgLCBgbXVzdF9ub3RgLCBvciBgc2hvdWxkYCBxdWVyeSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5tdXN0KSB7XG4gICAgICAgICAgICBjaGVja1F1ZXJpZXMobWV0YSwgcXVlcnkubXVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5Lm11c3Rfbm90KSB7XG4gICAgICAgICAgICBjaGVja1F1ZXJpZXMobWV0YSwgcXVlcnkubXVzdF9ub3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5zaG91bGQpIHtcbiAgICAgICAgICAgIGNoZWNrUXVlcmllcyhtZXRhLCBxdWVyeS5zaG91bGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2sgPSB7XG4gICAgICAgIGJvb2w6IGNoZWNrQm9vbCxcbiAgICAgICAgZXhpc3RzOiByZXF1aXJlKCcuL0V4aXN0cycpLFxuICAgICAgICBwcmVmaXg6IHJlcXVpcmUoJy4vUHJlZml4JyksXG4gICAgICAgIHF1ZXJ5X3N0cmluZzogcmVxdWlyZSgnLi9RdWVyeVN0cmluZycpLFxuICAgICAgICByYW5nZTogcmVxdWlyZSgnLi9SYW5nZScpLFxuICAgICAgICB0ZXJtczogcmVxdWlyZSgnLi9UZXJtcycpLFxuICAgICAgICBtYXRjaDogcmVxdWlyZSgnLi9NYXRjaCcpLFxuICAgICAgICBoYXNfcGFyZW50OiByZXF1aXJlKCcuL0hhc1BhcmVudCcpLFxuICAgICAgICBoYXNfY2hpbGQ6IHJlcXVpcmUoJy4vSGFzQ2hpbGQnKVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNoZWNrQm9vbDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgIHRocm93ICdFeGlzdHMgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4aXN0cyBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQobWV0YVtxdWVyeS5maWVsZF0sIHF1ZXJ5LmZpZWxkKTtcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRhLCBxdWVyeSkge1xuICAgICAgICBpZiAoIXF1ZXJ5LnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93ICdoYXMtY2hpbGQgYHR5cGVgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcXVlcnkucXVlcnkpIHtcbiAgICAgICAgICAgIHRocm93ICdoYXMtY2hpbGQgYHF1ZXJ5YCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXF1ZXJ5LnF1ZXJ5LmJvb2wpIHtcbiAgICAgICAgICAgIHRocm93ICdoYXMtY2hpbGQgYHF1ZXJ5LmJvb2xgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgfTtcbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkucGFyZW50X3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93ICdoYXMtcGFyZW50IGBwYXJlbnRfdHlwZWAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxdWVyeS5xdWVyeSkge1xuICAgICAgICAgICAgdGhyb3cgJ2hhcy1wYXJlbnQgYHF1ZXJ5YCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXF1ZXJ5LnF1ZXJ5LmJvb2wpIHtcbiAgICAgICAgICAgIHRocm93ICdoYXMtcGFyZW50IGBxdWVyeS5ib29sYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgIH07XG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uKG1ldGEsIGZpZWxkKSB7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdNYXRjaCBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IGBzdHJpbmdgIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ01hdGNoIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdNYXRjaCBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcXVlcnkuc3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWF0Y2ggYHN0cmluZ2AgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1ByZWZpeCBgZmllbGRgICcgKyBmaWVsZCArICcgaXMgbm90IG9mIHR5cGUgYHN0cmluZ2AgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnUHJlZml4IGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdQcmVmaXggYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5wcmVmaXhlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnUHJlZml4IGBwcmVmaXhlc2AgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGaWVsZChtZXRhW3F1ZXJ5LmZpZWxkXSwgcXVlcnkuZmllbGQpO1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBjaGVja0ZpZWxkID0gZnVuY3Rpb24obWV0YSwgZmllbGQpIHtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgYHN0cmluZ2AgaW4gbWV0YSBkYXRhLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnUXVlcnlTdHJpbmcgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCByZWNvZ25pemVkIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKCFxdWVyeS5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1F1ZXJ5U3RyaW5nIGBmaWVsZGAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxdWVyeS5zdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93ICdRdWVyeVN0cmluZyBgc3RyaW5nYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBjaGVja0ZpZWxkKG1ldGFbcXVlcnkuZmllbGRdLCBxdWVyeS5maWVsZCk7XG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IGNoZWNrRmllbGQgPSBmdW5jdGlvbihtZXRhLCBmaWVsZCkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgaWYgKCFtZXRhLmV4dHJlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnUmFuZ2UgYGZpZWxkYCAnICsgZmllbGQgKyAnIGlzIG5vdCBvcmRpbmFsIGluIG1ldGEgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ1JhbmdlIGBmaWVsZGAgJyArIGZpZWxkICsgJyBpcyBub3QgcmVjb2duaXplZCBpbiBtZXRhIGRhdGEuJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGEsIHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkuZmllbGQpIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgZmllbGRgIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5mcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgZnJvbWAgaXMgbWlzc2luZyBmcm9tIGFyZ3VtZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LnRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdSYW5nZSBgdG9gIGlzIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRmllbGQobWV0YVtxdWVyeS5maWVsZF0sIHF1ZXJ5LmZpZWxkKTtcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRhLCBxdWVyeSkge1xuICAgICAgICBpZiAoIXF1ZXJ5LmZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGVybXMgYGZpZWxkYCBpcyBtaXNzaW5nIGZyb20gYXJndW1lbnQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkudGVybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ1Rlcm1zIGB0ZXJtc2AgYXJlIG1pc3NpbmcgZnJvbSBhcmd1bWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5LnRlcm1zID0gQXJyYXkuaXNBcnJheShxdWVyeS50ZXJtcykgPyBxdWVyeS50ZXJtcyA6IFsgcXVlcnkudGVybXMgXTtcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGNvbnN0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgY29uc3QgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgY29uc3QgVG9wSGl0cyA9IHJlcXVpcmUoJy4uL2FnZy9Ub3BIaXRzJyk7XG5cbiAgICBjb25zdCBDb21tdW5pdHkgPSAgTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUb3BIaXRzXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZGVncmVlRmllbGQ6ICdwcm9wZXJ0aWVzLmRlZ3JlZSdcbiAgICAgICAgfSxcblxuICAgICAgICB0eXBlOiAnbWljcm8nLFxuXG4gICAgICAgIC8vIGV4dHJlbWUgbm90IHJlbGV2YW50IGZvciBtaWNyb1xuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAtSW5maW5pdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8uZ2V0KF8ubWluQnkoZGF0YSwgY29tbXVuaXR5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZ2V0KGNvbW11bml0eSwgdGhpcy5vcHRpb25zLmRlZ3JlZUZpZWxkKTtcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmRlZ3JlZUZpZWxkKSxcbiAgICAgICAgICAgICAgICBtYXg6IF8uZ2V0KF8ubWF4QnkoZGF0YSwgY29tbXVuaXR5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZ2V0KGNvbW11bml0eSwgdGhpcy5vcHRpb25zLmRlZ3JlZUZpZWxkKTtcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmRlZ3JlZUZpZWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21tdW5pdHk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgY29uc3QgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBjb25zdCBUaWxpbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9UaWxpbmcnKTtcblxuICAgIGNvbnN0IENvdW50ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmdcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAnY291bnQnLFxuXG4gICAgICAgIC8vIGV4dHJlbWUgbm90IHJlbGV2YW50IGZvciBjb3VudCB0aWxlXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXg6IC1JbmZpbml0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb3VudDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGxldCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgbGV0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgbGV0IFRpbGluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL1RpbGluZycpO1xuICAgIGxldCBDdXN0b21BZ2dzID0gcmVxdWlyZSgnLi4vYWdnL0N1c3RvbUFnZ3MnKTtcblxuICAgIGxldCBDdXN0b20gPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIEN1c3RvbUFnZ3NcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAnY3VzdG9tX3RpbGUnXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ3VzdG9tO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGNvbnN0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgY29uc3QgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgY29uc3QgRGF0ZUhpc3RvZ3JhbSA9IHJlcXVpcmUoJy4uL2FnZy9EYXRlSGlzdG9ncmFtJyk7XG4gICAgY29uc3QgSGlzdG9ncmFtID0gcmVxdWlyZSgnLi4vYWdnL0hpc3RvZ3JhbScpO1xuXG4gICAgY29uc3QgRnJlcXVlbmN5ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBEYXRlSGlzdG9ncmFtLFxuICAgICAgICAgICAgSGlzdG9ncmFtXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ2ZyZXF1ZW5jeScsXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRnJlcXVlbmN5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGNvbnN0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgY29uc3QgQmlubmluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL0Jpbm5pbmcnKTtcbiAgICBjb25zdCBNZXRyaWMgPSByZXF1aXJlKCcuLi9hZ2cvTWV0cmljJyk7XG5cbiAgICBjb25zdCBIZWF0bWFwID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBCaW5uaW5nLFxuICAgICAgICAgICAgLy8gYWdnc1xuICAgICAgICAgICAgTWV0cmljXG4gICAgICAgIF0sXG5cbiAgICAgICAgdHlwZTogJ2hlYXRtYXAnLFxuXG4gICAgICAgIGV4dHJhY3RFeHRyZW1hOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBiaW5zID0gbmV3IEZsb2F0NjRBcnJheShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBfLm1pbihiaW5zKSxcbiAgICAgICAgICAgICAgICBtYXg6IF8ubWF4KGJpbnMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBjb25zdCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGNvbnN0IEJpbm5pbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9CaW5uaW5nJyk7XG5cbiAgICBjb25zdCBNYWNybyA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgQmlubmluZ1xuICAgICAgICBdLFxuXG4gICAgICAgIHR5cGU6ICdtYWNybycsXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpbnMgPSBuZXcgRmxvYXQ2NEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKGJpbnMpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoYmlucylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYWNybztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IExpdmUgPSByZXF1aXJlKCcuLi9jb3JlL0xpdmUnKTtcbiAgICBjb25zdCBFbGFzdGljID0gcmVxdWlyZSgnLi4vcGFyYW0vRWxhc3RpYycpO1xuICAgIGNvbnN0IFRpbGluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL1RpbGluZycpO1xuICAgIGNvbnN0IFRvcEhpdHMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wSGl0cycpO1xuXG4gICAgY29uc3QgTWljcm8gPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRvcEhpdHNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAnbWljcm8nLFxuXG4gICAgICAgIC8vIGV4dHJlbWUgbm90IHJlbGV2YW50IGZvciBtaWNyb1xuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbjogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWF4OiAtSW5maW5pdHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTWljcm87XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgY29uc3QgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBjb25zdCBCaW5uaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vQmlubmluZycpO1xuICAgIGNvbnN0IFRvcEhpdHMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wSGl0cycpO1xuXG4gICAgY29uc3QgUHJldmlldyA9IExpdmUuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gcGFyYW1zXG4gICAgICAgICAgICBFbGFzdGljLFxuICAgICAgICAgICAgQmlubmluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRvcEhpdHNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAncHJldmlldycsXG5cbiAgICAgICAgLy8gZXh0cmVtZSBub3QgcmVsZXZhbnQgZm9yIHByZXZpZXdcbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByZXZpZXc7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgY29uc3QgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBjb25zdCBUaWxpbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9UaWxpbmcnKTtcbiAgICBjb25zdCBUb3BUZXJtcyA9IHJlcXVpcmUoJy4uL2FnZy9Ub3BUZXJtcycpO1xuICAgIGNvbnN0IEhpc3RvZ3JhbSA9IHJlcXVpcmUoJy4uL2FnZy9IaXN0b2dyYW0nKTtcbiAgICBjb25zdCBUb3BIaXRzID0gcmVxdWlyZSgnLi4vYWdnL1RvcEhpdHMnKTtcblxuICAgIGNvbnN0IFRvcENvdW50ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICBUb3BUZXJtcyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIEhpc3RvZ3JhbSxcbiAgICAgICAgICAgIFRvcEhpdHNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9wX2NvdW50J1xuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcENvdW50O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGNvbnN0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgY29uc3QgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgY29uc3QgVG9wVGVybXMgPSByZXF1aXJlKCcuLi9hZ2cvVG9wVGVybXMnKTtcbiAgICBjb25zdCBEYXRlSGlzdG9ncmFtID0gcmVxdWlyZSgnLi4vYWdnL0RhdGVIaXN0b2dyYW0nKTtcbiAgICBjb25zdCBIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvSGlzdG9ncmFtJyk7XG4gICAgY29uc3QgVG9wSGl0cyA9IHJlcXVpcmUoJy4uL2FnZy9Ub3BIaXRzJyk7XG5cbiAgICBjb25zdCBUb3BGcmVxdWVuY3kgPSBMaXZlLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAgICAgRWxhc3RpYyxcbiAgICAgICAgICAgIFRpbGluZyxcbiAgICAgICAgICAgIC8vIGFnZ3NcbiAgICAgICAgICAgIFRvcFRlcm1zLFxuICAgICAgICAgICAgRGF0ZUhpc3RvZ3JhbSxcbiAgICAgICAgICAgIEhpc3RvZ3JhbSxcbiAgICAgICAgICAgIFRvcEhpdHNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9wX2ZyZXF1ZW5jeScsXG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9wRnJlcXVlbmN5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGNvbnN0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgY29uc3QgQmlubmluZyA9IHJlcXVpcmUoJy4uL3BhcmFtL0Jpbm5pbmcnKTtcbiAgICBjb25zdCBUZXJtcyA9IHJlcXVpcmUoJy4uL2FnZy9UZXJtcycpO1xuXG4gICAgY29uc3QgVG9wVHJhaWxzID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBCaW5uaW5nLFxuICAgICAgICAgICAgLy8gYWdnc1xuICAgICAgICAgICAgVGVybXNcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9wX3RyYWlscycsXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heDogLUluZmluaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9wVHJhaWxzO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTGl2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvTGl2ZScpO1xuICAgIGNvbnN0IEVsYXN0aWMgPSByZXF1aXJlKCcuLi9wYXJhbS9FbGFzdGljJyk7XG4gICAgY29uc3QgVGlsaW5nID0gcmVxdWlyZSgnLi4vcGFyYW0vVGlsaW5nJyk7XG4gICAgY29uc3QgVGVybXNGaWx0ZXIgPSByZXF1aXJlKCcuLi9hZ2cvVGVybXNGaWx0ZXInKTtcbiAgICBjb25zdCBIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvSGlzdG9ncmFtJyk7XG5cbiAgICBjb25zdCBUb3BpY0NvdW50ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUZXJtc0ZpbHRlcixcbiAgICAgICAgICAgIEhpc3RvZ3JhbSxcbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9waWNfY291bnQnLFxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcGljQ291bnQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBMaXZlID0gcmVxdWlyZSgnLi4vY29yZS9MaXZlJyk7XG4gICAgY29uc3QgRWxhc3RpYyA9IHJlcXVpcmUoJy4uL3BhcmFtL0VsYXN0aWMnKTtcbiAgICBjb25zdCBUaWxpbmcgPSByZXF1aXJlKCcuLi9wYXJhbS9UaWxpbmcnKTtcbiAgICBjb25zdCBUZXJtc0ZpbHRlciA9IHJlcXVpcmUoJy4uL2FnZy9UZXJtc0ZpbHRlcicpO1xuICAgIGNvbnN0IERhdGVIaXN0b2dyYW0gPSByZXF1aXJlKCcuLi9hZ2cvRGF0ZUhpc3RvZ3JhbScpO1xuICAgIGNvbnN0IEhpc3RvZ3JhbSA9IHJlcXVpcmUoJy4uL2FnZy9IaXN0b2dyYW0nKTtcblxuICAgIGNvbnN0IFRvcGljRnJlcXVlbmN5ID0gTGl2ZS5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBwYXJhbXNcbiAgICAgICAgICAgIEVsYXN0aWMsXG4gICAgICAgICAgICBUaWxpbmcsXG4gICAgICAgICAgICAvLyBhZ2dzXG4gICAgICAgICAgICBUZXJtc0ZpbHRlcixcbiAgICAgICAgICAgIERhdGVIaXN0b2dyYW0sXG4gICAgICAgICAgICBIaXN0b2dyYW1cbiAgICAgICAgXSxcblxuICAgICAgICB0eXBlOiAndG9waWNfZnJlcXVlbmN5J1xuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcGljRnJlcXVlbmN5O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgcmVzZXRNb3VzZUN1cnNvclN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0aGlzIGJvdW5kIE9OQ0UgcGVyIG1hcFxuICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikuY3NzKCdjdXJzb3InLCAnJyk7XG4gICAgfTtcblxuICAgIGNvbnN0IE1hcCA9IEwuTWFwLmV4dGVuZCh7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBMLk1hcC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgcmVzZXRNb3VzZUN1cnNvclN0eWxlLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIGNhcnRlc2lhbiBwcm9qZWN0aW9uIGluICgwLDApLCAoMjU2LCAyNTYpIGNvb3JkaW5hdGUgc3BhY2VcbiAgICBMLlByb2plY3Rpb24uR3JhcGggPSB7XG5cbiAgICAgICAgcHJvamVjdDogZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEwuUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMLkxhdExuZyhwb2ludC55LCBwb2ludC54KTtcbiAgICAgICAgfSxcblxuICAgICAgICBib3VuZHM6IEwuYm91bmRzKFswLCAwXSwgWzI1NiwgMjU2XSlcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMLlByb2plY3Rpb24uR3JhcGg7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBET00gPSByZXF1aXJlKCcuL0RPTScpO1xuXG4gICAgY29uc3QgQ2FudmFzID0gRE9NLmV4dGVuZCh7XG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgRE9NLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICAvLyBoYW5kbGVyc1xuICAgICAgICAgICAgbWFwLm9uKCdjbGljaycsIHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZXJzXG4gICAgICAgICAgICBtYXAub2ZmKCdjbGljaycsIHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0aGlzKTtcbiAgICAgICAgICAgIERPTS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAgICAgICAgICAgIHRpbGUuc3R5bGVbJ3BvaW50ZXItZXZlbnRzJ10gPSAnYWxsJztcbiAgICAgICAgICAgIHRpbGUud2lkdGggPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICB0aWxlLmhlaWdodCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RUaWxlKGNvb3JkcywgdGlsZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgdGlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyVGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB0aWxlLmVsLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aWxlU2l6ZSwgdGlsZVNpemUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBCYXNlID0gcmVxdWlyZSgnLi4vLi4vbGF5ZXIvY29yZS9CYXNlJyk7XG5cbiAgICBjb25zdCBET00gPSBCYXNlLmV4dGVuZCh7XG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgTC5HcmlkTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIG1hcC5vbignem9vbXN0YXJ0JywgdGhpcy5jbGVhckV4dHJlbWEsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMub25UaWxlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NhY2hlbG9hZCcsIHRoaXMub25DYWNoZUxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGVoaXQnLCB0aGlzLm9uQ2FjaGVIaXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignY2FjaGV1bmxvYWQnLCB0aGlzLm9uQ2FjaGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbignZXh0cmVtYWNoYW5nZScsIHRoaXMub25FeHRyZW1hQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBMLkdyaWRMYXllci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5jbGVhckV4dHJlbWEsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ3RpbGV1bmxvYWQnLCB0aGlzLm9uVGlsZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGVsb2FkJywgdGhpcy5vbkNhY2hlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGVoaXQnLCB0aGlzLm9uQ2FjaGVIaXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NhY2hldW5sb2FkJywgdGhpcy5vbkNhY2hlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdleHRyZW1hY2hhbmdlJywgdGhpcy5vbkV4dHJlbWFDaGFuZ2UsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVIaXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBldmVudC50aWxlO1xuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgLy8gZGF0YSBleGlzdHMsIHJlbmRlciBvbmx5IHRoaXMgdGlsZVxuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGUsIGNhY2hlZC5kYXRhLCBjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVMb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgLy8gc2FtZSBleHRyZW1hLCB3ZSBhcmUgZ29vZCB0byByZW5kZXIgdGhlIHRpbGVzLiBJblxuICAgICAgICAgICAgLy8gdGhlIGNhc2Ugb2YgYSBtYXAgd2l0aCB3cmFwYXJvdW5kLCB3ZSBtYXkgaGF2ZVxuICAgICAgICAgICAgLy8gbXVsdGlwbGUgdGlsZXMgZGVwZW5kZW50IG9uIHRoZSByZXNwb25zZSwgc28gaXRlcmF0ZVxuICAgICAgICAgICAgLy8gb3ZlciBlYWNoIHRpbGUgYW5kIGRyYXcgaXQuXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGV2ZW50LmNvb3JkcztcbiAgICAgICAgICAgIGlmIChjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgIF8uZm9ySW4oY2FjaGVkLnRpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGUsIGNhY2hlZC5kYXRhLCBjb29yZHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXh0cmVtYUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZWRyYXcgYWxsIHRpbGVzXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX2NhY2hlLCBjYWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIF8uZm9ySW4oY2FjaGVkLnRpbGVzLCAodGlsZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZEZyb21DYWNoZUtleShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZVVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRE9NO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgRE9NID0gcmVxdWlyZSgnLi9ET00nKTtcblxuICAgIGNvbnN0IEhUTUwgPSBET00uZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB6b29tQW5pbWF0aW9uOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIERPTS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgLy8gaGFuZGxlcnNcbiAgICAgICAgICAgIG1hcC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tc3RhcnQnLCB0aGlzLmNsZWFyVGlsZXMsIHRoaXMpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLm9uKCdtb3VzZW1vdmUnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5vbignbW91c2VvdmVyJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU92ZXIoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikub24oJ21vdXNlb3V0JywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU91dChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGVyc1xuICAgICAgICAgICAgbWFwLm9mZignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5jbGVhclRpbGVzLCB0aGlzKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5vZmYoJ21vdXNlbW92ZScpO1xuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLm9mZignbW91c2VvdmVyJyk7XG4gICAgICAgICAgICAkKHRoaXMuX2NvbnRhaW5lcikub2ZmKCdtb3VzZW91dCcpO1xuICAgICAgICAgICAgRE9NLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNjYWxlZCBsZXZlbFxuICAgICAgICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlIGxlYWZsZXQtaHRtbC10aWxlJyk7XG4gICAgICAgICAgICB0aWxlLndpZHRoID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICAgICAgICAgICAgdGlsZS5oZWlnaHQgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZShjb29yZHMsIHRpbGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIHRpbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBCYXNlID0gcmVxdWlyZSgnLi4vLi4vbGF5ZXIvY29yZS9CYXNlJyk7XG5cbiAgICBjb25zdCBOT19PUCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBjb25zdCBPdmVybGF5ID0gQmFzZS5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLm9uVGlsZVVubG9hZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjYWNoZWxvYWQnLCB0aGlzLm9uQ2FjaGVMb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NhY2hlaGl0JywgdGhpcy5vbkNhY2hlSGl0LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2NhY2hldW5sb2FkJywgdGhpcy5vbkNhY2hlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2V4dHJlbWFjaGFuZ2UnLCB0aGlzLm9uRXh0cmVtYUNoYW5nZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl90aWxlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5faW5pdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgLy8gYWRkIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICBtYXAub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldFZpZXcoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBsYXllclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdGlsZVpvb20gPSBudWxsO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLm9mZigndGlsZXVubG9hZCcsIHRoaXMub25UaWxlVW5sb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjYWNoZWxvYWQnLCB0aGlzLm9uQ2FjaGVMb2FkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjYWNoZWhpdCcsIHRoaXMub25DYWNoZUhpdCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY2FjaGV1bmxvYWQnLCB0aGlzLm9uQ2FjaGVVbmxvYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2V4dHJlbWFjaGFuZ2UnLCB0aGlzLm9uRXh0cmVtYUNoYW5nZSwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKCdjbGljaycsIHRoaXMub25DbGljaywgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOby1vcCB0aGVzZSBmdW5jdGlvbnNcbiAgICAgICAgX3VwZGF0ZU9wYWNpdHk6IE5PX09QLFxuICAgICAgICBfaW5pdFRpbGU6IE5PX09QLFxuICAgICAgICBfdXBkYXRlTGV2ZWxzOiBOT19PUCxcbiAgICAgICAgX3JlbW92ZVRpbGVzQXRab29tOiBOT19PUCxcbiAgICAgICAgX3NldFpvb21UcmFuc2Zvcm1zOiBOT19PUCxcblxuICAgICAgICBfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc05hbWUgKz0gJ2xlYWZsZXQtbGF5ZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuICAgICAgICAgICAgdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcHJ1bmVUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuICAgICAgICAgICAgICAgIHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl90aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCAodGlsZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aWxlLnJldGFpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF8uZm9ySW4odGhpcy5fdGlsZXMsICh0aWxlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICAgICAgICAgICAgdGhpcy5fdGlsZVpvb20gPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRWaWV3OiBmdW5jdGlvbihjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuICAgICAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcbiAgICAgICAgICAgIGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEdyaWQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoY2VudGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFub1BydW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BydW5lVGlsZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRab29tVHJhbnNmb3JtKGNlbnRlciwgem9vbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uKGNlbnRlciwgem9vbSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBjdXJyZW50Wm9vbSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgY29uc3Qgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGN1cnJlbnRDZW50ZXIsIHpvb20pO1xuICAgICAgICAgICAgY29uc3QgZGVzdENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QoY2VudGVyLCB6b29tKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQocG9zaXRpb24pLmFkZCh2aWV3SGFsZikuc3VidHJhY3QoY2VudGVyT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChMLkJyb3dzZXIuYW55M2QpIHtcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG4gICAgICAgICAgICAgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG4gICAgICAgICAgICAgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFtdO1xuXG4gICAgICAgICAgICBfLmZvckluKHRoaXMuX3RpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICB0aWxlLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgbWFwJ3MsIGNvbnN0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gICAgICAgICAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGlsZShxdWV1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW1vdmVUaWxlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG4gICAgICAgICAgICAvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuICAgICAgICAgICAgICAgIGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgdGlsZSA9IHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGUoY29vcmRzLCB0aWxlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCB0aWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZFRpbGU6IGZ1bmN0aW9uKGNvb3Jkcykge1xuXG4gICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKGNvb3JkcywgTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzW2tleV0gPSB0aWxlO1xuXG4gICAgICAgICAgICAvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdGlsZVJlYWR5OiBmdW5jdGlvbihjb29yZHMsIGVyciwgdGlsZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGlsZSBsb2FkZWRcbiAgICAgICAgICAgIHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aWxlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcnVuZVRpbGVzKCk7XG5cbiAgICAgICAgICAgIC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG4gICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICAgICAgdGlsZTogdGlsZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gQGV2ZW50IGxvYWQ6IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgICAgICAgICAgICAgaWYgKEwuQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVIaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlTG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXh0cmVtYUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVVbmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBlc3BlciA9IHJlcXVpcmUoJ2VzcGVyJyk7XG4gICAgY29uc3QgT3ZlcmxheSA9IHJlcXVpcmUoJy4vT3ZlcmxheScpO1xuXG4gICAgY29uc3QgVElMRV9TSVpFID0gMjU2O1xuXG4gICAgY29uc3QgV2ViR0wgPSBPdmVybGF5LmV4dGVuZCh7XG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgT3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tc3RhcnQnLCB0aGlzLm9uWm9vbVN0YXJ0LCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vbignem9vbWVuZCcsIHRoaXMub25ab29tRW5kLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLm9uWm9vbVN0YXJ0LCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLm9uWm9vbUVuZCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25ab29tU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhckV4dHJlbWEoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25ab29tRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgT3ZlcmxheS5wcm90b3R5cGUuX2luaXRDb250YWluZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0R0woKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25XZWJHTEluaXQ6IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGRvbmUobnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRHTDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsID0gZXNwZXIuV2ViR0xDb250ZXh0LmdldCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pc3NpbmcgY29udGV4dFxuICAgICAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdVbmFibGUgdG8gYWNxdWlyZSBhIFdlYkdMIGNvbnRleHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5pdCB0aGUgd2ViZ2wgc3RhdGVcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICAvLyBnZXQgbWFwIHNpemVcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgLy8gc2V0IHZpZXdwb3J0IHNpemVcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbmV3IGVzcGVyLlZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZS54ICogZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemUueSAqIGRldmljZVBpeGVsUmF0aW9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgICAgICB0aGlzLl9nbC5jYW52YXMuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5fZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gICAgICAgICAgICAvLyB3ZWJnbCBpbml0IGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLm9uV2ViR0xJbml0KGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyByZWFkeVxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBkcmF3IGxvb3BcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUcmFuc2xhdGlvbk1hdHJpeDogZnVuY3Rpb24oeCwgeSwgeikge1xuICAgICAgICAgICAgY29uc3QgbWF0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgICAgICBtYXRbMF0gPSAxO1xuICAgICAgICAgICAgbWF0WzFdID0gMDtcbiAgICAgICAgICAgIG1hdFsyXSA9IDA7XG4gICAgICAgICAgICBtYXRbM10gPSAwO1xuICAgICAgICAgICAgbWF0WzRdID0gMDtcbiAgICAgICAgICAgIG1hdFs1XSA9IDE7XG4gICAgICAgICAgICBtYXRbNl0gPSAwO1xuICAgICAgICAgICAgbWF0WzddID0gMDtcbiAgICAgICAgICAgIG1hdFs4XSA9IDA7XG4gICAgICAgICAgICBtYXRbOV0gPSAwO1xuICAgICAgICAgICAgbWF0WzEwXSA9IDE7XG4gICAgICAgICAgICBtYXRbMTFdID0gMDtcbiAgICAgICAgICAgIG1hdFsxMl0gPSB4O1xuICAgICAgICAgICAgbWF0WzEzXSA9IHk7XG4gICAgICAgICAgICBtYXRbMTRdID0gejtcbiAgICAgICAgICAgIG1hdFsxNV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG1hdDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPcnRob01hdHJpeDogZnVuY3Rpb24obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICAgICAgbWF0WzBdID0gMiAvIChyaWdodCAtIGxlZnQpO1xuICAgICAgICAgICAgbWF0WzFdID0gMDtcbiAgICAgICAgICAgIG1hdFsyXSA9IDA7XG4gICAgICAgICAgICBtYXRbM10gPSAwO1xuICAgICAgICAgICAgbWF0WzRdID0gMDtcbiAgICAgICAgICAgIG1hdFs1XSA9IDIgLyAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgICAgIG1hdFs2XSA9IDA7XG4gICAgICAgICAgICBtYXRbN10gPSAwO1xuICAgICAgICAgICAgbWF0WzhdID0gMDtcbiAgICAgICAgICAgIG1hdFs5XSA9IDA7XG4gICAgICAgICAgICBtYXRbMTBdID0gLTIgLyAoZmFyIC0gbmVhcik7XG4gICAgICAgICAgICBtYXRbMTFdID0gMDtcbiAgICAgICAgICAgIG1hdFsxMl0gPSAtKChyaWdodCArIGxlZnQpIC8gKHJpZ2h0IC0gbGVmdCkpO1xuICAgICAgICAgICAgbWF0WzEzXSA9IC0oKHRvcCArIGJvdHRvbSkgLyAodG9wIC0gYm90dG9tKSk7XG4gICAgICAgICAgICBtYXRbMTRdID0gLSgoZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcikpO1xuICAgICAgICAgICAgbWF0WzE1XSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbWF0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFdyYXBBcm91bmRPZmZzZXQ6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucG93KDIsIHRoaXMuX21hcC5nZXRab29tKCkpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG1vZGVsIG1hdHJpeFxuICAgICAgICAgICAgY29uc3QgeFdyYXAgPSBNYXRoLmZsb29yKGNvb3Jkcy54IC8gc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCB5V3JhcCA9IE1hdGguZmxvb3IoY29vcmRzLnkgLyBzaXplKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2l6ZSAqIFRJTEVfU0laRSAqIHhXcmFwLFxuICAgICAgICAgICAgICAgIHNpemUgKiBUSUxFX1NJWkUgKiB5V3JhcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3J0aG9NYXRyaXgoXG4gICAgICAgICAgICAgICAgMCwgc2l6ZS54LFxuICAgICAgICAgICAgICAgIDAsIHNpemUueSxcbiAgICAgICAgICAgICAgICAtMSwgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Vmlld09mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRoaXMuX21hcC5nZXRab29tKCkpICogVElMRV9TSVpFO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBib3VuZHMubWluLngsXG4gICAgICAgICAgICAgICAgZGltIC0gYm91bmRzLm1heC55XG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRpbGVPZmZzZXQ6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgY29uc3QgZGltID0gTWF0aC5wb3coMiwgY29vcmRzLnopO1xuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkcy54O1xuICAgICAgICAgICAgY29uc3QgeSA9ICh0aGlzLm9wdGlvbnMudG1zKSA/IGNvb3Jkcy55IDogZGltIC0gY29vcmRzLnkgLSAxO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB4ICogVElMRV9TSVpFLFxuICAgICAgICAgICAgICAgIHkgKiBUSUxFX1NJWkVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Bvc2l0aW9uQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgLy8gc2V0IHZpZXdwb3J0IHNpemVcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0LnJlc2l6ZShcbiAgICAgICAgICAgICAgICBzaXplLnggKiBkZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIHNpemUueSAqIGRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgICAgICB0aGlzLl9nbC5jYW52YXMuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5fZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gICAgICAgICAgICAvLyByZS1wb3NpdGlvbiBjb250YWluZXJcbiAgICAgICAgICAgIGNvbnN0IHRvcExlZnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoWzAsIDBdKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXAgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZS1wb3NpdGlvbiBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1pvb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIHRoZSBjb250YWluZXIgYW5kIHJlc2l6ZSB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fZHJhdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpbXBsZW1lbnQgdGhpc1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gV2ViR0w7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBsZXQgQ29yZSA9IHtcbiAgICAgICAgSFRNTDogcmVxdWlyZSgnLi9jb3JlL0hUTUwnKSxcbiAgICAgICAgV2ViR0w6IHJlcXVpcmUoJy4vY29yZS9XZWJHTCcpLFxuICAgICAgICBDYW52YXM6IHJlcXVpcmUoJy4vY29yZS9DYW52YXMnKVxuICAgIH07XG5cbiAgICAvLyBjYW52YXMgcmVuZGVyZXJzXG4gICAgbGV0IENhbnZhcyA9IHtcbiAgICAgICAgSGVhdG1hcDogcmVxdWlyZSgnLi90eXBlL2NhbnZhcy9IZWF0bWFwJyksXG4gICAgICAgIFRvcFRyYWlsczogcmVxdWlyZSgnLi90eXBlL2NhbnZhcy9Ub3BUcmFpbHMnKSxcbiAgICAgICAgUHJldmlldzogcmVxdWlyZSgnLi90eXBlL2NhbnZhcy9QcmV2aWV3JylcbiAgICB9O1xuXG4gICAgLy8gaHRtbCByZW5kZXJlcnNcbiAgICBsZXQgSFRNTCA9IHtcbiAgICAgICAgRW1wdHk6IHJlcXVpcmUoJy4vdHlwZS9odG1sL0VtcHR5JyksXG4gICAgICAgIEhlYXRtYXA6IHJlcXVpcmUoJy4vdHlwZS9odG1sL0hlYXRtYXAnKSxcbiAgICAgICAgUmluZzogcmVxdWlyZSgnLi90eXBlL2h0bWwvUmluZycpLFxuICAgICAgICBXb3JkQ2xvdWQ6IHJlcXVpcmUoJy4vdHlwZS9odG1sL1dvcmRDbG91ZCcpLFxuICAgICAgICBXb3JkSGlzdG9ncmFtOiByZXF1aXJlKCcuL3R5cGUvaHRtbC9Xb3JkSGlzdG9ncmFtJyksXG4gICAgICAgIENvbW11bml0eUxhYmVsOiByZXF1aXJlKCcuL3R5cGUvaHRtbC9Db21tdW5pdHlMYWJlbCcpXG4gICAgfTtcblxuICAgIC8vIHdlYmdsIHJlbmRlcmVyc1xuICAgIGxldCBXZWJHTCA9IHtcbiAgICAgICAgSGVhdG1hcDogcmVxdWlyZSgnLi90eXBlL3dlYmdsL0hlYXRtYXAnKSxcbiAgICAgICAgUG9pbnQ6IHJlcXVpcmUoJy4vdHlwZS93ZWJnbC9Qb2ludCcpLFxuICAgICAgICBDbHVzdGVyOiByZXF1aXJlKCcuL3R5cGUvd2ViZ2wvQ2x1c3RlcicpLFxuICAgICAgICBDb21tdW5pdHk6IHJlcXVpcmUoJy4vdHlwZS93ZWJnbC9Db21tdW5pdHknKVxuICAgIH07XG5cbiAgICAvLyBwZW5kaW5nIGxheWVyIHJlbmRlcmVyc1xuICAgIGxldCBQZW5kaW5nID0ge1xuICAgICAgICBEZWxheWVkQmxpbms6IHJlcXVpcmUoJy4vdHlwZS9wZW5kaW5nL0RlbGF5ZWRCbGluaycpLFxuICAgICAgICBEZWxheWVkU3BpbjogcmVxdWlyZSgnLi90eXBlL3BlbmRpbmcvRGVsYXllZFNwaW4nKSxcbiAgICAgICAgQmxpbms6IHJlcXVpcmUoJy4vdHlwZS9wZW5kaW5nL0JsaW5rJyksXG4gICAgICAgIFNwaW46IHJlcXVpcmUoJy4vdHlwZS9wZW5kaW5nL1NwaW4nKSxcbiAgICAgICAgQmxpbmtTcGluOiByZXF1aXJlKCcuL3R5cGUvcGVuZGluZy9CbGlua1NwaW4nKVxuICAgIH07XG5cbiAgICAvLyBwZW5kaW5nIGxheWVyIHJlbmRlcmVyc1xuICAgIGxldCBEZWJ1ZyA9IHtcbiAgICAgICAgQ29vcmQ6IHJlcXVpcmUoJy4vdHlwZS9kZWJ1Zy9Db29yZCcpXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBDb3JlOiBDb3JlLFxuICAgICAgICBIVE1MOiBIVE1MLFxuICAgICAgICBDYW52YXM6IENhbnZhcyxcbiAgICAgICAgV2ViR0w6IFdlYkdMLFxuICAgICAgICBEZWJ1ZzogRGVidWcsXG4gICAgICAgIFBlbmRpbmc6IFBlbmRpbmdcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgTlVNX0dSQURJRU5UX1NURVBTID0gMTAwO1xuXG4gICAgZnVuY3Rpb24gcmdiMmxhYihyZ2IpIHtcbiAgICAgICAgY29uc3QgciA9IHJnYlswXSA+IDAuMDQwNDUgPyBNYXRoLnBvdygocmdiWzBdICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByZ2JbMF0gLyAxMi45MjtcbiAgICAgICAgY29uc3QgZyA9IHJnYlsxXSA+IDAuMDQwNDUgPyBNYXRoLnBvdygocmdiWzFdICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByZ2JbMV0gLyAxMi45MjtcbiAgICAgICAgY29uc3QgYiA9IHJnYlsyXSA+IDAuMDQwNDUgPyBNYXRoLnBvdygocmdiWzJdICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByZ2JbMl0gLyAxMi45MjtcbiAgICAgICAgLy9PYnNlcnZlci4gPSAywrAsIElsbHVtaW5hbnQgPSBENjVcbiAgICAgICAgbGV0IHggPSByICogMC40MTI0NTY0ICsgZyAqIDAuMzU3NTc2MSArIGIgKiAwLjE4MDQzNzU7XG4gICAgICAgIGxldCB5ID0gciAqIDAuMjEyNjcyOSArIGcgKiAwLjcxNTE1MjIgKyBiICogMC4wNzIxNzUwO1xuICAgICAgICBsZXQgeiA9IHIgKiAwLjAxOTMzMzkgKyBnICogMC4xMTkxOTIwICsgYiAqIDAuOTUwMzA0MTtcbiAgICAgICAgeCA9IHggLyAwLjk1MDQ3OyAvLyBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50PSBENjVcbiAgICAgICAgeSA9IHkgLyAxLjAwMDAwO1xuICAgICAgICB6ID0geiAvIDEuMDg4ODM7XG4gICAgICAgIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcwMzcgKiB4KSArICgxNiAvIDExNik7XG4gICAgICAgIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcwMzcgKiB5KSArICgxNiAvIDExNik7XG4gICAgICAgIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcwMzcgKiB6KSArICgxNiAvIDExNik7XG4gICAgICAgIHJldHVybiBbKDExNiAqIHkpIC0gMTYsXG4gICAgICAgICAgICA1MDAgKiAoeCAtIHkpLFxuICAgICAgICAgICAgMjAwICogKHkgLSB6KSxcbiAgICAgICAgICAgIHJnYlszXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFiMnJnYihsYWIpIHtcbiAgICAgICAgbGV0IHkgPSAobGFiWzBdICsgMTYpIC8gMTE2O1xuICAgICAgICBsZXQgeCA9IHkgKyBsYWJbMV0gLyA1MDA7XG4gICAgICAgIGxldCB6ID0geSAtIGxhYlsyXSAvIDIwMDtcbiAgICAgICAgeCA9IHggPiAwLjIwNjg5MzAzNCA/IHggKiB4ICogeCA6ICh4IC0gNCAvIDI5KSAvIDcuNzg3MDM3O1xuICAgICAgICB5ID0geSA+IDAuMjA2ODkzMDM0ID8geSAqIHkgKiB5IDogKHkgLSA0IC8gMjkpIC8gNy43ODcwMzc7XG4gICAgICAgIHogPSB6ID4gMC4yMDY4OTMwMzQgPyB6ICogeiAqIHogOiAoeiAtIDQgLyAyOSkgLyA3Ljc4NzAzNztcbiAgICAgICAgeCA9IHggKiAwLjk1MDQ3OyAvLyBPYnNlcnZlcj0gMsKwLCBJbGx1bWluYW50PSBENjVcbiAgICAgICAgeSA9IHkgKiAxLjAwMDAwO1xuICAgICAgICB6ID0geiAqIDEuMDg4ODM7XG4gICAgICAgIGxldCByID0geCAqIDMuMjQwNDU0MiArIHkgKiAtMS41MzcxMzg1ICsgeiAqIC0wLjQ5ODUzMTQ7XG4gICAgICAgIGxldCBnID0geCAqIC0wLjk2OTI2NjAgKyB5ICogMS44NzYwMTA4ICsgeiAqIDAuMDQxNTU2MDtcbiAgICAgICAgbGV0IGIgPSB4ICogMC4wNTU2NDM0ICsgeSAqIC0wLjIwNDAyNTkgKyB6ICogMS4wNTcyMjUyO1xuICAgICAgICByID0gciA+IDAuMDAzMDQgPyAxLjA1NSAqIE1hdGgucG93KHIsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIHI7XG4gICAgICAgIGcgPSBnID4gMC4wMDMwNCA/IDEuMDU1ICogTWF0aC5wb3coZywgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogZztcbiAgICAgICAgYiA9IGIgPiAwLjAwMzA0ID8gMS4wNTUgKiBNYXRoLnBvdyhiLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBiO1xuICAgICAgICByZXR1cm4gW01hdGgubWF4KE1hdGgubWluKHIsIDEpLCAwKSwgTWF0aC5tYXgoTWF0aC5taW4oZywgMSksIDApLCBNYXRoLm1heChNYXRoLm1pbihiLCAxKSwgMCksIGxhYlszXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYzEsIGMyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAoYzFbMF0gLSBjMlswXSkgKiAoYzFbMF0gLSBjMlswXSkgK1xuICAgICAgICAgICAgKGMxWzFdIC0gYzJbMV0pICogKGMxWzFdIC0gYzJbMV0pICtcbiAgICAgICAgICAgIChjMVsyXSAtIGMyWzJdKSAqIChjMVsyXSAtIGMyWzJdKSArXG4gICAgICAgICAgICAoYzFbM10gLSBjMlszXSkgKiAoYzFbM10gLSBjMlszXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1aWxkRmxhdExvb2t1cFRhYmxlID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlVNX0dSQURJRU5UX1NURVBTOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNvbG9yWzBdKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNvbG9yWzFdKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNvbG9yWzJdKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNvbG9yWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1c2luZyBldmVuIHBlcmNlcHR1YWwgZGlzdGFuY2UgYW5kIGludGVycG9sYXRpb24gaW4gQ0lFIEwqYSpiKiBzcGFjZVxuICAgIGNvbnN0IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9ycykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoTlVNX0dSQURJRU5UX1NURVBTICogNCAqIDQpO1xuICAgICAgICBjb25zdCBvdXRwdXRHcmFkaWVudCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlcHR1YWwgc3ByZWFkIGluIEwqYSpiKiBzcGFjZVxuICAgICAgICBjb25zdCBsYWJzID0gXy5tYXAoYmFzZUNvbG9ycywgY29sb3IgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJnYjJsYWIoW2NvbG9yWzBdIC8gMjU1LCBjb2xvclsxXSAvIDI1NSwgY29sb3JbMl0gLyAyNTUsIGNvbG9yWzNdIC8gMjU1XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZGlzdGFuY2VzID0gXy5tYXAobGFicywgKGNvbG9yLCBpbmRleCwgY29sb3JzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAwID8gZGlzdGFuY2UoY29sb3IsIGNvbG9yc1tpbmRleCAtIDFdKSA6IDA7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgY3VtdWxhdGl2ZSBkaXN0YW5jZXMgaW4gWzAsMV1cbiAgICAgICAgY29uc3QgdG90YWxEaXN0YW5jZSA9IF8ucmVkdWNlKGRpc3RhbmNlcywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGRpc3RhbmNlcyA9IF8ubWFwKGRpc3RhbmNlcywgZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZCAvIHRvdGFsRGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZGlzdGFuY2VUcmF2ZXJzZWQgPSAwO1xuICAgICAgICBsZXQga2V5ID0gMDtcbiAgICAgICAgbGV0IHByb2dyZXNzO1xuICAgICAgICBsZXQgc3RlcFByb2dyZXNzO1xuICAgICAgICBsZXQgcmdiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9HUkFESUVOVF9TVEVQUzsgaSsrKSB7XG4gICAgICAgICAgICBwcm9ncmVzcyA9IGkgLyAoTlVNX0dSQURJRU5UX1NURVBTIC0gMSk7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPiBkaXN0YW5jZVRyYXZlcnNlZCArIGRpc3RhbmNlc1trZXkgKyAxXSAmJiBrZXkgKyAxIDwgbGFicy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ICs9IDE7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VUcmF2ZXJzZWQgKz0gZGlzdGFuY2VzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGVwUHJvZ3Jlc3MgPSAocHJvZ3Jlc3MgLSBkaXN0YW5jZVRyYXZlcnNlZCkgLyBkaXN0YW5jZXNba2V5ICsgMV07XG4gICAgICAgICAgICByZ2IgPSBsYWIycmdiKFtcbiAgICAgICAgICAgICAgICBsYWJzW2tleV1bMF0gKyAobGFic1trZXkgKyAxXVswXSAtIGxhYnNba2V5XVswXSkgKiBzdGVwUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGFic1trZXldWzFdICsgKGxhYnNba2V5ICsgMV1bMV0gLSBsYWJzW2tleV1bMV0pICogc3RlcFByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGxhYnNba2V5XVsyXSArIChsYWJzW2tleSArIDFdWzJdIC0gbGFic1trZXldWzJdKSAqIHN0ZXBQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBsYWJzW2tleV1bM10gKyAobGFic1trZXkgKyAxXVszXSAtIGxhYnNba2V5XVszXSkgKiBzdGVwUHJvZ3Jlc3NcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgb3V0cHV0R3JhZGllbnRbaSAqIDRdID0gcmdiWzBdO1xuICAgICAgICAgICAgb3V0cHV0R3JhZGllbnRbaSAqIDQgKyAxXSA9IHJnYlsxXTtcbiAgICAgICAgICAgIG91dHB1dEdyYWRpZW50W2kgKiA0ICsgMl0gPSByZ2JbMl07XG4gICAgICAgICAgICBvdXRwdXRHcmFkaWVudFtpICogNCArIDNdID0gcmdiWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRHcmFkaWVudDtcbiAgICB9O1xuXG4gICAgY29uc3QgQ09PTCA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4MDQsIDB4MjAsIDB4NDAsIDB4NTBdLFxuICAgICAgICBbMHgwOCwgMHg0MCwgMHg4MSwgMHg3Zl0sXG4gICAgICAgIFsweDA4LCAweDY4LCAweGFjLCAweGZmXSxcbiAgICAgICAgWzB4MmIsIDB4OGMsIDB4YmUsIDB4ZmZdLFxuICAgICAgICBbMHg0ZSwgMHhiMywgMHhkMywgMHhmZl0sXG4gICAgICAgIFsweDdiLCAweGNjLCAweGM0LCAweGZmXSxcbiAgICAgICAgWzB4YTgsIDB4ZGQsIDB4YjUsIDB4ZmZdLFxuICAgICAgICBbMHhjYywgMHhlYiwgMHhjNSwgMHhmZl0sXG4gICAgICAgIFsweGUwLCAweGYzLCAweGRiLCAweGZmXSxcbiAgICAgICAgWzB4ZjcsIDB4ZmMsIDB4ZjAsIDB4ZmZdXG4gICAgXSk7XG5cbiAgICBjb25zdCBIT1QgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsweDQwLCAweDAwLCAweDEzLCAweDUwXSxcbiAgICAgICAgWzB4ODAsIDB4MDAsIDB4MjYsIDB4N2ZdLFxuICAgICAgICBbMHhiZCwgMHgwMCwgMHgyNiwgMHhmZl0sXG4gICAgICAgIFsweGUzLCAweDFhLCAweDFjLCAweGZmXSxcbiAgICAgICAgWzB4ZmMsIDB4NGUsIDB4MmEsIDB4ZmZdLFxuICAgICAgICBbMHhmZCwgMHg4ZCwgMHgzYywgMHhmZl0sXG4gICAgICAgIFsweGZlLCAweGIyLCAweDRjLCAweGZmXSxcbiAgICAgICAgWzB4ZmUsIDB4ZDksIDB4NzYsIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhlZCwgMHhhMCwgMHhmZl1cbiAgICBdKTtcblxuICAgIGNvbnN0IFZFUkRBTlQgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsweDAwLCAweDQwLCAweDI2LCAweDUwXSxcbiAgICAgICAgWzB4MDAsIDB4NWEsIDB4MzIsIDB4N2ZdLFxuICAgICAgICBbMHgyMywgMHg4NCwgMHg0MywgMHhmZl0sXG4gICAgICAgIFsweDQxLCAweGFiLCAweDVkLCAweGZmXSxcbiAgICAgICAgWzB4NzgsIDB4YzYsIDB4NzksIDB4ZmZdLFxuICAgICAgICBbMHhhZCwgMHhkZCwgMHg4ZSwgMHhmZl0sXG4gICAgICAgIFsweGQ5LCAweGYwLCAweGEzLCAweGZmXSxcbiAgICAgICAgWzB4ZjcsIDB4ZmMsIDB4YjksIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhmZiwgMHhlNSwgMHhmZl1cbiAgICBdKTtcblxuICAgIGNvbnN0IFNQRUNUUkFMID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHgyNiwgMHgxYSwgMHg0MCwgMHg1MF0sXG4gICAgICAgIFsweDQ0LCAweDJmLCAweDcyLCAweDdmXSxcbiAgICAgICAgWzB4ZTEsIDB4MmIsIDB4MDIsIDB4ZmZdLFxuICAgICAgICBbMHgwMiwgMHhkYywgMHgwMSwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGQyLCAweDAyLCAweGZmXSxcbiAgICAgICAgWzB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZdXG4gICAgXSk7XG5cbiAgICBjb25zdCBURU1QRVJBVFVSRSA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWzB4MDAsIDB4MTYsIDB4NDAsIDB4NTBdLFxuICAgICAgICBbMHgwMCwgMHgzOSwgMHg2NiwgMHg3Zl0sXG4gICAgICAgIFsweDMxLCAweDNkLCAweDY2LCAweGZmXSxcbiAgICAgICAgWzB4ZTEsIDB4MmIsIDB4MDIsIDB4ZmZdLFxuICAgICAgICBbMHhmZiwgMHhkMiwgMHgwMiwgMHhmZl0sXG4gICAgICAgIFsweGZmLCAweGZmLCAweGZmLCAweGZmXVxuICAgIF0pO1xuXG4gICAgY29uc3QgR1JFWVNDQUxFID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHgwMCwgMHgwMCwgMHgwMCwgMHg3Zl0sXG4gICAgICAgIFsweDQwLCAweDQwLCAweDQwLCAweGZmXSxcbiAgICAgICAgWzB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZdXG4gICAgXSk7XG5cbiAgICBjb25zdCBQT0xBUl9IT1QgPSBidWlsZFBlcmNlcHR1YWxMb29rdXBUYWJsZShbXG4gICAgICAgIFsgMHhmZiwgMHg0NCwgMHgwMCwgMHhmZiBdLFxuICAgICAgICBbIDB4YmQsIDB4YmQsIDB4YmQsIDB4YjAgXVxuICAgIF0pO1xuXG4gICAgY29uc3QgUE9MQVJfQ09MRCA9IGJ1aWxkUGVyY2VwdHVhbExvb2t1cFRhYmxlKFtcbiAgICAgICAgWyAweGJkLCAweGJkLCAweGJkLCAweGIwIF0sXG4gICAgICAgIFsgMHgzMiwgMHhhNSwgMHhmOSwgMHhmZiBdXG4gICAgXSk7XG5cbiAgICBjb25zdCBGSVJFID0gYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoW1xuICAgICAgICBbMHg5NiwgMHgwMCwgMHgwMCwgMHg5Nl0sXG4gICAgICAgIFsweGZmLCAweGZmLCAweDMyLCAweGZmXVxuICAgIF0pO1xuXG4gICAgY29uc3QgRkxBVCA9IGJ1aWxkRmxhdExvb2t1cFRhYmxlKFsweGZmLCAweGZmLCAweGZmLCAweGZmXSk7XG5cbiAgICBjb25zdCBidWlsZExvb2t1cEZ1bmN0aW9uID0gZnVuY3Rpb24oUkFNUCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NhbGVkVmFsdWUsIGluQ29sb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihzY2FsZWRWYWx1ZSAqIChSQU1QLmxlbmd0aCAvIDQgLSAxKSk7XG4gICAgICAgICAgICBpbkNvbG9yWzBdID0gUkFNUFtpbmRleCAqIDRdO1xuICAgICAgICAgICAgaW5Db2xvclsxXSA9IFJBTVBbaW5kZXggKiA0ICsgMV07XG4gICAgICAgICAgICBpbkNvbG9yWzJdID0gUkFNUFtpbmRleCAqIDQgKyAyXTtcbiAgICAgICAgICAgIGluQ29sb3JbM10gPSBSQU1QW2luZGV4ICogNCArIDNdO1xuICAgICAgICAgICAgcmV0dXJuIGluQ29sb3I7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbmNhdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWQgPSBuZXcgRmxvYXQzMkFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgICAgICBjb21iaW5lZC5zZXQoYSwgMCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChiLCBhLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9O1xuXG4gICAgY29uc3QgQ29sb3JUYWJsZXMgPSB7XG4gICAgICAgIGNvb2w6IENPT0wsXG4gICAgICAgIGhvdDogSE9ULFxuICAgICAgICB2ZXJkYW50OiBWRVJEQU5ULFxuICAgICAgICBzcGVjdHJhbDogU1BFQ1RSQUwsXG4gICAgICAgIHRlbXBlcmF0dXJlOiBURU1QRVJBVFVSRSxcbiAgICAgICAgZ3JleTogR1JFWVNDQUxFLFxuICAgICAgICBwb2xhcjogY29uY2F0KFBPTEFSX0hPVCwgUE9MQVJfQ09MRCksXG4gICAgICAgIGZsYXQ6IEZMQVRcbiAgICB9O1xuXG4gICAgY29uc3QgQ29sb3JSYW1wID0ge1xuICAgICAgICBjb29sOiBidWlsZExvb2t1cEZ1bmN0aW9uKENPT0wpLFxuICAgICAgICBob3Q6IGJ1aWxkTG9va3VwRnVuY3Rpb24oSE9UKSxcbiAgICAgICAgdmVyZGFudDogYnVpbGRMb29rdXBGdW5jdGlvbihWRVJEQU5UKSxcbiAgICAgICAgc3BlY3RyYWw6IGJ1aWxkTG9va3VwRnVuY3Rpb24oU1BFQ1RSQUwpLFxuICAgICAgICB0ZW1wZXJhdHVyZTogYnVpbGRMb29rdXBGdW5jdGlvbihURU1QRVJBVFVSRSksXG4gICAgICAgIGdyZXk6IGJ1aWxkTG9va3VwRnVuY3Rpb24oR1JFWVNDQUxFKSxcbiAgICAgICAgZmlyZTogYnVpbGRMb29rdXBGdW5jdGlvbihGSVJFKSxcbiAgICAgICAgcG9sYXI6IGJ1aWxkTG9va3VwRnVuY3Rpb24oY29uY2F0KFBPTEFSX0hPVCwgUE9MQVJfQ09MRCkpLFxuICAgICAgICBmbGF0OiBidWlsZExvb2t1cEZ1bmN0aW9uKEZMQVQpXG4gICAgfTtcblxuICAgIGNvbnN0IHNldENvbG9yUmFtcCA9IGZ1bmN0aW9uKHR5cGUsIGJhc2VDb2xvcnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IENvbG9yUmFtcFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fY29sb3JSYW1wID0gZnVuYztcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlQ29sb3JzKSB7XG4gICAgICAgICAgICBDb2xvclJhbXBbdHlwZS50b0xvd2VyQ2FzZSgpXSA9IGJ1aWxkTG9va3VwRnVuY3Rpb24oYnVpbGRQZXJjZXB0dWFsTG9va3VwVGFibGUoYmFzZUNvbG9ycykpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JSYW1wID0gQ29sb3JSYW1wW3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbG9yUmFtcFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRDb2xvclJhbXAgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclJhbXAgfHwgQ29sb3JSYW1wW3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENvbG9yUmFtcFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDb2xvclRhYmxlc1t0aGlzLl9jb2xvclJhbXBUeXBlXTtcbiAgICB9O1xuXG4gICAgY29uc3QgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jb2xvclJhbXAgPSBDb2xvclJhbXAudmVyZGFudDtcbiAgICAgICAgdGhpcy5fY29sb3JSYW1wVHlwZSA9ICd2ZXJkYW50JztcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gICAgICAgIHNldENvbG9yUmFtcDogc2V0Q29sb3JSYW1wLFxuICAgICAgICBnZXRDb2xvclJhbXA6IGdldENvbG9yUmFtcCxcbiAgICAgICAgZ2V0Q29sb3JSYW1wVGFibGU6IGdldENvbG9yUmFtcFRhYmxlLFxuICAgICAgICBOVU1fR1JBRElFTlRfU1RFUFM6IE5VTV9HUkFESUVOVF9TVEVQU1xuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBTSUdNT0lEX1NDQUxFID0gMC4xNTtcblxuICAgIC8vIGxvZzEwXG5cbiAgICBmdW5jdGlvbiBsb2cxMFRyYW5zZm9ybSh2YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIGNvbnN0IGxvZ01pbiA9IE1hdGgubG9nMTAobWluIHx8IDEpO1xuICAgICAgICBjb25zdCBsb2dNYXggPSBNYXRoLmxvZzEwKG1heCB8fCAxKTtcbiAgICAgICAgY29uc3QgbG9nVmFsID0gTWF0aC5sb2cxMCh2YWwgfHwgMSk7XG4gICAgICAgIHJldHVybiAobG9nVmFsIC0gbG9nTWluKSAvICgobG9nTWF4IC0gbG9nTWluKSB8fCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZlcnNlTG9nMTBUcmFuc2Zvcm0obnZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgbG9nTWluID0gTWF0aC5sb2cxMChtaW4gfHwgMSk7XG4gICAgICAgIGNvbnN0IGxvZ01heCA9IE1hdGgubG9nMTAobWF4IHx8IDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIChudmFsICogbG9nTWF4IC0gbnZhbCAqIGxvZ01pbikgKyBsb2dNaW4pO1xuICAgIH1cblxuICAgIC8vIHNpZ21vaWRcblxuICAgIGZ1bmN0aW9uIHNpZ21vaWRUcmFuc2Zvcm0odmFsLCBtaW4sIG1heCkge1xuICAgICAgICBjb25zdCBhYnNNaW4gPSBNYXRoLmFicyhtaW4pO1xuICAgICAgICBjb25zdCBhYnNNYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgubWF4KGFic01pbiwgYWJzTWF4KTtcbiAgICAgICAgY29uc3Qgc2NhbGVkVmFsID0gdmFsIC8gKFNJR01PSURfU0NBTEUgKiBkaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiAxIC8gKDEgKyBNYXRoLmV4cCgtc2NhbGVkVmFsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52ZXJzZVNpZ21vaWRUcmFuc2Zvcm0obnZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgYWJzTWluID0gTWF0aC5hYnMobWluKTtcbiAgICAgICAgY29uc3QgYWJzTWF4ID0gTWF0aC5hYnMobWF4KTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLm1heChhYnNNaW4sIGFic01heCk7XG4gICAgICAgIGlmIChudmFsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLWRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudmFsID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKCgxL252YWwpIC0gMSkgKiAtKFNJR01PSURfU0NBTEUgKiBkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgLy8gbGluZWFyXG5cbiAgICBmdW5jdGlvbiBsaW5lYXJUcmFuc2Zvcm0odmFsLCBtaW4sIG1heCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZhbCAtIG1pbikgLyByYW5nZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZlcnNlTGluZWFyVHJhbnNmb3JtKG52YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gKyBudmFsICogcmFuZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgVHJhbnNmb3JtID0ge1xuICAgICAgICBsaW5lYXI6IGxpbmVhclRyYW5zZm9ybSxcbiAgICAgICAgbG9nMTA6IGxvZzEwVHJhbnNmb3JtLFxuICAgICAgICBzaWdtb2lkOiBzaWdtb2lkVHJhbnNmb3JtXG4gICAgfTtcblxuICAgIGNvbnN0IEludmVyc2UgPSB7XG4gICAgICAgIGxpbmVhcjogaW52ZXJzZUxpbmVhclRyYW5zZm9ybSxcbiAgICAgICAgbG9nMTA6IGludmVyc2VMb2cxMFRyYW5zZm9ybSxcbiAgICAgICAgc2lnbW9pZDogaW52ZXJzZVNpZ21vaWRUcmFuc2Zvcm1cbiAgICB9O1xuXG4gICAgY29uc3QgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yYW5nZSA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1GdW5jID0gbG9nMTBUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX2ludmVyc2VGdW5jID0gaW52ZXJzZUxvZzEwVHJhbnNmb3JtO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRUcmFuc2Zvcm1GdW5jID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBjb25zdCBmdW5jID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1GdW5jID0gVHJhbnNmb3JtW2Z1bmNdO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UeXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5faW52ZXJzZUZ1bmMgPSBJbnZlcnNlW2Z1bmNdO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRWYWx1ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5fcmFuZ2UubWluID0gcmFuZ2UubWluO1xuICAgICAgICB0aGlzLl9yYW5nZS5tYXggPSByYW5nZS5tYXg7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFZhbHVlUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRUcmFuc2Zvcm1FbnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gJ3NpZ21vaWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJwb2xhdGVUb1JhbmdlID0gZnVuY3Rpb24obnZhbCkge1xuICAgICAgICAvLyBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBmaWx0ZXIgcmFuZ2VcbiAgICAgICAgY29uc3Qgck1pbiA9IHRoaXMuX3JhbmdlLm1pbjtcbiAgICAgICAgY29uc3Qgck1heCA9IHRoaXMuX3JhbmdlLm1heDtcbiAgICAgICAgY29uc3QgcnZhbCA9IChudmFsIC0gck1pbikgLyAock1heCAtIHJNaW4pO1xuICAgICAgICAvLyBlbnN1cmUgb3V0cHV0IGlzIFswOjFdXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBydmFsKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybVZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIC8vIGNsYW1wIHRoZSB2YWx1ZSBiZXR3ZWVuIHRoZSBleHRyZW1lIChzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5KVxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLl9leHRyZW1hLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5fZXh0cmVtYS5tYXg7XG4gICAgICAgIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1heChNYXRoLm1pbih2YWwsIG1heCksIG1pbik7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdmFsdWVcbiAgICAgICAgaWYgKG1pbiAhPT0gbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtRnVuYyhjbGFtcGVkLCBtaW4sIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbWluID09PSBtYXgsIGFsd2F5cyByZXR1cm4gMVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuXG4gICAgY29uc3QgdW50cmFuc2Zvcm1WYWx1ZSA9IGZ1bmN0aW9uKG52YWwpIHtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5fZXh0cmVtYS5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMuX2V4dHJlbWEubWF4O1xuICAgICAgICAvLyBjbGFtcCB0aGUgdmFsdWUgYmV0d2VlbiB0aGUgZXh0cmVtZSAoc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSlcbiAgICAgICAgY29uc3QgY2xhbXBlZCA9IE1hdGgubWF4KE1hdGgubWluKG52YWwsIDEpLCAwKTtcbiAgICAgICAgLy8gdW5ub3JtYWxpemUgdGhlIHZhbHVlXG4gICAgICAgIGlmIChtaW4gIT09IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludmVyc2VGdW5jKGNsYW1wZWQsIG1pbiwgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBtaW4gPT09IG1heCwgYWx3YXlzIHJldHVybiAxXG4gICAgICAgIHJldHVybiAxO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcbiAgICAgICAgc2V0VHJhbnNmb3JtRnVuYzogc2V0VHJhbnNmb3JtRnVuYyxcbiAgICAgICAgc2V0VmFsdWVSYW5nZTogc2V0VmFsdWVSYW5nZSxcbiAgICAgICAgZ2V0VmFsdWVSYW5nZTogZ2V0VmFsdWVSYW5nZSxcbiAgICAgICAgZ2V0VHJhbnNmb3JtRW51bTogZ2V0VHJhbnNmb3JtRW51bSxcbiAgICAgICAgdHJhbnNmb3JtVmFsdWU6IHRyYW5zZm9ybVZhbHVlLFxuICAgICAgICB1bnRyYW5zZm9ybVZhbHVlOiB1bnRyYW5zZm9ybVZhbHVlLFxuICAgICAgICBpbnRlcnBvbGF0ZVRvUmFuZ2U6IGludGVycG9sYXRlVG9SYW5nZVxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBQT1NJVElWRSA9ICcxJztcbiAgICBjb25zdCBORVVUUkFMID0gJzAnO1xuICAgIGNvbnN0IE5FR0FUSVZFID0gJy0xJztcblxuICAgIGZ1bmN0aW9uIGdldENsYXNzRnVuYyhtaW4sIG1heCkge1xuICAgICAgICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IC0xO1xuICAgICAgICBtYXggPSBtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IDE7XG4gICAgICAgIGNvbnN0IHBvc2l0aXZlID0gWzAuMjUgKiBtYXgsIDAuNSAqIG1heCwgMC43NSAqIG1heF07XG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlID0gWy0wLjI1ICogbWluLCAtMC41ICogbWluLCAtMC43NSAqIG1pbl07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzZW50aW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgICAgICBsZXQgcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc2VudGltZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICduZWctJztcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5lZ2F0aXZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAncG9zLSc7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBwb3NpdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFicyA9IE1hdGguYWJzKHNlbnRpbWVudCk7XG4gICAgICAgICAgICBpZiAoYWJzID4gcmFuZ2VbMl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJzQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPiByYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAnMyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA+IHJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICcyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAnMSc7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VG90YWwoY291bnQpIHtcbiAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gY291bnRbUE9TSVRJVkVdID8gY291bnRbUE9TSVRJVkVdIDogMDtcbiAgICAgICAgY29uc3QgbmV1ID0gY291bnRbTkVVVFJBTF0gPyBjb3VudFtORVVUUkFMXSA6IDA7XG4gICAgICAgIGNvbnN0IG5lZyA9IGNvdW50W05FR0FUSVZFXSA/IGNvdW50W05FR0FUSVZFXSA6IDA7XG4gICAgICAgIHJldHVybiBwb3MgKyBuZXUgKyBuZWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXZnKGNvdW50KSB7XG4gICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcyA9IGNvdW50W1BPU0lUSVZFXSA/IGNvdW50W1BPU0lUSVZFXSA6IDA7XG4gICAgICAgIGNvbnN0IG5ldSA9IGNvdW50W05FVVRSQUxdID8gY291bnRbTkVVVFJBTF0gOiAwO1xuICAgICAgICBjb25zdCBuZWcgPSBjb3VudFtORUdBVElWRV0gPyBjb3VudFtORUdBVElWRV0gOiAwO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHBvcyArIG5ldSArIG5lZztcbiAgICAgICAgcmV0dXJuICh0b3RhbCAhPT0gMCkgPyAocG9zIC0gbmVnKSAvIHRvdGFsIDogMDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0Q2xhc3NGdW5jOiBnZXRDbGFzc0Z1bmMsXG4gICAgICAgIGdldFRvdGFsOiBnZXRUb3RhbCxcbiAgICAgICAgZ2V0QXZnOiBnZXRBdmdcbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgQ2FudmFzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9DYW52YXMnKTtcbiAgICBjb25zdCBDb2xvclJhbXAgPSByZXF1aXJlKCcuLi8uLi9taXhpbi9Db2xvclJhbXAnKTtcbiAgICBjb25zdCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG5cbiAgICBjb25zdCBIZWF0bWFwID0gQ2FudmFzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbG9yUmFtcC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihiaW5zLCByZXNvbHV0aW9uLCByYW1wKSB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZXNvbHV0aW9uO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCByZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgbGV0IG52YWwgPSAwO1xuICAgICAgICAgICAgbGV0IHJ2YWwgPSAwO1xuICAgICAgICAgICAgbGV0IGJpbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8Ymlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpbiA9IGJpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJpbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvclswXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclszXSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnZhbCA9IHRoaXMudHJhbnNmb3JtVmFsdWUoYmluKTtcbiAgICAgICAgICAgICAgICAgICAgcnZhbCA9IHRoaXMuaW50ZXJwb2xhdGVUb1JhbmdlKG52YWwpO1xuICAgICAgICAgICAgICAgICAgICByYW1wKHJ2YWwsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YVtpICogNF0gPSBNYXRoLnJvdW5kKGNvbG9yWzBdICogMjU1KTtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKiA0ICsgMV0gPSBNYXRoLnJvdW5kKGNvbG9yWzFdICogMjU1KTtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKiA0ICsgMl0gPSBNYXRoLnJvdW5kKGNvbG9yWzJdICogMjU1KTtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKiA0ICsgM10gPSBNYXRoLnJvdW5kKGNvbG9yWzNdICogMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY2FudmFzLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaW5zID0gbmV3IEZsb2F0NjRBcnJheShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoYmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcmFtcCA9IHRoaXMuZ2V0Q29sb3JSYW1wKCk7XG4gICAgICAgICAgICBjb25zdCB0aWxlQ2FudmFzID0gdGhpcy5yZW5kZXJDYW52YXMoYmlucywgcmVzb2x1dGlvbiwgcmFtcCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgdGlsZUNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQ2FudmFzJyk7XG5cbiAgICBjb25zdCBQcmV2aWV3ID0gQ2FudmFzLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICAgICAgbGluZUNvbG9yOiAnI2ZmZidcbiAgICAgICAgfSxcblxuICAgICAgICBoaWdobGlnaHRlZDogZmFsc2UsXG5cbiAgICAgICAgX2RyYXdIaWdobGlnaHQ6IGZ1bmN0aW9uKGNhbnZhcywgeCwgeSwgc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5vcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgIHggKiBzaXplLFxuICAgICAgICAgICAgICAgIHkgKiBzaXplLFxuICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgc2l6ZSk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMub3B0aW9ucy5saW5lQ29sb3I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICBjb25zdCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGtleVxuICAgICAgICAgICAgY29uc3QgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYmluIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICBjb25zdCBiaW4gPSB0aGlzLmdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJpbiBkYXRhIGVudHJ5XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhY2hlZC5kYXRhW2Jpbi5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdGlsZSByZWx5aW5nIG9uIHRoYXQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBfLmZvckluKGNhY2hlZC50aWxlcywgdGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3SGlnaGxpZ2h0KHRpbGUsIGJpbi54LCBiaW4ueSwgYmluLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBieDogYmluLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBieTogYmluLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHJldmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIGhpZ2hsaWdodGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBjb2xsaXNpb247XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBjdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLl9tYXAuX2NvbnRhaW5lcikuY3NzKCdjdXJzb3InLCAncG9pbnRlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW91c2Ugb3V0XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIGhpZ2hsaWdodGVkIGZsYWdcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUHJldmlldztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQ2FudmFzJyk7XG4gICAgY29uc3QgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG4gICAgY29uc3QgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuXG4gICAgY29uc3QgVG9wVHJhaWxzID0gQ2FudmFzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzZWxlY3RlZENvbG9yOiBbMjU1LCAxMDAsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkQ29sb3I6IFsyMDAsIDAsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGRvd25TYW1wbGVGYWN0b3I6IDhcbiAgICAgICAgfSxcblxuICAgICAgICBoaWdobGlnaHRlZDogbnVsbCxcblxuICAgICAgICBzZWxlY3RlZDogbnVsbCxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbG9yUmFtcC5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJIaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRUcmFpbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlscygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhpZ2hsaWdodDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlscygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBiaW4gPSB0aGlzLl9nZXRCaW5EYXRhKGUpO1xuICAgICAgICAgICAgaWYgKGJpbikge1xuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oYmluKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBzZWxlY3RlZCBmbGFnXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBiaW4gPSB0aGlzLl9nZXRCaW5EYXRhKGUpO1xuICAgICAgICAgICAgaWYgKGJpbikge1xuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiaW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZsYWcgYXMgaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhpZ2hsaWdodChiaW4pO1xuICAgICAgICAgICAgICAgIC8vIHNldCBjdXJzb3JcbiAgICAgICAgICAgICAgICAkKHRoaXMuX21hcC5fY29udGFpbmVyKS5jc3MoJ2N1cnNvcicsICdwb2ludGVyJyk7XG4gICAgICAgICAgICAgICAgLy8gZXhpdCBlYXJseVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vdXNlIG91dFxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhpZ2hsaWdodGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEJpbkRhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgLy8gZ2V0IHRpbGUgY29vcmRcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgIGNvbnN0IG5rZXkgPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKGNvb3JkLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5waXhlbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYmluIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICBjb25zdCBiaW4gPSB0aGlzLmdldEJpbkNvb3JkRnJvbUxheWVyUG9pbnQobGF5ZXJQb2ludCk7XG4gICAgICAgICAgICAgICAgLy8gZG93bnNhbXBsZSB0aGUgYmluIHJlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKGJpbi54IC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGJpbi55IC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGhpdHMgYSBwaXhlbFxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQucGl4ZWxzW3hdICYmIGNhY2hlZC5waXhlbHNbeF1beV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoY2FjaGVkLnBpeGVsc1t4XVt5XSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRha2UgZmlyc3QgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpZHNbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjb2xsaXNpb24gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ4OiBiaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5OiBiaW4ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0b3AtdHJhaWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hpZ2hsaWdodFRyYWlsc0ZvckRhdGE6IGZ1bmN0aW9uKGNhY2hlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWQgPSB0aGlzLmhpZ2hsaWdodGVkO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWlsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbCA9IGNhY2hlZC50cmFpbHNbc2VsZWN0ZWQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHRpbGUgcmVseWluZyBvbiB0aGF0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9ySW4oY2FjaGVkLnRpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUcmFpbCh0aWxlLCB0cmFpbCwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsID0gY2FjaGVkLnRyYWlsc1toaWdobGlnaHRlZC52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JJbihjYWNoZWQudGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRyYWlsKHRpbGUsIHRyYWlsLCB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGlnaGxpZ2h0VHJhaWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaWxlcygpO1xuICAgICAgICAgICAgXy5mb3JJbih0aGlzLl9jYWNoZSwgY2FjaGVkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRUcmFpbHNGb3JEYXRhKGNhY2hlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVuZGVyVHJhaWw6IGZ1bmN0aW9uKGNhbnZhcywgcGl4ZWxzLCBjb2xvcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBoaWdobGlnaHQuaGVpZ2h0ID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGhpZ2hsaWdodC53aWR0aCA9IHJlc29sdXRpb247XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRDdHggPSBoaWdobGlnaHQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGhpZ2hsaWdodEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgcmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICBsZXQgcGl4ZWwsIHgsIHksIGksIGo7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxwaXhlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwaXhlbCA9IHBpeGVsc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gcGl4ZWxbMF07XG4gICAgICAgICAgICAgICAgeSA9IHBpeGVsWzFdO1xuICAgICAgICAgICAgICAgIGogPSB4ICsgKHJlc29sdXRpb24gKiB5KTtcbiAgICAgICAgICAgICAgICBkYXRhW2ogKiA0XSA9IGNvbG9yWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaiAqIDQgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgICAgICAgICAgIGRhdGFbaiAqIDQgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgICAgICAgICAgIGRhdGFbaiAqIDQgKyAzXSA9IGNvbG9yWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGlnaGxpZ2h0Q3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgLy8gZHJhdyB0byB0aWxlXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0LFxuICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbiwgcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBjb29yZCkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW9kaWZ5IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICBjb25zdCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZVtua2V5XTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQudHJhaWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhaWxzIGFscmVhZHkgYWRkZWQsIGV4aXQgZWFybHlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFpbHMgPSBjYWNoZWQudHJhaWxzID0ge307XG4gICAgICAgICAgICBjb25zdCBwaXhlbHMgPSBjYWNoZWQucGl4ZWxzID0ge307XG4gICAgICAgICAgICBjb25zdCBpZHMgID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgYmlucyA9IGRhdGFbaWRdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxiaW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbiA9IGJpbnNbal07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gc2FtcGxlIHRoZSBwaXhlbCB0byBtYWtlIGludGVyYWN0aW9uIGVhc2llclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByeCA9IE1hdGguZmxvb3IoYmluWzBdIC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByeSA9IE1hdGguZmxvb3IoYmluWzFdIC8gdGhpcy5vcHRpb25zLmRvd25TYW1wbGVGYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcnhdID0gcGl4ZWxzW3J4XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3J4XVtyeV0gPSBwaXhlbHNbcnhdW3J5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3J4XVtyeV1baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHBpeGVsIHVuZGVyIHRoZSB0cmFpbCBhdCBjb3JyZWN0IHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGJpblswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGJpblsxXTtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxzW2lkXSA9IHRyYWlsc1tpZF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsc1tpZF0ucHVzaChbIHgsIHkgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGhpZ2hsaWdodCBzZWxlY3RlZCB0cmFpbHMgaW4gdGhlIHRpbGVcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFRyYWlsc0ZvckRhdGEoY2FjaGVkKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvcFRyYWlscztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0sIGNvb3JkKSB7XG4gICAgICAgICAgICAkKGVsZW0pLmVtcHR5KCk7XG4gICAgICAgICAgICAkKGVsZW0pLmFwcGVuZCgnPGRpdiBzdHlsZT1cInRvcDowOyBsZWZ0OjA7XCI+JyArIGNvb3JkLnogKyAnLCAnICsgY29vcmQueCArICcsICcgKyBjb29yZC55ICsgJzwvZGl2PicpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgSFRNTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvSFRNTCcpO1xuICAgIGNvbnN0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcbiAgICBjb25zdCBUSUxFX1NJWkUgPSAyNTY7XG5cbiAgICBjb25zdCBDb21tdW5pdHlMYWJlbCA9IEhUTUwuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybVxuICAgICAgICBdLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1pbkZvbnRTaXplOiAxMCxcbiAgICAgICAgICAgIG1heEZvbnRTaXplOiAyNCxcbiAgICAgICAgICAgIG1pbk9wYWNpdHk6IDAuNSxcbiAgICAgICAgICAgIG1heE9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgIGxhYmVsTWF4TGVuZ3RoOiBUSUxFX1NJWkUsXG4gICAgICAgICAgICBsYWJlbFRocmVzaG9sZDogMC42LFxuICAgICAgICAgICAgbGFiZWxGaWVsZDogJ21ldGFkYXRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIGNvbW11bml0eSB0aXRsZSBzdHJpbmcgdG8gYXBwIGxldmVsIG1vdXNlbW92ZSBoYW5kbGVyXG4gICAgICAgICAgICAvLyB3aGVuIHBvaW50ZXIgaXMgb3ZlciBhIGNvbW11bml0eSByaW5nXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRhcmdldC5kYXRhKCdjb21tdW5pdHlEYXRhJyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGNvdW50OiBkYXRhLm51bU5vZGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW11bml0eS1sYWJlbHMnLFxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIGNsZWFyZWQgc3RyaW5nIHRvIGFwcCBsZXZlbCBtb3VzZW1vdmUgaGFuZGxlciB3aGVuXG4gICAgICAgICAgICAvLyBwb2ludGVyIG1vdmVzIG9mZiBhIGNvbW11bml0eSByaW5nXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW11bml0eS1sYWJlbHMnLFxuICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlTGFiZWxEaXY6IGZ1bmN0aW9uKGNvbW11bml0eSwgY29vcmQsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbGV0IG52YWwgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKF8uZ2V0KGNvbW11bml0eSwgdGhpcy5vcHRpb25zLmRlZ3JlZUZpZWxkKSk7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIG52YWwgYXMgaXQgaXMgY3VycmVudGx5IGluIHRoZSByYW5nZSBbdGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkIDogMV1cbiAgICAgICAgICAgIG52YWwgPSAobnZhbCAtIHRoaXMub3B0aW9ucy5sYWJlbFRocmVzaG9sZCkgLyAoMS4wIC0gdGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkKTtcbiAgICAgICAgICAgIGNvbnN0IHpJbmRleCA9IE1hdGguY2VpbCgxMDAgKiBudmFsKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5vcHRpb25zLm1pbkZvbnRTaXplICsgKG52YWwgKiAodGhpcy5vcHRpb25zLm1heEZvbnRTaXplIC0gdGhpcy5vcHRpb25zLm1pbkZvbnRTaXplKSk7XG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm1pbk9wYWNpdHkgKyAobnZhbCAqICh0aGlzLm9wdGlvbnMubWF4T3BhY2l0eSAtIHRoaXMub3B0aW9ucy5taW5PcGFjaXR5KSk7XG4gICAgICAgICAgICBjb25zdCBkaW0gPSBNYXRoLnBvdygyLCBjb29yZC56KTtcbiAgICAgICAgICAgIGNvbnN0IHRpbGVTcGFuID0gTWF0aC5wb3coMiwgMzIpIC8gZGltO1xuICAgICAgICAgICAgY29uc3QgeCA9IF8uZ2V0KGNvbW11bml0eSwgdGhpcy5nZXRYRmllbGQoKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gXy5nZXQoY29tbXVuaXR5LCB0aGlzLmdldFlGaWVsZCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSAoKHggJSB0aWxlU3BhbikgLyB0aWxlU3BhbikgKiBUSUxFX1NJWkUgLSAodGhpcy5vcHRpb25zLmxhYmVsTWF4TGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSAoKHkgJSB0aWxlU3BhbikgLyB0aWxlU3BhbikgKiBUSUxFX1NJWkUgLSAoZm9udFNpemUgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiAkKFxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9XCIgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJHtsZWZ0fXB4O1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICR7dG9wfXB4O1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAke29wYWNpdHl9O1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6ICR7Zm9udFNpemV9cHg7XG4gICAgICAgICAgICAgICAgICAgIHotaW5kZXg6ICR7ekluZGV4fTtcbiAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7Zm9udFNpemV9cHg7XCI+JHtfLmdldChjb21tdW5pdHksIHRoaXMub3B0aW9ucy5sYWJlbEZpZWxkKX08L2Rpdj5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIGNvb3JkKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGl2cyA9ICQoKTtcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChjb21tdW5pdHkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghXy5nZXQoY29tbXVuaXR5LCB0aGlzLm9wdGlvbnMubGFiZWxGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBudmFsID0gdGhpcy50cmFuc2Zvcm1WYWx1ZShfLmdldChjb21tdW5pdHksIHRoaXMub3B0aW9ucy5kZWdyZWVGaWVsZCkpO1xuICAgICAgICAgICAgICAgIGlmIChudmFsIDwgdGhpcy5vcHRpb25zLmxhYmVsVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGl2ID0gdGhpcy5fY3JlYXRlTGFiZWxEaXYoY29tbXVuaXR5LCBjb29yZCwgJ2NvbW11bml0eS1sYWJlbCcpO1xuICAgICAgICAgICAgICAgIGRpdi5kYXRhKCdjb21tdW5pdHlEYXRhJywgY29tbXVuaXR5KTtcbiAgICAgICAgICAgICAgICBkaXZzID0gZGl2cy5hZGQoZGl2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChjb250YWluZXIpLmVtcHR5KCkuYXBwZW5kKGRpdnMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tbXVuaXR5TGFiZWw7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG5cbiAgICBjb25zdCBFbXB0eSA9IEhUTUwuZXh0ZW5kKHt9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRW1wdHk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG4gICAgY29uc3QgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG4gICAgY29uc3QgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuXG4gICAgY29uc3QgSGVhdG1hcCA9IEhUTUwuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgICAgICBDb2xvclJhbXAsXG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybVxuICAgICAgICBdLFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgQ29sb3JSYW1wLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0LmF0dHIoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KHZhbHVlLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgIGJ4OiBwYXJzZUludCh0YXJnZXQuYXR0cignZGF0YS1ieCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIGJ5OiBwYXJzZUludCh0YXJnZXQuYXR0cignZGF0YS1ieScpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoZWF0bWFwJyxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXQuYXR0cignZGF0YS12YWx1ZScpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCh2YWx1ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICBieDogcGFyc2VJbnQodGFyZ2V0LmF0dHIoJ2RhdGEtYngnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBieTogcGFyc2VJbnQodGFyZ2V0LmF0dHIoJ2RhdGEtYnknKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhdG1hcCcsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gdW4tc2VsZWN0IGFueSBwcmV2IHNlbGVjdGVkIHBpeGVsXG4gICAgICAgICAgICAkKCcuaGVhdG1hcC1waXhlbCcpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIC8vIGdldCB0YXJnZXRcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUYXJnZXRMYXllcihlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGF5ZXIgaXMgbm90IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdoZWF0bWFwLXBpeGVsJykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXQuYXR0cignZGF0YS12YWx1ZScpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCh2YWx1ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICBieDogcGFyc2VJbnQodGFyZ2V0LmF0dHIoJ2RhdGEtYngnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBieTogcGFyc2VJbnQodGFyZ2V0LmF0dHIoJ2RhdGEtYnknKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhdG1hcCcsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaW5zID0gbmV3IEZsb2F0NjRBcnJheShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoYmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcmFtcCA9IHRoaXMuZ2V0Q29sb3JSYW1wKCk7XG4gICAgICAgICAgICBjb25zdCBwaXhlbFNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUgLyByZXNvbHV0aW9uO1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICAgICAgbGV0IG52YWwgPSAwO1xuICAgICAgICAgICAgbGV0IHJ2YWwgPSAwO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8Ymlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbiA9IGJpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJpbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGkgJSByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5mbG9vcihpIC8gcmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgIG52YWwgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKGJpbik7XG4gICAgICAgICAgICAgICAgICAgIHJ2YWwgPSB0aGlzLmludGVycG9sYXRlVG9SYW5nZShudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmFtcChydmFsLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKGNvbG9yWzBdICogMjU1KTtcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gTWF0aC5yb3VuZChjb2xvclsxXSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IE1hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjb2xvclszXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZ2JhID0gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhdG1hcC1waXhlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXZhbHVlPVwiJHtiaW59XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYng9XCIke2xlZnR9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYnk9XCIke3RvcH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7cGl4ZWxTaXplfXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke3BpeGVsU2l6ZX1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAke2xlZnQgKiBwaXhlbFNpemV9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAke3RvcCAqIHBpeGVsU2l6ZX1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3JnYmF9O1wiPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhdG1hcDtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IEhUTUwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0hUTUwnKTtcbiAgICBjb25zdCBWYWx1ZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL21peGluL1ZhbHVlVHJhbnNmb3JtJyk7XG5cbiAgICBjb25zdCBIZWF0bWFwID0gSFRNTC5leHRlbmQoe1xuXG4gICAgICAgIGluY2x1ZGVzOiBbXG4gICAgICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgICAgIFZhbHVlVHJhbnNmb3JtXG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy5oZWF0bWFwLXJpbmcnKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUYXJnZXRMYXllcihlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGF5ZXIgaXMgbm90IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdoZWF0bWFwLXJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaW5zID0gbmV3IEZsb2F0NjRBcnJheShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoYmlucy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmluU2l6ZSA9ICh0aGlzLm9wdGlvbnMudGlsZVNpemUgLyByZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGxldCBodG1sID0gJyc7XG4gICAgICAgICAgICBiaW5zLmZvckVhY2goKGJpbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWJpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKGJpbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gcGVyY2VudCAqIGJpblNpemU7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGJpblNpemUgLSByYWRpdXMpIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gKGluZGV4ICUgcmVzb2x1dGlvbikgKiBiaW5TaXplO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IE1hdGguZmxvb3IoaW5kZXggLyByZXNvbHV0aW9uKSAqIGJpblNpemU7XG4gICAgICAgICAgICAgICAgaHRtbCArPVxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJoZWF0bWFwLXJpbmdcIiBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJHtsZWZ0ICsgb2Zmc2V0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAke3RvcCArIG9mZnNldH1weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAke3JhZGl1c31weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtyYWRpdXN9cHg7XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG4gICAgY29uc3QgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuICAgIGNvbnN0IHNlbnRpbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NlbnRpbWVudC9TZW50aW1lbnQnKTtcbiAgICBjb25zdCBzZW50aW1lbnRGdW5jID0gc2VudGltZW50LmdldENsYXNzRnVuYygtMSwgMSk7XG5cbiAgICBjb25zdCBWRVJUSUNBTF9PRkZTRVQgPSAyNDtcbiAgICBjb25zdCBIT1JJWk9OVEFMX09GRlNFVCA9IDEwO1xuICAgIGNvbnN0IE5VTV9BVFRFTVBUUyA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBpbml0aWFsIHBvc2l0aW9uLCByZXR1cm4gYSBuZXcgcG9zaXRpb24sIGluY3JlbWVudGFsbHkgc3BpcmFsbGVkXG4gICAgICogb3V0d2FyZHMuXG4gICAgICovXG4gICAgY29uc3Qgc3BpcmFsUG9zaXRpb24gPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgY29uc3QgcGkyID0gMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IGNpcmMgPSBwaTIgKiBwb3MucmFkaXVzO1xuICAgICAgICBjb25zdCBpbmMgPSAocG9zLmFyY0xlbmd0aCA+IGNpcmMgLyAxMCkgPyBjaXJjIC8gMTAgOiBwb3MuYXJjTGVuZ3RoO1xuICAgICAgICBjb25zdCBkYSA9IGluYyAvIHBvcy5yYWRpdXM7XG4gICAgICAgIGxldCBudCA9IChwb3MudCArIGRhKTtcbiAgICAgICAgaWYgKG50ID4gcGkyKSB7XG4gICAgICAgICAgICBudCA9IG50ICUgcGkyO1xuICAgICAgICAgICAgcG9zLnJhZGl1cyA9IHBvcy5yYWRpdXMgKyBwb3MucmFkaXVzSW5jO1xuICAgICAgICB9XG4gICAgICAgIHBvcy50ID0gbnQ7XG4gICAgICAgIHBvcy54ID0gcG9zLnJhZGl1cyAqIE1hdGguY29zKG50KTtcbiAgICAgICAgcG9zLnkgPSBwb3MucmFkaXVzICogTWF0aC5zaW4obnQpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGJvdW5kaW5nIGJveCBhIGludGVyc2VjdHMgYm91bmRpbmcgYm94IGJcbiAgICAgKi9cbiAgICBjb25zdCBpbnRlcnNlY3RUZXN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGEueCAtIGIueCkgKiAyIDwgKGEud2lkdGggKyBiLndpZHRoKSkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhhLnkgLSBiLnkpICogMiA8IChhLmhlaWdodCArIGIuaGVpZ2h0KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgYm91bmRpbmcgYm94IGEgaXMgbm90IGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgYm91bmRpbmcgYm94IGJcbiAgICAgKi9cbiAgICBjb25zdCBvdmVybGFwVGVzdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhLnggKyBhLndpZHRoIC8gMiA+IGIueCArIGIud2lkdGggLyAyIHx8XG4gICAgICAgICAgICBhLnggLSBhLndpZHRoIC8gMiA8IGIueCAtIGIud2lkdGggLyAyIHx8XG4gICAgICAgICAgICBhLnkgKyBhLmhlaWdodCAvIDIgPiBiLnkgKyBiLmhlaWdodCAvIDIgfHxcbiAgICAgICAgICAgIGEueSAtIGEuaGVpZ2h0IC8gMiA8IGIueSAtIGIuaGVpZ2h0IC8gMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgd29yZCBpbnRlcnNlY3RzIGFub3RoZXIgd29yZCwgb3IgaXMgbm90IGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGVcbiAgICAgKiB0aWxlIGJvdW5kaW5nIGJveFxuICAgICAqL1xuICAgIGNvbnN0IGludGVyc2VjdFdvcmQgPSBmdW5jdGlvbihwb3NpdGlvbiwgd29yZCwgY2xvdWQsIGJiKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICAgICAgaGVpZ2h0OiB3b3JkLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3b3JkLndpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvdWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RUZXN0KGJveCwgY2xvdWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3JkZXI7XG4gICAgICAgIGlmIChvdmVybGFwVGVzdChib3gsIGJiKSkge1xuICAgICAgICAgICAgLy8gaWYgaXQgaGl0cyBhIGJvcmRlciwgaW5jcmVtZW50IGNvbGxpc2lvbiBjb3VudFxuICAgICAgICAgICAgLy8gYW5kIGV4dGVuZCBhcmMgbGVuZ3RoXG4gICAgICAgICAgICBwb3NpdGlvbi5jb2xsaXNpb25zKys7XG4gICAgICAgICAgICBwb3NpdGlvbi5hcmNMZW5ndGggPSBwb3NpdGlvbi5yYWRpdXM7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IFdvcmRDbG91ZCA9IEhUTUwuZXh0ZW5kKHtcblxuICAgICAgICBpbmNsdWRlczogW1xuICAgICAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgICAgICBWYWx1ZVRyYW5zZm9ybVxuICAgICAgICBdLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG1heE51bVdvcmRzOiAxNSxcbiAgICAgICAgICAgIG1pbkZvbnRTaXplOiAxMCxcbiAgICAgICAgICAgIG1heEZvbnRTaXplOiAyMFxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm0uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SGlnaGxpZ2h0OiBmdW5jdGlvbih3b3JkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgd29yZFxuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmFkZENsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICQoYC53b3JkLWNsb3VkLWxhYmVsW2RhdGEtd29yZD1cIiR7d29yZH1cIl1gKS5hZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IHdvcmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAkKCcud29yZC1jbG91ZC1sYWJlbCcpLnJlbW92ZUNsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIHdvcmRcbiAgICAgICAgICAgICAgICAkKGAud29yZC1jbG91ZC1sYWJlbFtkYXRhLXdvcmQ9XCIke3dvcmR9XCJdYCkuYWRkQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGUub3JpZ2luYWxFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgejogY29vcmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhY2hlZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmQtY2xvdWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9ICQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAkKCcud29yZC1jbG91ZC1sYWJlbCcpLnJlbW92ZUNsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29yZC1jbG91ZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gdW4tc2VsZWN0IGFueSBwcmV2IHNlbGVjdGVkIHdvcmRzXG4gICAgICAgICAgICAkKCcud29yZC1jbG91ZC1sYWJlbCcpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAvLyBnZXQgdGFyZ2V0XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGFyZ2V0TGF5ZXIoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaWdobGlnaHQod29yZCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29yZC1jbG91ZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbWVhc3VyZVdvcmRzOiBmdW5jdGlvbih3b3JkQ291bnRzKSB7XG4gICAgICAgICAgICAvLyBzb3J0IHdvcmRzIGJ5IGZyZXF1ZW5jeVxuICAgICAgICAgICAgd29yZENvdW50cyA9IHdvcmRDb3VudHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLmNvdW50IC0gYS5jb3VudDtcbiAgICAgICAgICAgIH0pLnNsaWNlKDAsIHRoaXMub3B0aW9ucy5tYXhOdW1Xb3Jkcyk7XG4gICAgICAgICAgICAvLyBidWlsZCBtZWFzdXJlbWVudCBodG1sXG4gICAgICAgICAgICBjb25zdCAkaHRtbCA9ICQoJzxkaXYgc3R5bGU9XCJoZWlnaHQ6MjU2cHg7IHdpZHRoOjI1NnB4O1wiPjwvZGl2PicpO1xuICAgICAgICAgICAgY29uc3QgbWluRm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWluRm9udFNpemU7XG4gICAgICAgICAgICBjb25zdCBtYXhGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5tYXhGb250U2l6ZTtcbiAgICAgICAgICAgIHdvcmRDb3VudHMuZm9yRWFjaCh3b3JkID0+IHtcbiAgICAgICAgICAgICAgICB3b3JkLnBlcmNlbnQgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKHdvcmQuY291bnQpO1xuICAgICAgICAgICAgICAgIHdvcmQuZm9udFNpemUgPSBtaW5Gb250U2l6ZSArIHdvcmQucGVyY2VudCAqIChtYXhGb250U2l6ZSAtIG1pbkZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAkaHRtbC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIndvcmQtY2xvdWQtbGFiZWxcIiBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTpoaWRkZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6ICR7d29yZC5mb250U2l6ZX1weDtcIj4ke3dvcmQudGV4dH08L2Rpdj47XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhcHBlbmQgbWVhc3VyZW1lbnRzXG4gICAgICAgICAgICAkKCdib2R5JykuYXBwZW5kKCRodG1sKTtcbiAgICAgICAgICAgICRodG1sLmNoaWxkcmVuKCkuZWFjaCgoaW5kZXgsIGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICB3b3JkQ291bnRzW2luZGV4XS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgd29yZENvdW50c1tpbmRleF0uaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRodG1sLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdvcmRDb3VudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZVdvcmRDbG91ZDogZnVuY3Rpb24od29yZENvdW50cykge1xuICAgICAgICAgICAgY29uc3QgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gICAgICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGlsZVNpemUgLSBIT1JJWk9OVEFMX09GRlNFVCAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aWxlU2l6ZSAtIFZFUlRJQ0FMX09GRlNFVCAqIDIsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2xvdWQgPSBbXTtcbiAgICAgICAgICAgIC8vIHNvcnQgd29yZHMgYnkgZnJlcXVlbmN5XG4gICAgICAgICAgICB3b3JkQ291bnRzID0gdGhpcy5fbWVhc3VyZVdvcmRzKHdvcmRDb3VudHMpO1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgd29yZCBjbG91ZFxuICAgICAgICAgICAgd29yZENvdW50cy5mb3JFYWNoKHdvcmRDb3VudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgc3BpcmFsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXNJbmM6IDUsXG4gICAgICAgICAgICAgICAgICAgIGFyY0xlbmd0aDogMTAsXG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnM6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHNwaXJhbCBvdXR3YXJkcyB0byBmaW5kIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcy5jb2xsaXNpb25zIDwgTlVNX0FUVEVNUFRTKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBwb3NpdGlvbiBpbiBhIHNwaXJhbFxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzcGlyYWxQb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcnNlY3RXb3JkKHBvcywgd29yZENvdW50LCBjbG91ZCwgYm91bmRpbmdCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG91ZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHdvcmRDb3VudC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogd29yZENvdW50LnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHdvcmRDb3VudC5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiBNYXRoLnJvdW5kKCh3b3JkQ291bnQucGVyY2VudCAqIDEwMCkgLyAxMCkgKiAxMCwgLy8gcm91bmQgdG8gbmVhcmVzdCAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3b3JkQ291bnQud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB3b3JkQ291bnQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbnRpbWVudDogd29yZENvdW50LnNlbnRpbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmc6IHdvcmRDb3VudC5hdmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbG91ZDtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRyYWN0RXh0cmVtYTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgc3VtcyA9IF8ubWFwKGRhdGEsIGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBjb3VudC5jb3VudHMgfHwgY291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNOdW1iZXIoY291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbnRpbWVudC5nZXRUb3RhbChjb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBfLm1pbihzdW1zKSxcbiAgICAgICAgICAgICAgICBtYXg6IF8ubWF4KHN1bXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUZXh0OiBmdW5jdGlvbihrZXlEYXRhLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyVGlsZTogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgXy5pc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3b3JkQ291bnRzID0gXy5tYXAoZGF0YSwgKGtleURhdGEsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0ga2V5RGF0YS5jb3VudHMgfHwga2V5RGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUZXh0KGtleURhdGEsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNOdW1iZXIoY291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBzZW50aW1lbnQuZ2V0VG90YWwoY291bnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF2ZyA9IHNlbnRpbWVudC5nZXRBdmcoY291bnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogdG90YWwsXG4gICAgICAgICAgICAgICAgICAgIGF2ZzogYXZnLFxuICAgICAgICAgICAgICAgICAgICBzZW50aW1lbnQ6IHNlbnRpbWVudEZ1bmMoYXZnKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGV4aXQgZWFybHkgaWYgbm8gd29yZHNcbiAgICAgICAgICAgIGlmICh3b3JkQ291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdlbmVyZWF0ZSB0aGUgY2xvdWRcbiAgICAgICAgICAgIGNvbnN0IGNsb3VkID0gdGhpcy5fY3JlYXRlV29yZENsb3VkKHdvcmRDb3VudHMpO1xuICAgICAgICAgICAgLy8gYnVpbGQgaHRtbCBlbGVtZW50c1xuICAgICAgICAgICAgY29uc3QgaGFsZlNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUgLyAyO1xuICAgICAgICAgICAgbGV0IGh0bWwgPSAnJztcbiAgICAgICAgICAgIGNsb3VkLmZvckVhY2goZnVuY3Rpb24od29yZCkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3b3JkLWNsb3VkLWxhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3b3JkLWNsb3VkLWxhYmVsLSR7d29yZC5wZXJjZW50fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkLnRleHQgPT09IGhpZ2hsaWdodCA/ICdoaWdobGlnaHQnIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkLnNlbnRpbWVudCA/IHdvcmQuc2VudGltZW50IDogJydcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHN0eWxlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmb250LXNpemU6ICR7d29yZC5mb250U2l6ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgbGVmdDogJHsoaGFsZlNpemUgKyB3b3JkLngpIC0gKHdvcmQud2lkdGggLyAyKX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgdG9wOiAkeyhoYWxmU2l6ZSArIHdvcmQueSkgLSAod29yZC5oZWlnaHQgLyAyKX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2lkdGg6ICR7d29yZC53aWR0aH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBgaGVpZ2h0OiAke3dvcmQuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGh0bWwgZm9yIGVudHJ5XG4gICAgICAgICAgICAgICAgaHRtbCArPVxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2NsYXNzTmFtZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiJHtzdHlsZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VudGltZW50PVwiJHt3b3JkLmF2Z31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS13b3JkPVwiJHt3b3JkLmtleX1cIj4ke3dvcmQudGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXb3JkQ2xvdWQ7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBIVE1MID0gcmVxdWlyZSgnLi4vLi4vY29yZS9IVE1MJyk7XG4gICAgY29uc3QgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuICAgIGNvbnN0IHNlbnRpbWVudCA9IHJlcXVpcmUoJy4uLy4uL3NlbnRpbWVudC9TZW50aW1lbnQnKTtcbiAgICBjb25zdCBzZW50aW1lbnRGdW5jID0gc2VudGltZW50LmdldENsYXNzRnVuYygtMSwgMSk7XG5cbiAgICBjb25zdCBpc1NpbmdsZVZhbHVlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgLy8gc2luZ2xlIHZhbHVlcyBhcmUgbmV2ZXIgbnVsbCwgYW5kIGFsd2F5cyBudW1iZXJzXG4gICAgICAgIHJldHVybiBjb3VudCAhPT0gbnVsbCAmJiBfLmlzTnVtYmVyKGNvdW50KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXh0cmFjdENvdW50ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgaWYgKGlzU2luZ2xlVmFsdWUoY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbnRpbWVudC5nZXRUb3RhbChjb3VudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGV4dHJhY3RTZW50aW1lbnRDbGFzcyA9IGZ1bmN0aW9uKGF2Zykge1xuICAgICAgICBpZiAoYXZnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZW50aW1lbnRGdW5jKGF2Zyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICBjb25zdCBleHRyYWN0RnJlcXVlbmN5ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgY291bnQgPSBjb3VudC5jb3VudHMgfHwgY291bnQ7XG4gICAgICAgIGlmIChpc1NpbmdsZVZhbHVlKGNvdW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50OiBzZW50aW1lbnQuZ2V0VG90YWwoY291bnQpLFxuICAgICAgICAgICAgYXZnOiBzZW50aW1lbnQuZ2V0QXZnKGNvdW50KVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBleHRyYWN0QXZnID0gZnVuY3Rpb24oZnJlcXVlbmNpZXMpIHtcbiAgICAgICAgaWYgKGZyZXF1ZW5jaWVzWzBdLmF2ZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VtID0gXy5zdW1CeShmcmVxdWVuY2llcywgZnVuY3Rpb24oZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJlcXVlbmN5LmF2ZztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdW0gLyBmcmVxdWVuY2llcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIGNvbnN0IFdvcmRIaXN0b2dyYW0gPSBIVE1MLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBtYXhOdW1Xb3JkczogOCxcbiAgICAgICAgICAgIG1pbkZvbnRTaXplOiAxNixcbiAgICAgICAgICAgIG1heEZvbnRTaXplOiAyMlxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm0uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SGlnaGxpZ2h0OiBmdW5jdGlvbih3b3JkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgd29yZFxuICAgICAgICAgICAgJCh0aGlzLl9jb250YWluZXIpLmFkZENsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICQoYC53b3JkLWhpc3RvZ3JhbS1lbnRyeVtkYXRhLXdvcmQ9XCIke3dvcmR9XCJdYCkuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQgPSB3b3JkO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgJCgnLndvcmQtaGlzdG9ncmFtLWVudHJ5JykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtd29yZCcpO1xuICAgICAgICAgICAgaWYgKHdvcmQpIHtcbiAgICAgICAgICAgICAgICAkKGAud29yZC1oaXN0b2dyYW0tZW50cnlbZGF0YS13b3JkPVwiJHt3b3JkfVwiXWApLmFkZENsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBsYXllciBjb29yZFxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyUG9pbnQgPSB0aGlzLmdldExheWVyUG9pbnRGcm9tRXZlbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBjb29yZFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGcm9tTGF5ZXJQb2ludChsYXllclBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY2FjaGUga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgbmtleSA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29vcmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBlbnRyeVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlW25rZXldO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IGNvb3JkLnosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWNoZWQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JkLWhpc3RvZ3JhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gJChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICQoJy53b3JkLWhpc3RvZ3JhbS1lbnRyeScpLnJlbW92ZUNsYXNzKCdob3ZlcicpO1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29yZC1oaXN0b2dyYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIHVuLXNlbGVjdCBhbmQgcHJldiBzZWxlY3RlZCBoaXN0b2dyYW1cbiAgICAgICAgICAgICQoJy53b3JkLWhpc3RvZ3JhbS1lbnRyeScpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgICQodGhpcy5fY29udGFpbmVyKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAvLyBnZXQgdGFyZ2V0XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAkKGUub3JpZ2luYWxFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGFyZ2V0TGF5ZXIoZS5vcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHRhcmdldC5hdHRyKCdkYXRhLXdvcmQnKTtcbiAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaWdobGlnaHQod29yZCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGxheWVyIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJQb2ludCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIGNvb3JkXG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZyb21MYXllclBvaW50KGxheWVyUG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGdldCBjYWNoZSBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBua2V5ID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb29yZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNhY2hlIGVudHJ5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVbbmtleV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZS5vcmlnaW5hbEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjb29yZC56LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FjaGVkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29yZC1oaXN0b2dyYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0cmFjdEV4dHJlbWE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1bXMgPSBfLm1hcChkYXRhLCBjb3VudHMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnN1bUJ5KGNvdW50cywgZXh0cmFjdENvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaW46IF8ubWluKHN1bXMpLFxuICAgICAgICAgICAgICAgIG1heDogXy5tYXgoc3VtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKGtleURhdGEsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRyYWN0VmFsdWVzOiBmdW5jdGlvbihkYXRhLCBrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyZXF1ZW5jaWVzID0gXy5tYXAoZGF0YSwgZXh0cmFjdEZyZXF1ZW5jeSk7XG4gICAgICAgICAgICBjb25zdCBhdmcgPSBleHRyYWN0QXZnKGZyZXF1ZW5jaWVzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IF8ubWF4QnkoZnJlcXVlbmNpZXMsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwuY291bnQ7XG4gICAgICAgICAgICB9KS5jb3VudDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gXy5zdW1CeShmcmVxdWVuY2llcywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5jb3VudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRUZXh0KGRhdGEsIGtleSksXG4gICAgICAgICAgICAgICAgZnJlcXVlbmNpZXM6IGZyZXF1ZW5jaWVzLFxuICAgICAgICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgICAgICAgICAgICBhdmc6IGF2Z1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCBfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHQgPSB0aGlzLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgb2JqZWN0IHRvIGFycmF5XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBfLm1hcChkYXRhLCB0aGlzLmV4dHJhY3RWYWx1ZXMuYmluZCh0aGlzKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLnRvdGFsIC0gYS50b3RhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZ2V0IG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICBjb25zdCBudW1FbnRyaWVzID0gTWF0aC5taW4odmFsdWVzLmxlbmd0aCwgdGhpcy5vcHRpb25zLm1heE51bVdvcmRzKTtcbiAgICAgICAgICAgIGNvbnN0ICRodG1sID0gJCgnPGRpdiBjbGFzcz1cIndvcmQtaGlzdG9ncmFtc1wiIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgICAgICAgY29uc3QgbWluRm9udFNpemUgPSB0aGlzLm9wdGlvbnMubWluRm9udFNpemU7XG4gICAgICAgICAgICBjb25zdCBtYXhGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5tYXhGb250U2l6ZTtcbiAgICAgICAgICAgIHZhbHVlcy5zbGljZSgwLCBudW1FbnRyaWVzKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB2YWx1ZS5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9waWMgPSB2YWx1ZS50b3BpYztcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVxdWVuY2llcyA9IHZhbHVlLmZyZXF1ZW5jaWVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IHZhbHVlLm1heDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHZhbHVlLnRvdGFsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF2ZyA9IHZhbHVlLmF2ZztcbiAgICAgICAgICAgICAgICBjb25zdCBzZW50aW1lbnRDbGFzcyA9IGV4dHJhY3RTZW50aW1lbnRDbGFzcyhhdmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodENsYXNzID0gKGtleSA9PT0gaGlnaGxpZ2h0KSA/ICdoaWdobGlnaHQnIDogJyc7XG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgdGhlIGhlaWdodCBiYXNlZCBvbiBsZXZlbCBtaW4gLyBtYXhcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdGhpcy50cmFuc2Zvcm1WYWx1ZSh0b3RhbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudExhYmVsID0gTWF0aC5yb3VuZCgocGVyY2VudCAqIDEwMCkgLyAxMCkgKiAxMDtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtaW5Gb250U2l6ZSArIHBlcmNlbnQgKiAobWF4Rm9udFNpemUgLSBtaW5Gb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250YWluZXIgJ2VudHJ5JyBmb3IgY2hhcnQgYW5kIGhhc2h0YWdcbiAgICAgICAgICAgICAgICBjb25zdCAkZW50cnkgPSAkKFxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3b3JkLWhpc3RvZ3JhbS1lbnRyeSAke2hpZ2hsaWdodENsYXNzfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXNlbnRpbWVudD1cIiR7YXZnfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke2tleX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6JHtoZWlnaHR9cHg7XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY2hhcnRcbiAgICAgICAgICAgICAgICBjb25zdCAkY2hhcnQgPSAkKFxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3b3JkLWhpc3RvZ3JhbS1sZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VudGltZW50PVwiJHthdmd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtd29yZD1cIiR7a2V5fVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFyV2lkdGggPSAnY2FsYygnICsgKDEwMCAvIGZyZXF1ZW5jaWVzLmxlbmd0aCkgKyAnJSknO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBiYXJzXG4gICAgICAgICAgICAgICAgZnJlcXVlbmNpZXMuZm9yRWFjaChmcmVxdWVuY3kgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGZyZXF1ZW5jeS5jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZnID0gZnJlcXVlbmN5LmF2ZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VudGltZW50Q2xhc3MgPSBleHRyYWN0U2VudGltZW50Q2xhc3MoYXZnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwZXJjZW50IHJlbGF0aXZlIHRvIHRoZSBoaWdoZXN0IGNvdW50IGluIHRoZSB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGVyY2VudCA9IChtYXggIT09IDApID8gKGNvdW50IC8gbWF4KSAqIDEwMCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgaW52aXNpYmxlIGlmIHplcm8gY291bnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IHJlbGF0aXZlUGVyY2VudCA9PT0gMCA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHN0eWxlIGNsYXNzIG9mIHRoZSBiYXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudExhYmVsID0gTWF0aC5yb3VuZChyZWxhdGl2ZVBlcmNlbnQgLyAxMCkgKiAxMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFyQ2xhc3NlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd29yZC1oaXN0b2dyYW0tYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgd29yZC1oaXN0b2dyYW0tYmFyLSR7cGVyY2VudExhYmVsfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7c2VudGltZW50Q2xhc3N9LWZpbGxgXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhclRvcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoZXJlIGlzIGF0IGxlYXN0IGEgc2luZ2xlIHBpeGVsIG9mIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmICgocmVsYXRpdmVQZXJjZW50IC8gMTAwKSAqIGhlaWdodCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhckhlaWdodCA9ICczcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyVG9wID0gJ2NhbGMoMTAwJSAtIDNweCknO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFySGVpZ2h0ID0gYCR7cmVsYXRpdmVQZXJjZW50fSVgO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyVG9wID0gYCR7MTAwIC0gcmVsYXRpdmVQZXJjZW50fSVgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBiYXJcbiAgICAgICAgICAgICAgICAgICAgJGNoYXJ0LmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2JhckNsYXNzZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXdvcmQ9XCIke2tleX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJHt2aXNpYmlsaXR5fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJHtiYXJXaWR0aH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke2JhckhlaWdodH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAke2JhclRvcH07XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICRlbnRyeS5hcHBlbmQoJGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BpY0NsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3b3JkLWhpc3RvZ3JhbS1sYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIGB3b3JkLWhpc3RvZ3JhbS1sYWJlbC0ke3BlcmNlbnRMYWJlbH1gLFxuICAgICAgICAgICAgICAgICAgICBzZW50aW1lbnRDbGFzc1xuICAgICAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0YWcgbGFiZWxcbiAgICAgICAgICAgICAgICBjb25zdCAkdG9waWMgPSAkKFxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3b3JkLWhpc3RvZ3JhbS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7dG9waWNDbGFzc2VzfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZW50aW1lbnQ9XCIke2F2Z31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtd29yZD1cIiR7a2V5fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogJHtoZWlnaHR9cHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6ICR7aGVpZ2h0fXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtoZWlnaHR9cHg7XCI+JHt0b3BpY308L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgICRlbnRyeS5hcHBlbmQoJHRvcGljKTtcbiAgICAgICAgICAgICAgICAkaHRtbC5hcHBlbmQoJGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGh0bWwuY3NzKCd0b3AnLCAodGhpcy5vcHRpb25zLnRpbGVTaXplIC8gMikgLSAodG90YWxIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJGh0bWxbMF0ub3V0ZXJIVE1MO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFdvcmRIaXN0b2dyYW07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IC0oTWF0aC5yYW5kb20oKSAqIERFTEFZKTtcbiAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJibGlua2luZyBibGlua2luZy10aWxlXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6JHtkZWxheX1tc1wiPjwvZGl2PmA7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IC0oTWF0aC5yYW5kb20oKSAqIERFTEFZKTtcbiAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZlcnRpY2FsLWNlbnRlcmVkLWJveCBibGlua2luZ1wiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWNpcmNsZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lLW1hc2tcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheTogJHtkZWxheX1tc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkZXItbGluZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBERUxBWSA9IDEyMDA7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICByZW5kZXJUaWxlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IC0oTWF0aC5yYW5kb20oKSAqIERFTEFZKTtcbiAgICAgICAgICAgICAgICBpZiAoJChlbGVtKS5oYXNDbGFzcygncGVuZGluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJibGlua2luZyBibGlua2luZy10aWxlXCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj48L2Rpdj5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIERFTEFZKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IERFTEFZID0gMTIwMDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gLShNYXRoLnJhbmRvbSgpICogREVMQVkpO1xuICAgICAgICAgICAgICAgIGlmICgkKGVsZW0pLmhhc0NsYXNzKCdwZW5kaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZlcnRpY2FsLWNlbnRlcmVkLWJveFwiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1jaXJjbGVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lLW1hc2tcIiBzdHlsZT1cImFuaW1hdGlvbi1kZWxheTogJHtkZWxheX1tc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIERFTEFZKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IERFTEFZID0gMTIwMDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gLShNYXRoLnJhbmRvbSgpICogREVMQVkpO1xuICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidmVydGljYWwtY2VudGVyZWQtYm94XCIgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6ICR7ZGVsYXl9bXNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkZXItY2lyY2xlXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGVyLWxpbmUtbWFza1wiIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiAke2RlbGF5fW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRlci1saW5lXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IGVzcGVyID0gcmVxdWlyZSgnZXNwZXInKTtcbiAgICBjb25zdCBXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvV2ViR0wnKTtcbiAgICBjb25zdCBWZXJ0ZXhBdGxhcyA9IHJlcXVpcmUoJy4vVmVydGV4QXRsYXMnKTtcbiAgICBjb25zdCBTaGFkZXJzID0gcmVxdWlyZSgnLi9TaGFkZXJzJyk7XG4gICAgY29uc3QgU2hhcGVzID0gcmVxdWlyZSgnLi9TaGFwZXMnKTtcblxuICAgIGNvbnN0IFRJTEVfU0laRSA9IDI1NjtcbiAgICBjb25zdCBOVU1fU0xJQ0VTID0gNjQ7XG4gICAgY29uc3QgUE9JTlRfUkFESVVTID0gMjtcblxuICAgIGNvbnN0IENsdXN0ZXIgPSBXZWJHTC5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG91dGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIG91dGxpbmVDb2xvcjogWzAuMCwgMC4wLCAwLjAsIDEuMF0sXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFswLjIsIDAuMTUsIDAuNCwgMC41XSxcbiAgICAgICAgICAgIHJhZGl1czogUE9JTlRfUkFESVVTLFxuICAgICAgICAgICAgYmxlbmRpbmc6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBjaXJjbGUgdmVydGV4YnVmZmVyXG4gICAgICAgICAgICB0aGlzLl9jaXJjbGVGaWxsQnVmZmVyID0gU2hhcGVzLmNpcmNsZS5maWxsKE5VTV9TTElDRVMpO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlT3V0bGluZUJ1ZmZlciA9IFNoYXBlcy5jaXJjbGUub3V0bGluZShOVU1fU0xJQ0VTKTtcbiAgICAgICAgICAgIC8vIHZlcnRleCBhdGxhcyBmb3IgYWxsIHRpbGVzXG4gICAgICAgICAgICB0aGlzLl9hdGxhcyA9IG5ldyBWZXJ0ZXhBdGxhcyh7XG4gICAgICAgICAgICAgICAgMToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBsb2FkIHNoYWRlclxuICAgICAgICAgICAgdGhpcy5fc2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgdmVydDogU2hhZGVycy5pbnN0YW5jZWRQb2ludC52ZXJ0LFxuICAgICAgICAgICAgICAgIGZyYWc6IFNoYWRlcnMuaW5zdGFuY2VkUG9pbnQuZnJhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGV2ZW50LmNvb3JkcztcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KGNhY2hlZC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBNYXRoLnNxcnQoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRXaWR0aCA9IFRJTEVfU0laRSAvIHJlc29sdXRpb247XG4gICAgICAgICAgICBjb25zdCBoYWxmV2lkdGggPSBwb2ludFdpZHRoIC8gMjtcbiAgICAgICAgICAgIGxldCBudW1Qb2ludHMgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbiA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJpbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IChpICUgcmVzb2x1dGlvbikgKiBwb2ludFdpZHRoICsgaGFsZldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihpIC8gcmVzb2x1dGlvbikgKiBwb2ludFdpZHRoICsgaGFsZldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcG9pbnQgdG8gYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tudW1Qb2ludHMgKiAyXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tudW1Qb2ludHMgKiAyICsgMV0gPSAoVElMRV9TSVpFIC0geSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCBwb2ludCBjb3VudFxuICAgICAgICAgICAgICAgICAgICBudW1Qb2ludHMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlZC5udW1Qb2ludHMgPSBudW1Qb2ludHM7XG4gICAgICAgICAgICBpZiAobnVtUG9pbnRzID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5jb29yZHMgPSB0aGlzLmdldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChuY29vcmRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdGxhcy5hZGRUaWxlKGhhc2gsIHBvc2l0aW9ucywgbnVtUG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlVW5sb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICBpZiAoY2FjaGVkLm51bVBvaW50cyA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWNoZWQubnVtUG9pbnRzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBuY29vcmRzID0gdGhpcy5nZXROb3JtYWxpemVkQ29vcmRzKGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQobmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXRsYXMucmVtb3ZlVGlsZShoYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3SW5zdGFuY2VkOiBmdW5jdGlvbihjaXJjbGUsIGNvbG9yLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9zaGFkZXI7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBjb25zdCBhdGxhcyA9IHRoaXMuX2F0bGFzO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ibGVuZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBibGVuZGluZ1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSBzaGFkZXJcbiAgICAgICAgICAgIHNoYWRlci51c2UoKTtcbiAgICAgICAgICAgIC8vIHNldCB1bmlmb3Jtc1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VDb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UmFkaXVzJywgcmFkaXVzKTtcbiAgICAgICAgICAgIC8vIGNhbGMgdmlldyBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZmZzZXQgPSB0aGlzLmdldFZpZXdPZmZzZXQoKTtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGNpcmNsZSB0byBpbnN0YW5jZVxuICAgICAgICAgICAgY2lyY2xlLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGJpbmQgb2Zmc2V0cyBhbmQgZW5hYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGF0bGFzLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGFsbG9jYXRlZCBjaHVua1xuICAgICAgICAgICAgYXRsYXMuZm9yRWFjaCgoY2h1bmssIGhhc2gpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0aWxlIHJlZmVycmluZyB0byB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2hhc2hdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZvciBlYWNoIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgXy5rZXlzKGNhY2hlZC50aWxlcykuZm9yRWFjaChoYXNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuY29vcmRGcm9tQ2FjaGVLZXkoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRzLnogIT09IHpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgd3JhcCBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBPZmZzZXQgPSB0aGlzLmdldFdyYXBBcm91bmRPZmZzZXQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZU9mZnNldCA9IHRoaXMuZ2V0VGlsZU9mZnNldChjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCB0aWxlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZU9mZnNldFswXSArIHdyYXBPZmZzZXRbMF0gLSB2aWV3T2Zmc2V0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVPZmZzZXRbMV0gKyB3cmFwT2Zmc2V0WzFdIC0gdmlld09mZnNldFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1VGlsZU9mZnNldCcsIHRvdGFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRsYXMuZHJhdyhoYXNoLCBjaXJjbGUubW9kZSwgY2lyY2xlLmNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGF0bGFzLnVuYmluZCgpO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgY2lyY2xlLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNldHVwXG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcbiAgICAgICAgICAgIHZpZXdwb3J0LnB1c2goKTtcbiAgICAgICAgICAgIC8vIGRyYXcgaW5zdGFuY2VkIGZpbGxcbiAgICAgICAgICAgIHRoaXMuZHJhd0luc3RhbmNlZChcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVGaWxsQnVmZmVyLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJhZGl1cyk7XG4gICAgICAgICAgICAvLyBkcmF3IGluc3RhbmNlZCBvdXRsaW5lc1xuICAgICAgICAgICAgZ2wubGluZVdpZHRoKHRoaXMub3B0aW9ucy5vdXRsaW5lV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3SW5zdGFuY2VkKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZU91dGxpbmVCdWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm91dGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmFkaXVzKTtcbiAgICAgICAgICAgIC8vIHRlYXJkb3duXG4gICAgICAgICAgICB2aWV3cG9ydC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsdXN0ZXI7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBlc3BlciA9IHJlcXVpcmUoJ2VzcGVyJyk7XG4gICAgY29uc3QgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuICAgIGNvbnN0IFZhbHVlVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vVmFsdWVUcmFuc2Zvcm0nKTtcbiAgICBjb25zdCBXZWJHTCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvV2ViR0wnKTtcbiAgICBjb25zdCBWZXJ0ZXhBdGxhcyA9IHJlcXVpcmUoJy4vVmVydGV4QXRsYXMnKTtcbiAgICBjb25zdCBTaGFkZXJzID0gcmVxdWlyZSgnLi9TaGFkZXJzJyk7XG4gICAgY29uc3QgU2hhcGVzID0gcmVxdWlyZSgnLi9TaGFwZXMnKTtcblxuICAgIGNvbnN0IFRJTEVfU0laRSA9IDI1NjtcbiAgICBjb25zdCBOVU1fU0xJQ0VTID0gMzYwO1xuICAgIGNvbnN0IFJBRElVUyA9IDEwO1xuXG4gICAgY29uc3QgQ2x1c3RlciA9IFdlYkdMLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvdXRsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBvdXRsaW5lQ29sb3I6IFswLjAsIDAuMCwgMC4wLCAxLjBdLFxuICAgICAgICAgICAgcmluZ1dpZHRoOiAzLFxuICAgICAgICAgICAgcmluZ09mZnNldDogMCxcbiAgICAgICAgICAgIHJhZGl1c0ZpZWxkOiAnbm9kZS5yYWRpdXMnLFxuICAgICAgICAgICAgdGlja1dpZHRoOiAyLFxuICAgICAgICAgICAgdGlja0hlaWdodDogOFxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZ2hsaWdodGVkOiBudWxsLFxuICAgICAgICBzZWxlY3RlZDogbnVsbCxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gcmluZyB2ZXJ0ZXhidWZmZXJzXG4gICAgICAgICAgICBjb25zdCBmdWxsV2lkdGggPSB0aGlzLm9wdGlvbnMucmluZ1dpZHRoICsgdGhpcy5vcHRpb25zLm91dGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3JpbmdGaWxsQnVmZmVyID0gU2hhcGVzLnJpbmcuZmlsbChcbiAgICAgICAgICAgICAgICBOVU1fU0xJQ0VTLFxuICAgICAgICAgICAgICAgIFJBRElVUyxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmluZ1dpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuX3JpbmdPdXRsaW5lQnVmZmVyID0gU2hhcGVzLnJpbmcuZmlsbChcbiAgICAgICAgICAgICAgICBOVU1fU0xJQ0VTLFxuICAgICAgICAgICAgICAgIFJBRElVUyxcbiAgICAgICAgICAgICAgICBmdWxsV2lkdGgpO1xuICAgICAgICAgICAgLy8gcXVhZCB2ZXJ0ZXhidWZmZXJcbiAgICAgICAgICAgIHRoaXMuX3F1YWRCdWZmZXIgPSBTaGFwZXMucXVhZC5maWxsKFxuICAgICAgICAgICAgICAgIC10aGlzLm9wdGlvbnMudGlja1dpZHRoLzIsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRpY2tXaWR0aC8yLFxuICAgICAgICAgICAgICAgIC1mdWxsV2lkdGgvMixcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGlja0hlaWdodCk7XG4gICAgICAgICAgICAvLyB2ZXJ0ZXggYXRsYXMgZm9yIGFsbCB0aWxlc1xuICAgICAgICAgICAgdGhpcy5fYXRsYXMgPSBuZXcgVmVydGV4QXRsYXMoe1xuICAgICAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZMT0FUJyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgMjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgc3BhdGlhbCBpbmRleFxuICAgICAgICAgICAgdGhpcy5fcnRyZWUgPSBuZXcgcmJ1c2goKTtcbiAgICAgICAgICAgIC8vIGxvYWQgc2hhZGVyc1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VkU2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgdmVydDogU2hhZGVycy5pbnN0YW5jZWRSaW5nLnZlcnQsXG4gICAgICAgICAgICAgICAgZnJhZzogU2hhZGVycy5pbnN0YW5jZWRSaW5nLmZyYWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5kaXZpZHVhbFNoYWRlciA9IG5ldyBlc3Blci5TaGFkZXIoe1xuICAgICAgICAgICAgICAgIHZlcnQ6IFNoYWRlcnMucmluZy52ZXJ0LFxuICAgICAgICAgICAgICAgIGZyYWc6IFNoYWRlcnMucmluZy5mcmFnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlZFRpY2tTaGFkZXIgPSBuZXcgZXNwZXIuU2hhZGVyKHtcbiAgICAgICAgICAgICAgICB2ZXJ0OiBTaGFkZXJzLmluc3RhbmNlZFRpY2sudmVydCxcbiAgICAgICAgICAgICAgICBmcmFnOiBTaGFkZXJzLmluc3RhbmNlZFRpY2suZnJhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZUxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGV2ZW50LmNvb3JkcztcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjYWNoZWQuZGF0YTtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhZGl1c09mZnNldCA9XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJpbmdPZmZzZXQgK1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yaW5nV2lkdGggK1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vdXRsaW5lV2lkdGg7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGggKiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbGVPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgeDogY29vcmRzLnggKiBUSUxFX1NJWkUsXG4gICAgICAgICAgICAgICAgeTogY29vcmRzLnkgKiBUSUxFX1NJWkUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGlsZVBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICBjb25zdCBsYXllclBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tdW5pdHkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG52YWwgPSB0aGlzLnRyYW5zZm9ybVZhbHVlKF8uZ2V0KGNvbW11bml0eSwgdGhpcy5vcHRpb25zLmRlZ3JlZUZpZWxkKSk7XG4gICAgICAgICAgICAgICAgaWYgKG52YWwgPCB0aGlzLm9wdGlvbnMuY29tbXVuaXR5VGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBjb29yZHMueik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoNCwgXy5nZXQoY29tbXVuaXR5LCB0aGlzLm9wdGlvbnMucmFkaXVzRmllbGQpICogc2NhbGUpICsgcmFkaXVzT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVTcGFuID0gTWF0aC5wb3coMiwgMzIpIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeFZhbCA9IF8uZ2V0KGNvbW11bml0eSwgdGhpcy5nZXRYRmllbGQoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeVZhbCA9IF8uZ2V0KGNvbW11bml0eSwgdGhpcy5nZXRZRmllbGQoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9ICgoeFZhbCAlIHRpbGVTcGFuKSAvIHRpbGVTcGFuKSAqIFRJTEVfU0laRTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gKCh5VmFsICUgdGlsZVNwYW4pIC8gdGlsZVNwYW4pICogVElMRV9TSVpFO1xuICAgICAgICAgICAgICAgIC8vIGdldCBwb3NpdGlvbiBpbiB0aWxlXG4gICAgICAgICAgICAgICAgdGlsZVBvaW50LnggPSB4O1xuICAgICAgICAgICAgICAgIHRpbGVQb2ludC55ID0gVElMRV9TSVpFIC0geTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgcG9zaXRpb24gaW4gbGF5ZXJcbiAgICAgICAgICAgICAgICBsYXllclBvaW50LnggPSB4ICsgdGlsZU9mZnNldC54O1xuICAgICAgICAgICAgICAgIGxheWVyUG9pbnQueSA9IHkgKyB0aWxlT2Zmc2V0Lnk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgcG9pbnRcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRpbGVQb2ludC54LFxuICAgICAgICAgICAgICAgICAgICB5OiB0aWxlUG9pbnQueSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIG1pblg6IGxheWVyUG9pbnQueCAtIHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogbGF5ZXJQb2ludC54ICsgcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBsYXllclBvaW50LnkgLSByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IGxheWVyUG9pbnQueSArIHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29tbXVuaXR5LFxuICAgICAgICAgICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBwb2ludCB0byBidWZmZXJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpICogM10gPSB0aWxlUG9pbnQueDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDFdID0gdGlsZVBvaW50Lnk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAyXSA9IHJhZGl1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGJ1bGsgaW5zZXJ0IHBvaW50cyB0byB0aGUgcnRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLl9ydHJlZS5sb2FkKHBvaW50cyk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgcG9pbnRzIGluIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgIGNhY2hlZC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgICAgICAgICAgY29uc3QgbmNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKG5jb29yZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0bGFzLmFkZFRpbGUoaGFzaCwgdmVydGljZXMsIHBvaW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVVbmxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBldmVudC5lbnRyeTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGF0bGFzXG4gICAgICAgICAgICAgICAgY29uc3QgbmNvb3JkcyA9IHRoaXMuZ2V0Tm9ybWFsaXplZENvb3Jkcyhjb29yZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmNhY2hlS2V5RnJvbUNvb3JkKG5jb29yZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0bGFzLnJlbW92ZVRpbGUoaGFzaCk7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gcnRyZWVcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBjYWNoZWQucG9pbnRzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnRyZWUucmVtb3ZlKHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhY2hlZC5wb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJQaXhlbCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9IHRoaXMuX3J0cmVlLnNlYXJjaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbGF5ZXJQaXhlbC54LFxuICAgICAgICAgICAgICAgIG1heFg6IGxheWVyUGl4ZWwueCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBsYXllclBpeGVsLnksXG4gICAgICAgICAgICAgICAgbWF4WTogbGF5ZXJQaXhlbC55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zWzBdO1xuICAgICAgICAgICAgICAgIC8vIG1pbWljIG1vdXNlb3ZlciAvIG1vdXNlb3V0IGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkLnZhbHVlICE9PSBjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgbW91c2VvdXQgZm9yIG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGlnaGxpZ2h0ZWQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBtb3VzZW92ZXIgZm9yIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3VzZW92ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gcHJldmlvdXMgY29sbGlzaW9uLCBleGVjdXRlIG1vdXNlb3ZlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVzZSBjb2xsaXNpb24gcG9pbnQgdG8gZmluZCB0aWxlXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29sbGlzaW9uLmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBoaWdobGlnaHRlZFxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB0aGlzLl9jYWNoZVtoYXNoXS50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBjb2xsaXNpb24ucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24ueVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yXG4gICAgICAgICAgICAgICAgJCh0aGlzLl9tYXAuX2NvbnRhaW5lcikuY3NzKCdjdXJzb3InLCAncG9pbnRlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vdXNlIG91dFxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhpZ2hsaWdodGVkLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBoaWdobGlnaHRlZCBmbGFnXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJQaXhlbCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9IHRoaXMuX3J0cmVlLnNlYXJjaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbGF5ZXJQaXhlbC54LFxuICAgICAgICAgICAgICAgIG1heFg6IGxheWVyUGl4ZWwueCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBsYXllclBpeGVsLnksXG4gICAgICAgICAgICAgICAgbWF4WTogbGF5ZXJQaXhlbC55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zWzBdO1xuICAgICAgICAgICAgICAgIC8vIHVzZSBjb2xsaXNpb24gcG9pbnQgdG8gZmluZCB0aWxlXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29sbGlzaW9uLmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB0aGlzLl9jYWNoZVtoYXNoXS50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBjb2xsaXNpb24ucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24ueVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhd0luc3RhbmNlZE91dGxpbmU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9pbnN0YW5jZWRTaGFkZXI7XG4gICAgICAgICAgICBjb25zdCByaW5nID0gdGhpcy5fcmluZ091dGxpbmVCdWZmZXI7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBjb25zdCBhdGxhcyA9IHRoaXMuX2F0bGFzO1xuICAgICAgICAgICAgLy8gdXNlIHNoYWRlclxuICAgICAgICAgICAgc2hhZGVyLnVzZSgpO1xuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm1zXG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCB0aGlzLmdldFByb2plY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VEZWdyZWVzJywgMzYwKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UmFkaXVzT2Zmc2V0JywgUkFESVVTKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIC8vIGNhbGMgdmlldyBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZmZzZXQgPSB0aGlzLmdldFZpZXdPZmZzZXQoKTtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGNpcmNsZSB0byBpbnN0YW5jZVxuICAgICAgICAgICAgcmluZy5iaW5kKCk7XG4gICAgICAgICAgICAvLyBiaW5kIG9mZnNldHMgYW5kIGVuYWJsZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICBhdGxhcy5iaW5kKCk7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBhbGxvY2F0ZWQgY2h1bmtcbiAgICAgICAgICAgIGF0bGFzLmZvckVhY2goKGNodW5rLCBoYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdGlsZSByZWZlcnJpbmcgdG8gdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtoYXNoXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciBmb3IgZWFjaCB0aWxlXG4gICAgICAgICAgICAgICAgICAgIF8ua2V5cyhjYWNoZWQudGlsZXMpLmZvckVhY2goaGFzaCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29yZHMgPSB0aGlzLmNvb3JkRnJvbUNhY2hlS2V5KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjaGVjayBoZXJlIGlmIHRoZSB0aWxlcyBhcmUgc3RhbGUgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHdyYXAgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cmFwT2Zmc2V0ID0gdGhpcy5nZXRXcmFwQXJvdW5kT2Zmc2V0KGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVPZmZzZXQgPSB0aGlzLmdldFRpbGVPZmZzZXQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsT2Zmc2V0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVPZmZzZXRbMF0gKyB3cmFwT2Zmc2V0WzBdIC0gdmlld09mZnNldFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlT2Zmc2V0WzFdICsgd3JhcE9mZnNldFsxXSAtIHZpZXdPZmZzZXRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCB0b3RhbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0bGFzLmRyYXcoaGFzaCwgcmluZy5tb2RlLCByaW5nLmNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGF0bGFzLnVuYmluZCgpO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgcmluZy51bmJpbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3SW5zdGFuY2VkRmlsbDogZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuX2luc3RhbmNlZFNoYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHJpbmcgPSB0aGlzLl9yaW5nRmlsbEJ1ZmZlcjtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICBjb25zdCB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGF0bGFzID0gdGhpcy5fYXRsYXM7XG4gICAgICAgICAgICAvLyB1c2Ugc2hhZGVyXG4gICAgICAgICAgICBzaGFkZXIudXNlKCk7XG4gICAgICAgICAgICAvLyBzZXQgdW5pZm9ybXNcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UmFkaXVzT2Zmc2V0JywgUkFESVVTKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIC8vIGNhbGMgdmlldyBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZmZzZXQgPSB0aGlzLmdldFZpZXdPZmZzZXQoKTtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGNpcmNsZSB0byBpbnN0YW5jZVxuICAgICAgICAgICAgcmluZy5iaW5kKCk7XG4gICAgICAgICAgICAvLyBiaW5kIG9mZnNldHMgYW5kIGVuYWJsZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICBhdGxhcy5iaW5kKCk7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBhbGxvY2F0ZWQgY2h1bmtcbiAgICAgICAgICAgIGF0bGFzLmZvckVhY2goKGNodW5rLCBoYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdGlsZSByZWZlcnJpbmcgdG8gdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtoYXNoXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCBzZWdtZW50LmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1RGVncmVlcycsIHNlZ21lbnQucGVyY2VudCAqIDM2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgZm9yIGVhY2ggdGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5rZXlzKGNhY2hlZC50aWxlcykuZm9yRWFjaChoYXNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29yZHMgPSB0aGlzLmNvb3JkRnJvbUNhY2hlS2V5KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb29yZHMueiAhPT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgd3JhcCBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cmFwT2Zmc2V0ID0gdGhpcy5nZXRXcmFwQXJvdW5kT2Zmc2V0KGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZU9mZnNldCA9IHRoaXMuZ2V0VGlsZU9mZnNldChjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbE9mZnNldCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZU9mZnNldFswXSArIHdyYXBPZmZzZXRbMF0gLSB2aWV3T2Zmc2V0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlT2Zmc2V0WzFdICsgd3JhcE9mZnNldFsxXSAtIHZpZXdPZmZzZXRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1VGlsZU9mZnNldCcsIHRvdGFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdGxhcy5kcmF3KGhhc2gsIHJpbmcubW9kZSwgcmluZy5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGF0bGFzLnVuYmluZCgpO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgcmluZy51bmJpbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3SW5zdGFuY2VkVGljazogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuX2luc3RhbmNlZFRpY2tTaGFkZXI7XG4gICAgICAgICAgICBjb25zdCBxdWFkID0gdGhpcy5fcXVhZEJ1ZmZlcjtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICBjb25zdCB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGF0bGFzID0gdGhpcy5fYXRsYXM7XG4gICAgICAgICAgICAvLyB1c2Ugc2hhZGVyXG4gICAgICAgICAgICBzaGFkZXIudXNlKCk7XG4gICAgICAgICAgICAvLyBzZXQgdW5pZm9ybXNcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCBjb2xvcik7XG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCB0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgICAgICAgICAvLyBjYWxjIHZpZXcgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCB2aWV3T2Zmc2V0ID0gdGhpcy5nZXRWaWV3T2Zmc2V0KCk7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBjaXJjbGUgdG8gaW5zdGFuY2VcbiAgICAgICAgICAgIHF1YWQuYmluZCgpO1xuICAgICAgICAgICAgLy8gYmluZCBvZmZzZXRzIGFuZCBlbmFibGUgaW5zdGFuY2luZ1xuICAgICAgICAgICAgYXRsYXMuYmluZCgpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggYWxsb2NhdGVkIGNodW5rXG4gICAgICAgICAgICBhdGxhcy5mb3JFYWNoKChjaHVuaywgaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHRpbGUgcmVmZXJyaW5nIHRvIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVbaGFzaF07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgZm9yIGVhY2ggdGlsZVxuICAgICAgICAgICAgICAgICAgICBfLmtleXMoY2FjaGVkLnRpbGVzKS5mb3JFYWNoKGhhc2ggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5jb29yZEZyb21DYWNoZUtleShoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb29yZHMueiAhPT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY2hlY2sgaGVyZSBpZiB0aGUgdGlsZXMgYXJlIHN0YWxlIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB3cmFwIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JhcE9mZnNldCA9IHRoaXMuZ2V0V3JhcEFyb3VuZE9mZnNldChjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRpbGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlT2Zmc2V0ID0gdGhpcy5nZXRUaWxlT2Zmc2V0KGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHRpbGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbE9mZnNldCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlT2Zmc2V0WzBdICsgd3JhcE9mZnNldFswXSAtIHZpZXdPZmZzZXRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZU9mZnNldFsxXSArIHdyYXBPZmZzZXRbMV0gLSB2aWV3T2Zmc2V0WzFdXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VUaWxlT2Zmc2V0JywgdG90YWxPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBhdGxhcy5kcmF3KGhhc2gsIHF1YWQubW9kZSwgcXVhZC5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICBhdGxhcy51bmJpbmQoKTtcbiAgICAgICAgICAgIC8vIHVuYmluZCBidWZmZXJcbiAgICAgICAgICAgIHF1YWQudW5iaW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhd0luZGl2aWR1YWxGaWxsOiBmdW5jdGlvbihzZWdtZW50cywgdGlsZXMsIHBvaW50LCByYWRpdXMpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgc2VsZWN0ZWQgcG9pbnRzXG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9pbmRpdmlkdWFsU2hhZGVyO1xuICAgICAgICAgICAgY29uc3QgcmluZyA9IHRoaXMuX3JpbmdGaWxsQnVmZmVyO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICAgICAgICAgIHJpbmcuYmluZCgpO1xuICAgICAgICAgICAgLy8gdXNlIHNoYWRlclxuICAgICAgICAgICAgc2hhZGVyLnVzZSgpO1xuICAgICAgICAgICAgLy8gdXNlIHVuaWZvcm0gZm9yIG9mZnNldFxuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgdGhpcy5nZXRQcm9qZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VSYWRpdXNPZmZzZXQnLCBSQURJVVMpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VSYWRpdXMnLCByYWRpdXMpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VPcGFjaXR5JywgdGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgICAgICAgICAgLy8gdmlldyBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZmZzZXQgPSB0aGlzLmdldFZpZXdPZmZzZXQoKTtcblxuICAgICAgICAgICAgc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCBzZWdtZW50LmNvbG9yKTtcbiAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndURlZ3JlZXMnLCBzZWdtZW50LnBlcmNlbnQgKiAzNjApO1xuICAgICAgICAgICAgICAgIF8uZm9ySW4odGlsZXMsIHRpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS5jb29yZHMueiAhPT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjaGVjayBoZXJlIGlmIHRoZSB0aWxlcyBhcmUgc3RhbGUgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHdyYXAgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBPZmZzZXQgPSB0aGlzLmdldFdyYXBBcm91bmRPZmZzZXQodGlsZS5jb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZU9mZnNldCA9IHRoaXMuZ2V0VGlsZU9mZnNldCh0aWxlLmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlT2Zmc2V0WzBdICsgd3JhcE9mZnNldFswXSAtIHZpZXdPZmZzZXRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlT2Zmc2V0WzFdICsgd3JhcE9mZnNldFsxXSAtIHZpZXdPZmZzZXRbMV1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VUaWxlT2Zmc2V0JywgdG90YWxPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndU9mZnNldCcsIHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmluZy5kcmF3KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHVuYmluZCB0aGUgYnVmZmVyXG4gICAgICAgICAgICByaW5nLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNldHVwXG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcbiAgICAgICAgICAgIHZpZXdwb3J0LnB1c2goKTtcblxuICAgICAgICAgICAgLy8gVEVNUFxuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogWyAwLjIsIDAuMiwgMC4yLCAxLjAgXSxcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogWyAwLjQsIDAuNCwgMC40LCAxLjAgXSxcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogMC44XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBbIDAuOCwgMC44LCAwLjgsIDEuMCBdLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiAwLjRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFNlZ21lbnRzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFsgMC40LCAwLjQsIDAuNCwgMS4wIF0sXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFsgMC42LCAwLjYsIDAuNiwgMS4wIF0sXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQ6IDAuOFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogWyAxLjAsIDEuMCwgMS4wLCAxLjAgXSxcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogMC40XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgLy8gZGlzYWJsZSBibGVuZGluZ1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgaW5zdGFuY2VkIG91dGxpbmVzXG4gICAgICAgICAgICB0aGlzLmRyYXdJbnN0YW5jZWRPdXRsaW5lKHRoaXMub3B0aW9ucy5vdXRsaW5lQ29sb3IpO1xuICAgICAgICAgICAgLy8gZHJhdyBpbnN0YW5jZWQgZmlsbFxuICAgICAgICAgICAgdGhpcy5kcmF3SW5zdGFuY2VkRmlsbChzZWdtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJhdyBpbmRpdmlkdWFsIGZpbGxcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbmRpdmlkdWFsRmlsbChcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRTZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZC50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZC5wb2ludCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZC5yYWRpdXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgaW5kaXZpZHVhbCBmaWxsXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3SW5kaXZpZHVhbEZpbGwoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQudGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQucG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQucmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZHJhdyBpbnN0YW5jZWQgdGlja1xuICAgICAgICAgICAgdGhpcy5kcmF3SW5zdGFuY2VkVGljayh0aGlzLm9wdGlvbnMub3V0bGluZUNvbG9yKTtcblxuICAgICAgICAgICAgLy8gdGVhcmRvd25cbiAgICAgICAgICAgIHZpZXdwb3J0LnBvcCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsdXN0ZXI7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBlc3BlciA9IHJlcXVpcmUoJ2VzcGVyJyk7XG4gICAgY29uc3QgV2ViR0wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL1dlYkdMJyk7XG4gICAgY29uc3QgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG4gICAgY29uc3QgVmFsdWVUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi9taXhpbi9WYWx1ZVRyYW5zZm9ybScpO1xuICAgIGNvbnN0IFRleHR1cmVBdGxhcyA9IHJlcXVpcmUoJy4vVGV4dHVyZUF0bGFzJyk7XG4gICAgY29uc3QgU2hhZGVycyA9IHJlcXVpcmUoJy4vU2hhZGVycycpO1xuICAgIGNvbnN0IFNoYXBlcyA9IHJlcXVpcmUoJy4vU2hhcGVzJyk7XG5cbiAgICBjb25zdCBUSUxFX1NJWkUgPSAyNTY7XG5cbiAgICBmdW5jdGlvbiBlbmNvZGUoZW5jLCB2YWwpIHtcbiAgICAgICAgZW5jWzBdID0gKHZhbCAvIDE2Nzc3MjE2LjApICYgMHhGRjtcbiAgICAgICAgZW5jWzFdID0gKHZhbCAvIDY1NTM2LjApICYgMHhGRjtcbiAgICAgICAgZW5jWzJdID0gKHZhbCAvIDI1Ni4wKSAmIDB4RkY7XG4gICAgICAgIGVuY1szXSA9IHZhbCAmIDB4RkY7XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgfVxuXG4gICAgY29uc3QgSGVhdG1hcCA9IFdlYkdMLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtcbiAgICAgICAgICAgIC8vIG1peGluc1xuICAgICAgICAgICAgQ29sb3JSYW1wLFxuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm1cbiAgICAgICAgXSxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gcXVhZCBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuX3F1YWRCdWZmZXIgPSBTaGFwZXMucXVhZC50ZXh0dXJlZChUSUxFX1NJWkUpO1xuICAgICAgICAgICAgLy8gdGV4dHVyZSBhdGxhcyBmb3IgYWxsIHRpbGVzXG4gICAgICAgICAgICB0aGlzLl9hdGxhcyA9IG5ldyBUZXh0dXJlQXRsYXMoKTtcbiAgICAgICAgICAgIC8vIGxvYWQgc2hhZGVyXG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIgPSBuZXcgZXNwZXIuU2hhZGVyKHtcbiAgICAgICAgICAgICAgICB2ZXJ0OiBTaGFkZXJzLmhlYXRtYXAudmVydCxcbiAgICAgICAgICAgICAgICBmcmFnOiBTaGFkZXJzLmhlYXRtYXAuZnJhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBDb2xvclJhbXAuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgVmFsdWVUcmFuc2Zvcm0uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2FjaGVMb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICBpZiAoY2FjaGVkLmRhdGEgJiYgY2FjaGVkLmRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdG8gYXRsYXNcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRpbGVUZXh0dXJlKGNhY2hlZCwgY29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlVW5sb2FkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gZXZlbnQuZW50cnk7XG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICBpZiAoY2FjaGVkLnN1bSA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWNoZWQuc3VtID0gMDtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBhdGxhc1xuICAgICAgICAgICAgICAgIGNvbnN0IG5jb29yZHMgPSB0aGlzLmdldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChuY29vcmRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdGxhcy5yZW1vdmVUaWxlKGhhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1ZmZlclRpbGVUZXh0dXJlOiBmdW5jdGlvbihjYWNoZWQsIGNvb3Jkcykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkoY2FjaGVkLmRhdGEpO1xuICAgICAgICAgICAgY29uc3QgYmlucyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICogNCk7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGxldCBiaW4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiaW4gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaW47XG4gICAgICAgICAgICAgICAgZW5jb2RlKGVuYywgYmluKTtcbiAgICAgICAgICAgICAgICBiaW5zW2kgKiA0XSA9IGVuY1swXTtcbiAgICAgICAgICAgICAgICBiaW5zW2kgKiA0ICsgMV0gPSBlbmNbMV07XG4gICAgICAgICAgICAgICAgYmluc1tpICogNCArIDJdID0gZW5jWzJdO1xuICAgICAgICAgICAgICAgIGJpbnNbaSAqIDQgKyAzXSA9IGVuY1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkLnN1bSA9IHN1bTtcbiAgICAgICAgICAgICAgICBjb25zdCBuY29vcmRzID0gdGhpcy5nZXROb3JtYWxpemVkQ29vcmRzKGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQobmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXRsYXMuYWRkVGlsZShoYXNoLCBiaW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9xdWFkQnVmZmVyO1xuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgLy8gY2FsYyB2aWV3IG9mZnNldFxuICAgICAgICAgICAgY29uc3Qgdmlld09mZnNldCA9IHRoaXMuZ2V0Vmlld09mZnNldCgpO1xuICAgICAgICAgICAgdGhpcy5fYXRsYXMuZm9yRWFjaCgoY2h1bmssIGhhc2gpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0aWxlIHJlZmVycmluZyB0byB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2hhc2hdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZvciBlYWNoIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgXy5rZXlzKGNhY2hlZC50aWxlcykuZm9yRWFjaChoYXNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHRpbGVzIHBvc2l0aW9uIGZyb20gaXRzIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5jb29yZEZyb21DYWNoZUtleShoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY2hlY2sgaGVyZSBpZiB0aGUgdGlsZXMgYXJlIHN0YWxlIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHdyYXBhcm91bmQgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cmFwT2Zmc2V0ID0gdGhpcy5nZXRXcmFwQXJvdW5kT2Zmc2V0KGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVPZmZzZXQgPSB0aGlzLmdldFRpbGVPZmZzZXQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsT2Zmc2V0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVPZmZzZXRbMF0gKyB3cmFwT2Zmc2V0WzBdIC0gdmlld09mZnNldFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlT2Zmc2V0WzFdICsgd3JhcE9mZnNldFsxXSAtIHZpZXdPZmZzZXRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCB0b3RhbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1diBvZmZzZXQgYW5kIGV4dGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VUZXh0dXJlQ29vcmRPZmZzZXQnLCBjaHVuay51dk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVRleHR1cmVDb29yZEV4dGVudCcsIGNodW5rLnV2RXh0ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNldHVwXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydC5wdXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIudXNlKCk7XG4gICAgICAgICAgICAvLyBzZXQgdW5pZm9ybXNcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtKCd1UmFuZ2VNaW4nLCB0aGlzLmdldFZhbHVlUmFuZ2UoKS5taW4pO1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm0oJ3VSYW5nZU1heCcsIHRoaXMuZ2V0VmFsdWVSYW5nZSgpLm1heCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndU1pbicsIHRoaXMuZ2V0RXh0cmVtYSgpLm1pbik7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndU1heCcsIHRoaXMuZ2V0RXh0cmVtYSgpLm1heCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVRyYW5zZm9ybVR5cGUnLCB0aGlzLmdldFRyYW5zZm9ybUVudW0oKSk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVRleHR1cmVTYW1wbGVyJywgMCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybSgndVJhbXAnLCB0aGlzLmdldENvbG9yUmFtcFRhYmxlKCkpO1xuICAgICAgICAgICAgdGhpcy5fYXRsYXMudGV4dHVyZS5iaW5kKDApO1xuICAgICAgICAgICAgLy8gZHJhd1xuICAgICAgICAgICAgdGhpcy5fcXVhZEJ1ZmZlci5iaW5kKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9xdWFkQnVmZmVyLnVuYmluZCgpO1xuICAgICAgICAgICAgLy8gdGVhcmRvd25cbiAgICAgICAgICAgIHRoaXMuX2F0bGFzLnRleHR1cmUudW5iaW5kKCk7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXRtYXA7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBlc3BlciA9IHJlcXVpcmUoJ2VzcGVyJyk7XG4gICAgY29uc3QgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuICAgIGNvbnN0IFdlYkdMID0gcmVxdWlyZSgnLi4vLi4vY29yZS9XZWJHTCcpO1xuICAgIGNvbnN0IFZlcnRleEF0bGFzID0gcmVxdWlyZSgnLi9WZXJ0ZXhBdGxhcycpO1xuICAgIGNvbnN0IFNoYWRlcnMgPSByZXF1aXJlKCcuL1NoYWRlcnMnKTtcbiAgICBjb25zdCBTaGFwZXMgPSByZXF1aXJlKCcuL1NoYXBlcycpO1xuXG4gICAgY29uc3QgVElMRV9TSVpFID0gMjU2O1xuICAgIGNvbnN0IE1BWF9QT0lOVFNfUEVSX1RJTEUgPSBUSUxFX1NJWkUgKiBUSUxFX1NJWkU7XG5cbiAgICBjb25zdCBOVU1fU0xJQ0VTID0gNjQ7XG4gICAgY29uc3QgUE9JTlRfUkFESVVTID0gODtcbiAgICBjb25zdCBQT0lOVF9SQURJVVNfSU5DID0gMjtcblxuICAgIGZ1bmN0aW9uIGFwcGx5Sml0dGVyKHBvaW50LCBtYXhEaXN0KSB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIChNYXRoLlBJICogMik7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnJhbmRvbSgpICogbWF4RGlzdDtcbiAgICAgICAgcG9pbnQueCArPSBNYXRoLmZsb29yKE1hdGguY29zKGFuZ2xlKSAqIGRpc3QpO1xuICAgICAgICBwb2ludC55ICs9IE1hdGguZmxvb3IoTWF0aC5zaW4oYW5nbGUpICogZGlzdCk7XG4gICAgfVxuXG4gICAgY29uc3QgUG9pbnQgPSBXZWJHTC5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG91dGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIG91dGxpbmVDb2xvcjogWzAuMCwgMC4wLCAwLjAsIDEuMF0sXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFswLjIsIDAuMTUsIDAuNCwgMC41XSxcbiAgICAgICAgICAgIHJhZGl1czogUE9JTlRfUkFESVVTLFxuICAgICAgICAgICAgc2VsZWN0ZWRPdXRsaW5lQ29sb3I6IFswLjAsIDAuMCwgMC4wLCAxLjBdLFxuICAgICAgICAgICAgc2VsZWN0ZWRGaWxsQ29sb3I6IFswLjgsIDAuNCwgMC4yLCAwLjVdLFxuICAgICAgICAgICAgc2VsZWN0ZWRSYWRpdXM6IFBPSU5UX1JBRElVUyArIFBPSU5UX1JBRElVU19JTkMsXG4gICAgICAgICAgICBoaWdobGlnaHRlZE91dGxpbmVDb2xvcjogWzAuMCwgMC4wLCAwLjAsIDEuMF0sXG4gICAgICAgICAgICBoaWdobGlnaHRlZEZpbGxDb2xvcjogWzAuMywgMC4yNSwgMC41LCAwLjVdLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRSYWRpdXM6IFBPSU5UX1JBRElVUyArIFBPSU5UX1JBRElVU19JTkMsXG4gICAgICAgICAgICBibGVuZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGppdHRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGppdHRlckRpc3RhbmNlOiAxMFxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZ2hsaWdodGVkOiBudWxsLFxuICAgICAgICBzZWxlY3RlZDogbnVsbCxcblxuICAgICAgICBvbldlYkdMSW5pdDogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHVzZSB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICAgICAgICBlc3Blci5XZWJHTENvbnRleHQuYmluZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBjaXJjbGUgdmVydGV4YnVmZmVyXG4gICAgICAgICAgICB0aGlzLl9jaXJjbGVGaWxsQnVmZmVyID0gU2hhcGVzLmNpcmNsZS5maWxsKE5VTV9TTElDRVMpO1xuICAgICAgICAgICAgdGhpcy5fY2lyY2xlT3V0bGluZUJ1ZmZlciA9IFNoYXBlcy5jaXJjbGUub3V0bGluZShOVU1fU0xJQ0VTKTtcbiAgICAgICAgICAgIC8vIHZlcnRleCBhdGxhcyBmb3IgYWxsIHRpbGVzXG4gICAgICAgICAgICB0aGlzLl9hdGxhcyA9IG5ldyBWZXJ0ZXhBdGxhcyh7XG4gICAgICAgICAgICAgICAgMToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgc3BhdGlhbCBpbmRleFxuICAgICAgICAgICAgdGhpcy5fcnRyZWUgPSBuZXcgcmJ1c2goKTtcbiAgICAgICAgICAgIC8vIGxvYWQgc2hhZGVyc1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VkU2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgdmVydDogU2hhZGVycy5pbnN0YW5jZWRQb2ludC52ZXJ0LFxuICAgICAgICAgICAgICAgIGZyYWc6IFNoYWRlcnMuaW5zdGFuY2VkUG9pbnQuZnJhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbmRpdmlkdWFsU2hhZGVyID0gbmV3IGVzcGVyLlNoYWRlcih7XG4gICAgICAgICAgICAgICAgdmVydDogU2hhZGVycy5wb2ludC52ZXJ0LFxuICAgICAgICAgICAgICAgIGZyYWc6IFNoYWRlcnMucG9pbnQuZnJhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29sbGlzaW9uUmFkaXVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmFkaXVzICsgdGhpcy5vcHRpb25zLm91dGxpbmVXaWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBXZWJHTC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tZW5kJywgdGhpcy5vblpvb21FbmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIFdlYkdMLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5vblpvb21FbmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uWm9vbVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3J0cmVlLmNsZWFyKCk7XG4gICAgICAgICAgICBXZWJHTC5wcm90b3R5cGUub25ab29tU3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNhY2hlTG9hZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGV2ZW50LmVudHJ5O1xuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5kYXRhICYmIGNhY2hlZC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHggLyB5IHRvIHRpbGUgcGl4ZWxzXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhY2hlZC5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhGaWVsZCA9IHRoaXMuZ2V0WEZpZWxkKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeUZpZWxkID0gdGhpcy5nZXRZRmllbGQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6b29tID0gY29vcmRzLno7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5nZXRDb2xsaXNpb25SYWRpdXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Qb2ludHMgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgTUFYX1BPSU5UU19QRVJfVElMRSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShudW1Qb2ludHMqMik7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeE9mZnNldCA9IGNvb3Jkcy54ICogVElMRV9TSVpFO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlPZmZzZXQgPSBjb29yZHMueSAqIFRJTEVfU0laRTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgICAgIC8vIGNhbGMgcGl4ZWwgbG9jYXRpb25zXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpdCA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBfLmdldChoaXQsIHhGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBfLmdldChoaXQsIHlGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBwb3NpdGlvbiBpbiBsYXllclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXllclBvaW50ID0gdGhpcy5nZXRMYXllclBvaW50RnJvbURhdGFQb2ludCh4LCB5LCB6b29tKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGppdHRlciBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBsYXllclBvaW50LnggKyAnOicgKyBsYXllclBvaW50Lnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uc1toYXNoXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5Sml0dGVyKGxheWVyUG9pbnQsIHRoaXMub3B0aW9ucy5qaXR0ZXJEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25zW2hhc2hdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgcG9zaXRpb24gaW4gdGlsZVxuICAgICAgICAgICAgICAgICAgICB0aWxlUG9pbnQueCA9IGxheWVyUG9pbnQueCAtIHhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVQb2ludC55ID0gVElMRV9TSVpFIC0gKGxheWVyUG9pbnQueSAtIHlPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aWxlUG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRpbGVQb2ludC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWDogbGF5ZXJQb2ludC54IC0gcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WDogbGF5ZXJQb2ludC54ICsgcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWTogbGF5ZXJQb2ludC55IC0gcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WTogbGF5ZXJQb2ludC55ICsgcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBwb2ludCB0byBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2kgKiAyXSA9IHRpbGVQb2ludC54O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaSAqIDIgKyAxXSA9IHRpbGVQb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVsayBpbnNlcnQgcG9pbnRzIHRvIHRoZSBydHJlZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydHJlZS5sb2FkKHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHBvaW50cyBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRvIGF0bGFzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5jb29yZHMgPSB0aGlzLmdldE5vcm1hbGl6ZWRDb29yZHMoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQobmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0bGFzLmFkZFRpbGUoaGFzaCwgcG9zaXRpb25zLCBwb2ludHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWNoZVVubG9hZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGV2ZW50LmVudHJ5O1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZHMgPSBldmVudC5jb29yZHM7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gYXRsYXNcbiAgICAgICAgICAgICAgICBjb25zdCBuY29vcmRzID0gdGhpcy5nZXROb3JtYWxpemVkQ29vcmRzKGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQobmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXRsYXMucmVtb3ZlVGlsZShoYXNoKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBydHJlZVxuICAgICAgICAgICAgICAgIGNhY2hlZC5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3J0cmVlLnJlbW92ZShwb2ludCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FjaGVkLnBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBsYXllclBpeGVsID0gdGhpcy5nZXRMYXllclBvaW50RnJvbUV2ZW50KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBjb25zdCBjb2xsaXNpb25zID0gdGhpcy5fcnRyZWUuc2VhcmNoKHtcbiAgICAgICAgICAgICAgICBtaW5YOiBsYXllclBpeGVsLngsXG4gICAgICAgICAgICAgICAgbWF4WDogbGF5ZXJQaXhlbC54LFxuICAgICAgICAgICAgICAgIG1pblk6IGxheWVyUGl4ZWwueSxcbiAgICAgICAgICAgICAgICBtYXhZOiBsYXllclBpeGVsLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbMF07XG4gICAgICAgICAgICAgICAgLy8gbWltaWMgbW91c2VvdmVyIC8gbW91c2VvdXQgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQudmFsdWUgIT09IGNvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZSBtb3VzZW91dCBmb3Igb2xkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaWdobGlnaHRlZC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIG1vdXNlb3ZlciBmb3IgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBwcmV2aW91cyBjb2xsaXNpb24sIGV4ZWN1dGUgbW91c2VvdmVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW91c2VvdmVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXNlIGNvbGxpc2lvbiBwb2ludCB0byBmaW5kIHRpbGVcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5jYWNoZUtleUZyb21Db29yZChjb2xsaXNpb24uY29vcmRzKTtcbiAgICAgICAgICAgICAgICAvLyBmbGFnIGFzIGhpZ2hsaWdodGVkXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZXM6IHRoaXMuX2NhY2hlW2hhc2hdLnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb24ueVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yXG4gICAgICAgICAgICAgICAgJCh0aGlzLl9tYXAuX2NvbnRhaW5lcikuY3NzKCdjdXJzb3InLCAncG9pbnRlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vdXNlIG91dFxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3V0Jywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhpZ2hsaWdodGVkLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBoaWdobGlnaHRlZCBmbGFnXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJQaXhlbCA9IHRoaXMuZ2V0TGF5ZXJQb2ludEZyb21FdmVudChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9IHRoaXMuX3J0cmVlLnNlYXJjaCh7XG4gICAgICAgICAgICAgICAgbWluWDogbGF5ZXJQaXhlbC54LFxuICAgICAgICAgICAgICAgIG1heFg6IGxheWVyUGl4ZWwueCxcbiAgICAgICAgICAgICAgICBtaW5ZOiBsYXllclBpeGVsLnksXG4gICAgICAgICAgICAgICAgbWF4WTogbGF5ZXJQaXhlbC55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zWzBdO1xuICAgICAgICAgICAgICAgIC8vIHVzZSBjb2xsaXNpb24gcG9pbnQgdG8gZmluZCB0aWxlXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuY2FjaGVLZXlGcm9tQ29vcmQoY29sbGlzaW9uLmNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzOiB0aGlzLl9jYWNoZVtoYXNoXS50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uLnlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXdJbnN0YW5jZWQ6IGZ1bmN0aW9uKGNpcmNsZSwgY29sb3IsIHJhZGl1cykge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuX2luc3RhbmNlZFNoYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICBjb25zdCB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGNvbnN0IGF0bGFzID0gdGhpcy5fYXRsYXM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJsZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlIGJsZW5kaW5nXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIHNoYWRlclxuICAgICAgICAgICAgc2hhZGVyLnVzZSgpO1xuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm1zXG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgdGhpcy5nZXRQcm9qZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VPcGFjaXR5JywgdGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VSYWRpdXMnLCByYWRpdXMpO1xuICAgICAgICAgICAgLy8gY2FsYyB2aWV3IG9mZnNldFxuICAgICAgICAgICAgY29uc3Qgdmlld09mZnNldCA9IHRoaXMuZ2V0Vmlld09mZnNldCgpO1xuICAgICAgICAgICAgLy8gYmluZHMgdGhlIGNpcmNsZSB0byBpbnN0YW5jZVxuICAgICAgICAgICAgY2lyY2xlLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGJpbmQgb2Zmc2V0cyBhbmQgZW5hYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGF0bGFzLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGFsbG9jYXRlZCBjaHVua1xuICAgICAgICAgICAgYXRsYXMuZm9yRWFjaCgoY2h1bmssIGhhc2gpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0aWxlIHJlZmVycmluZyB0byB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2hhc2hdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZvciBlYWNoIHRpbGVcbiAgICAgICAgICAgICAgICAgICAgXy5rZXlzKGNhY2hlZC50aWxlcykuZm9yRWFjaChoYXNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuY29vcmRGcm9tQ2FjaGVLZXkoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRzLnogIT09IHpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgd3JhcCBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBPZmZzZXQgPSB0aGlzLmdldFdyYXBBcm91bmRPZmZzZXQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aWxlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZU9mZnNldCA9IHRoaXMuZ2V0VGlsZU9mZnNldChjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCB0aWxlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZU9mZnNldFswXSArIHdyYXBPZmZzZXRbMF0gLSB2aWV3T2Zmc2V0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVPZmZzZXRbMV0gKyB3cmFwT2Zmc2V0WzFdIC0gdmlld09mZnNldFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1VGlsZU9mZnNldCcsIHRvdGFsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgdGhlIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRsYXMuZHJhdyhoYXNoLCBjaXJjbGUubW9kZSwgY2lyY2xlLmNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGluc3RhbmNpbmdcbiAgICAgICAgICAgIGF0bGFzLnVuYmluZCgpO1xuICAgICAgICAgICAgLy8gdW5iaW5kIGJ1ZmZlclxuICAgICAgICAgICAgY2lyY2xlLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXdJbmRpdmlkdWFsOiBmdW5jdGlvbihjaXJjbGUsIGNvbG9yLCByYWRpdXMsIHRpbGVzLCBwb2ludCkge1xuICAgICAgICAgICAgLy8gZHJhdyBzZWxlY3RlZCBwb2ludHNcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9pbmRpdmlkdWFsU2hhZGVyO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICAgICAgICAgIGNpcmNsZS5iaW5kKCk7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGJsZW5kaW5nXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIC8vIHVzZSBzaGFkZXJcbiAgICAgICAgICAgIHNoYWRlci51c2UoKTtcbiAgICAgICAgICAgIC8vIHVzZSB1bmlmb3JtIGZvciBvZmZzZXRcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHRoaXMuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtKCd1UmFkaXVzJywgcmFkaXVzKTtcbiAgICAgICAgICAgIC8vIHZpZXcgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCB2aWV3T2Zmc2V0ID0gdGhpcy5nZXRWaWV3T2Zmc2V0KCk7XG4gICAgICAgICAgICBfLmZvckluKHRpbGVzLCB0aWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5jb29yZHMueiAhPT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNoZWNrIGhlcmUgaWYgdGhlIHRpbGVzIGFyZSBzdGFsZSBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXQgd3JhcCBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwT2Zmc2V0ID0gdGhpcy5nZXRXcmFwQXJvdW5kT2Zmc2V0KHRpbGUuY29vcmRzKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGlsZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlT2Zmc2V0ID0gdGhpcy5nZXRUaWxlT2Zmc2V0KHRpbGUuY29vcmRzKTtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHRpbGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRpbGVPZmZzZXRbMF0gKyB3cmFwT2Zmc2V0WzBdIC0gdmlld09mZnNldFswXSxcbiAgICAgICAgICAgICAgICAgICAgdGlsZU9mZnNldFsxXSArIHdyYXBPZmZzZXRbMV0gLSB2aWV3T2Zmc2V0WzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCB0b3RhbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VPZmZzZXQnLCBwb2ludCk7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VDb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICBjaXJjbGUuZHJhdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1bmJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgY2lyY2xlLnVuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHNldHVwXG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcbiAgICAgICAgICAgIHZpZXdwb3J0LnB1c2goKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBpbnN0YW5jZWQgcG9pbnRzXG5cbiAgICAgICAgICAgIC8vIGRyYXcgaW5zdGFuY2VkIGZpbGxcbiAgICAgICAgICAgIHRoaXMuZHJhd0luc3RhbmNlZChcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVGaWxsQnVmZmVyLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJhZGl1cyk7XG4gICAgICAgICAgICAvLyBkcmF3IGluc3RhbmNlZCBvdXRsaW5lc1xuICAgICAgICAgICAgZ2wubGluZVdpZHRoKHRoaXMub3B0aW9ucy5vdXRsaW5lV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3SW5zdGFuY2VkKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZU91dGxpbmVCdWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm91dGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmFkaXVzKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBpbmRpdmlkdWFsIHBvaW50c1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgaW5kaXZpZHVhbCBmaWxsXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3SW5kaXZpZHVhbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlRmlsbEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkRmlsbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ZWRSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQudGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQucG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgaW5kaXZpZHVhbCBvdXRsaW5lXG4gICAgICAgICAgICAgICAgZ2wubGluZVdpZHRoKHRoaXMub3B0aW9ucy5vdXRsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGl2aWR1YWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZU91dGxpbmVCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWdobGlnaHRlZE91dGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZ2hsaWdodGVkUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkLnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkLnBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGluZGl2aWR1YWwgZmlsbFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGl2aWR1YWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZUZpbGxCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RlZEZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlbGVjdGVkUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGluZGl2aWR1YWwgb3V0bGluZVxuICAgICAgICAgICAgICAgIGdsLmxpbmVXaWR0aCh0aGlzLm9wdGlvbnMub3V0bGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbmRpdmlkdWFsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGVPdXRsaW5lQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRPdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RlZFJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5wb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRlYXJkb3duXG4gICAgICAgICAgICB2aWV3cG9ydC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgQ29sb3JSYW1wID0gcmVxdWlyZSgnLi4vLi4vbWl4aW4vQ29sb3JSYW1wJyk7XG5cbiAgICAvKipcbiAgICAgKiBwcmVjaXNpb25cbiAgICAgKi9cbiAgICBjb25zdCBwcmVjaXNpb24gPVxuICAgICAgICBgXG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIGRlY29kZSBmbG9hdFxuICAgICAqL1xuICAgIGNvbnN0IGRlY29kZVJHQkFUb0Zsb2F0ID1cbiAgICAgICAgYFxuICAgICAgICBmbG9hdCBkZWNvZGVSR0JBVG9GbG9hdCh2ZWM0IHYpIHtcbiAgICAgICAgICAgIHJldHVybiAodi54ICogMjU1LjAgKiAxNjc3NzIxNi4wKSArXG4gICAgICAgICAgICAgICAgKHYueSAqIDI1NS4wICogNjU1MzYuMCkgK1xuICAgICAgICAgICAgICAgICh2LnogKiAyNTUuMCAqIDI1Ni4wKSArXG4gICAgICAgICAgICAgICAgdi53ICogMjU1LjA7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybXNcbiAgICAgKi9cblxuICAgIC8vIGxvZzEwXG4gICAgY29uc3QgbG9nMTBUcmFuc2Zvcm0gPVxuICAgICAgICBgXG4gICAgICAgIGZsb2F0IGxvZzEwKGZsb2F0IHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZyh2YWwpIC8gbG9nKDEwLjApO1xuICAgICAgICB9XG4gICAgICAgIGZsb2F0IGxvZzEwVHJhbnNmb3JtKGZsb2F0IHZhbCwgZmxvYXQgbWluVmFsLCBmbG9hdCBtYXhWYWwpIHtcbiAgICAgICAgICAgIGlmIChtaW5WYWwgPCAxLjApIHsgbWluVmFsID0gMS4wOyB9XG4gICAgICAgICAgICBpZiAobWF4VmFsIDwgMS4wKSB7IG1heFZhbCA9IDEuMDsgfVxuICAgICAgICAgICAgaWYgKHZhbCA8IDEuMCkgeyB2YWwgPSAxLjA7IH1cbiAgICAgICAgICAgIGZsb2F0IGxvZ01pbiA9IGxvZzEwKG1pblZhbCk7XG4gICAgICAgICAgICBmbG9hdCBsb2dNYXggPSBsb2cxMChtYXhWYWwpO1xuICAgICAgICAgICAgZmxvYXQgbG9nVmFsID0gbG9nMTAodmFsKTtcbiAgICAgICAgICAgIGZsb2F0IHJhbmdlID0gbG9nTWF4IC0gbG9nTWluO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09IDAuMCkgeyByYW5nZSA9IDEuMDsgfVxuICAgICAgICAgICAgcmV0dXJuIChsb2dWYWwgLSBsb2dNaW4pIC8gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8vIHNpZ21vaWRcbiAgICBjb25zdCBzaWdtb2lkVHJhbnNmb3JtID1cbiAgICAgICAgYFxuICAgICAgICBmbG9hdCBzaWdtb2lkVHJhbnNmb3JtKGZsb2F0IHZhbCwgZmxvYXQgbWluVmFsLCBmbG9hdCBtYXhWYWwpIHtcbiAgICAgICAgICAgIG1pblZhbCA9IGFicyhtaW5WYWwpO1xuICAgICAgICAgICAgbWF4VmFsID0gYWJzKG1heFZhbCk7XG4gICAgICAgICAgICBmbG9hdCBkaXN0ID0gbWF4KG1pblZhbCwgbWF4VmFsKTtcbiAgICAgICAgICAgIGZsb2F0IFNJR01PSURfU0NBTEUgPSAwLjE1O1xuICAgICAgICAgICAgZmxvYXQgc2NhbGVkVmFsID0gdmFsIC8gKFNJR01PSURfU0NBTEUgKiBkaXN0KTtcbiAgICAgICAgICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1zY2FsZWRWYWwpKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgLy8gbGluZWFyXG4gICAgY29uc3QgbGluZWFyVHJhbnNmb3JtID1cbiAgICAgICAgYFxuICAgICAgICBmbG9hdCBsaW5lYXJUcmFuc2Zvcm0oZmxvYXQgdmFsLCBmbG9hdCBtaW5WYWwsIGZsb2F0IG1heFZhbCkge1xuICAgICAgICAgICAgZmxvYXQgcmFuZ2UgPSBtYXhWYWwgLSBtaW5WYWw7XG4gICAgICAgICAgICBpZiAocmFuZ2UgPT0gMC4wKSB7IHJhbmdlID0gMS4wOyB9XG4gICAgICAgICAgICByZXR1cm4gKHZhbCAtIG1pblZhbCkgLyByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuXG4gICAgY29uc3QgdHJhbnNmb3JtID1cbiAgICAgICAgbG9nMTBUcmFuc2Zvcm0gK1xuICAgICAgICBzaWdtb2lkVHJhbnNmb3JtICtcbiAgICAgICAgbGluZWFyVHJhbnNmb3JtICtcbiAgICAgICAgYFxuICAgICAgICAjZGVmaW5lIExPR19UUkFOU0ZPUk0gMFxuICAgICAgICAjZGVmaW5lIExJTkVBUl9UUkFOU0ZPUk0gMVxuICAgICAgICAjZGVmaW5lIFNJR01PSURfVFJBTlNGT1JNIDJcbiAgICAgICAgdW5pZm9ybSBpbnQgdVRyYW5zZm9ybVR5cGU7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdU1pbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1TWF4O1xuICAgICAgICBmbG9hdCB0cmFuc2Zvcm0oZmxvYXQgdmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsIDwgdU1pbikgeyB2YWwgPSB1TWluOyB9XG4gICAgICAgICAgICBpZiAodmFsID4gdU1heCkgeyB2YWwgPSB1TWF4OyB9XG4gICAgICAgICAgICBpZiAodVRyYW5zZm9ybVR5cGUgPT0gTElORUFSX1RSQU5TRk9STSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lYXJUcmFuc2Zvcm0odmFsLCB1TWluLCB1TWF4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodVRyYW5zZm9ybVR5cGUgPT0gU0lHTU9JRF9UUkFOU0ZPUk0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbW9pZFRyYW5zZm9ybSh2YWwsIHVNaW4sIHVNYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZzEwVHJhbnNmb3JtKHZhbCwgdU1pbiwgdU1heCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHJhbXBcbiAgICAgKi9cbiAgICBjb25zdCBjb2xvclJhbXAgPVxuICAgICAgICBgXG4gICAgICAgICNkZWZpbmUgUkFNUF9WQUxVRVMgJHtDb2xvclJhbXAuTlVNX0dSQURJRU5UX1NURVBTfVxuICAgICAgICB1bmlmb3JtIHZlYzQgdVJhbXBbUkFNUF9WQUxVRVNdO1xuICAgICAgICB2ZWM0IGNvbG9yUmFtcChmbG9hdCB2YWx1ZSkge1xuICAgICAgICAgICAgZmxvYXQgbWF4SW5kZXggPSBmbG9hdChSQU1QX1ZBTFVFUyAtIDEpO1xuICAgICAgICAgICAgaW50IGluZGV4ID0gaW50KHZhbHVlICogbWF4SW5kZXgpO1xuICAgICAgICAgICAgLy8gTk9URTogSSBSRUFMTFkgZG9uJ3QgbGlrZSB0aGlzLCBidXQgaXQgc2VlbXMgdG8gYmUgdGhlIG9ubHkgd2F5XG4gICAgICAgICAgICAvLyB0byBpbmRleCB0aGUgdVJhbXAgYXJyYXlcbiAgICAgICAgICAgIGZvciAoaW50IGk9MDsgaTxSQU1QX1ZBTFVFUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVSYW1wW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDEuMCwgMC4wLCAxLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIFJhbmdlXG4gICAgICovXG4gICAgY29uc3QgdmFsdWVSYW5nZSA9XG4gICAgICAgIGBcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmFuZ2VNaW47XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVJhbmdlTWF4O1xuICAgICAgICBmbG9hdCBpbnRlcnBvbGF0ZVRvUmFuZ2UoZmxvYXQgbnZhbCkge1xuICAgICAgICAgICAgZmxvYXQgcnZhbCA9IChudmFsIC0gdVJhbmdlTWluKSAvICh1UmFuZ2VNYXggLSB1UmFuZ2VNaW4pO1xuICAgICAgICAgICAgaWYgKHJ2YWwgPiAxLjApIHtcbiAgICAgICAgICAgICAgICBydmFsID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChydmFsIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgcnZhbCA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydmFsO1xuICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAvKipcbiAgICAgKiBoZWF0bWFwIHNoYWRlclxuICAgICAqL1xuICAgIGNvbnN0IGhlYXRtYXAgPSB7XG4gICAgICAgIHZlcnQ6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gaXZlYzIgdVRpbGVPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdVRleHR1cmVDb29yZE9mZnNldDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1VGV4dHVyZUNvb3JkRXh0ZW50O1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgdlRleHR1cmVDb29yZCA9IHZlYzIoXG4gICAgICAgICAgICAgICAgICAgIHVUZXh0dXJlQ29vcmRPZmZzZXQueCArIChhVGV4dHVyZUNvb3JkLnggKiB1VGV4dHVyZUNvb3JkRXh0ZW50LngpLFxuICAgICAgICAgICAgICAgICAgICB1VGV4dHVyZUNvb3JkT2Zmc2V0LnkgKyAoYVRleHR1cmVDb29yZC55ICogdVRleHR1cmVDb29yZEV4dGVudC55KSk7XG4gICAgICAgICAgICAgICAgaXZlYzIgd1Bvc2l0aW9uID0gaXZlYzIoYVBvc2l0aW9uKSArIHVUaWxlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgZnJhZzpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBkZWNvZGVSR0JBVG9GbG9hdCArXG4gICAgICAgICAgICB0cmFuc2Zvcm0gK1xuICAgICAgICAgICAgY29sb3JSYW1wICtcbiAgICAgICAgICAgIHZhbHVlUmFuZ2UgK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmVTYW1wbGVyO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZlYzQgZW5jID0gdGV4dHVyZTJEKHVUZXh0dXJlU2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgICAgICAgICAgZmxvYXQgY291bnQgPSBkZWNvZGVSR0JBVG9GbG9hdChlbmMpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxvYXQgbnZhbCA9IHRyYW5zZm9ybShjb3VudCk7XG4gICAgICAgICAgICAgICAgZmxvYXQgcnZhbCA9IGludGVycG9sYXRlVG9SYW5nZShudmFsKTtcbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gY29sb3JSYW1wKHJ2YWwpO1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpbnN0YW5jZWQgcG9pbnQgc2hhZGVyXG4gICAgICovXG4gICAgY29uc3QgaW5zdGFuY2VkUG9pbnQgPSB7XG4gICAgICAgIHZlcnQ6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYU9mZnNldDtcbiAgICAgICAgICAgIHVuaWZvcm0gaXZlYzIgdVRpbGVPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVSYWRpdXM7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgaXZlYzIgaU9mZnNldCA9IGl2ZWMyKGFPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZlYzIgbVBvc2l0aW9uID0gKHVSYWRpdXMgKiBhUG9zaXRpb24pICsgdmVjMihpT2Zmc2V0ICsgdVRpbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KG1Qb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgZnJhZzpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvci5yZ2IsIHVDb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgdmVydDpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVUaWxlT2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmFkaXVzO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZlYzIgbVBvc2l0aW9uID0gdVJhZGl1cyAqIGFQb3NpdGlvbiArIHZlYzIodU9mZnNldCArIHVUaWxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdmVjNChtUG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgIGZyYWc6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCB1Q29sb3IuYSAqIHVPcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaW5zdGFuY2VkIHJpbmcgc2hhZGVyXG4gICAgICovXG4gICAgY29uc3QgaW5zdGFuY2VkUmluZyA9IHtcbiAgICAgICAgdmVydDpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhUG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhT2Zmc2V0O1xuICAgICAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFSYWRpdXM7XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVUaWxlT2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1RGVncmVlcztcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVJhZGl1c09mZnNldDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGl2ZWMyIGlPZmZzZXQgPSBpdmVjMihhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2ZWMyIG1Qb3NpdGlvbiA9IChhUG9zaXRpb24ueHkgKyAobm9ybWFsaXplKGFQb3NpdGlvbi54eSkgKiAoYVJhZGl1cyAtIHVSYWRpdXNPZmZzZXQpKSkgKyB2ZWMyKGlPZmZzZXQgKyB1VGlsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGFQb3NpdGlvbi56ID4gdURlZ3JlZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdkNvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZDb2xvciA9IHVDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQobVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICBmcmFnOlxuICAgICAgICAgICAgcHJlY2lzaW9uICtcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGlmICh2Q29sb3IuYSA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IucmdiLCB2Q29sb3IuYSAqIHVPcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgICB9O1xuXG4gICAgY29uc3QgcmluZyA9IHtcbiAgICAgICAgdmVydDpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhUG9zaXRpb247XG4gICAgICAgICAgICB1bmlmb3JtIGl2ZWMyIHVPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVSYWRpdXM7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVEZWdyZWVzO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmFkaXVzT2Zmc2V0O1xuICAgICAgICAgICAgdW5pZm9ybSBpdmVjMiB1VGlsZU9mZnNldDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1Q29sb3I7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZlYzIgbVBvc2l0aW9uID0gKGFQb3NpdGlvbi54eSArIChub3JtYWxpemUoYVBvc2l0aW9uLnh5KSAqICh1UmFkaXVzIC0gdVJhZGl1c09mZnNldCkpKSArIHZlYzIodU9mZnNldCArIHVUaWxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoYVBvc2l0aW9uLnogPiB1RGVncmVlcykge1xuICAgICAgICAgICAgICAgICAgICB2Q29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkNvbG9yID0gdUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdmVjNChtUG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgIGZyYWc6XG4gICAgICAgICAgICBwcmVjaXNpb24gK1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZDb2xvci5hID09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjYXJkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvci5yZ2IsIHZDb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpbnN0YW5jZWQgcmluZyBzaGFkZXJcbiAgICAgKi9cbiAgICBjb25zdCBpbnN0YW5jZWRUaWNrID0ge1xuICAgICAgICB2ZXJ0OlxuICAgICAgICAgICAgcHJlY2lzaW9uICtcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFPZmZzZXQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYVJhZGl1cztcbiAgICAgICAgICAgIHVuaWZvcm0gaXZlYzIgdVRpbGVPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVSYWRpdXNPZmZzZXQ7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgaXZlYzIgaU9mZnNldCA9IGl2ZWMyKGFPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZlYzIgbVBvc2l0aW9uID0gKGFQb3NpdGlvbiArICh2ZWMyKDAsIDEpICogYVJhZGl1cykpICsgdmVjMihpT2Zmc2V0ICsgdVRpbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KG1Qb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgZnJhZzpcbiAgICAgICAgICAgIHByZWNpc2lvbiArXG4gICAgICAgICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvci5yZ2IsIHVDb2xvci5hICogdU9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVhdG1hcCBzaGFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGhlYXRtYXA6IGhlYXRtYXAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlZCBwb2ludCBzaGFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGluc3RhbmNlZFBvaW50OiBpbnN0YW5jZWRQb2ludCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcG9pbnQgc2hhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludDogcG9pbnQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlZCByaW5nIHNoYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdGFuY2VkUmluZzogaW5zdGFuY2VkUmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmluZyBzaGFkZXJcbiAgICAgICAgICovXG4gICAgICAgIHJpbmc6IHJpbmcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlZCB0aWNrIHNoYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdGFuY2VkVGljazogaW5zdGFuY2VkVGlja1xuXG4gICAgfTtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IGVzcGVyID0gcmVxdWlyZSgnZXNwZXInKTtcblxuICAgIGZ1bmN0aW9uIGNpcmNsZU91dGxpbmUobnVtU2VnbWVudHMpIHtcbiAgICAgICAgY29uc3QgdGhldGEgPSAoMiAqIE1hdGguUEkpIC8gbnVtU2VnbWVudHM7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IDEuMDtcbiAgICAgICAgLy8gcHJlY2FsY3VsYXRlIHNpbmUgYW5kIGNvc2luZVxuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAvLyBzdGFydCBhdCBhbmdsZSA9IDBcbiAgICAgICAgbGV0IHggPSByYWRpdXM7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShudW1TZWdtZW50cyAqIDIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpKjJdID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpKjIrMV0gPSB5O1xuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHJvdGF0aW9uXG4gICAgICAgICAgICBjb25zdCB0ID0geDtcbiAgICAgICAgICAgIHggPSBjICogeCAtIHMgKiB5O1xuICAgICAgICAgICAgeSA9IHMgKiB0ICsgYyAqIHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRlcnMgPSB7XG4gICAgICAgICAgICAwOiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiAnTElORV9MT09QJyxcbiAgICAgICAgICAgIGNvdW50OiBwb3NpdGlvbnMubGVuZ3RoIC8gMlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IGVzcGVyLlZlcnRleEJ1ZmZlcihwb3NpdGlvbnMsIHBvaW50ZXJzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaXJjbGVGaWxsKG51bVNlZ21lbnRzKSB7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gKDIgKiBNYXRoLlBJKSAvIG51bVNlZ21lbnRzO1xuICAgICAgICBjb25zdCByYWRpdXMgPSAxLjA7XG4gICAgICAgIC8vIHByZWNhbGN1bGF0ZSBzaW5lIGFuZCBjb3NpbmVcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgLy8gc3RhcnQgYXQgYW5nbGUgPSAwXG4gICAgICAgIGxldCB4ID0gcmFkaXVzO1xuICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoKG51bVNlZ21lbnRzICsgMikgKiAyKTtcbiAgICAgICAgcG9zaXRpb25zWzBdID0gMDtcbiAgICAgICAgcG9zaXRpb25zWzFdID0gMDtcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGgtMl0gPSByYWRpdXM7XG4gICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoLTFdID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb3NpdGlvbnNbKGkrMSkqMl0gPSB4O1xuICAgICAgICAgICAgcG9zaXRpb25zWyhpKzEpKjIrMV0gPSB5O1xuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHJvdGF0aW9uXG4gICAgICAgICAgICBjb25zdCB0ID0geDtcbiAgICAgICAgICAgIHggPSBjICogeCAtIHMgKiB5O1xuICAgICAgICAgICAgeSA9IHMgKiB0ICsgYyAqIHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRlcnMgPSB7XG4gICAgICAgICAgICAwOiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiAnVFJJQU5HTEVfRkFOJyxcbiAgICAgICAgICAgIGNvdW50OiBwb3NpdGlvbnMubGVuZ3RoIC8gMlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IGVzcGVyLlZlcnRleEJ1ZmZlcihwb3NpdGlvbnMsIHBvaW50ZXJzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRmlsbChudW1TZWdtZW50cywgcmFkaXVzLCBvdXRsaW5lKSB7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gKDIgKiBNYXRoLlBJKSAvIG51bVNlZ21lbnRzO1xuICAgICAgICAvLyBwcmVjYWxjdWxhdGUgc2luZSBhbmQgY29zaW5lXG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIC8vIHN0YXJ0IGF0IGFuZ2xlID0gMFxuICAgICAgICBsZXQgeDAgPSAwO1xuICAgICAgICBsZXQgeTAgPSByYWRpdXMgLSAob3V0bGluZSAvIDIpO1xuICAgICAgICBsZXQgeDEgPSAwO1xuICAgICAgICBsZXQgeTEgPSByYWRpdXMgKyAob3V0bGluZSAvIDIpO1xuICAgICAgICBjb25zdCBkZWdQZXJTZWcgPSAoMzYwIC8gKG51bVNlZ21lbnRzKzEpKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSgobnVtU2VnbWVudHMgKyAxKSAqICgzICsgMykpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb3NpdGlvbnNbaSo2XSA9IHgwO1xuICAgICAgICAgICAgcG9zaXRpb25zW2kqNisxXSA9IHkwO1xuICAgICAgICAgICAgcG9zaXRpb25zW2kqNisyXSA9IGkgKiBkZWdQZXJTZWc7XG4gICAgICAgICAgICBwb3NpdGlvbnNbaSo2KzNdID0geDE7XG4gICAgICAgICAgICBwb3NpdGlvbnNbaSo2KzRdID0geTE7XG4gICAgICAgICAgICBwb3NpdGlvbnNbaSo2KzVdID0gaSAqIGRlZ1BlclNlZztcbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSByb3RhdGlvblxuICAgICAgICAgICAgbGV0IHQgPSB4MDtcbiAgICAgICAgICAgIHgwID0gYyAqIHgwIC0gcyAqIHkwO1xuICAgICAgICAgICAgeTAgPSBzICogdCArIGMgKiB5MDtcbiAgICAgICAgICAgIHQgPSB4MTtcbiAgICAgICAgICAgIHgxID0gYyAqIHgxIC0gcyAqIHkxO1xuICAgICAgICAgICAgeTEgPSBzICogdCArIGMgKiB5MTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludGVycyA9IHtcbiAgICAgICAgICAgIDA6IHtcbiAgICAgICAgICAgICAgICBzaXplOiAzLCAvLyB4LCB5LCBkZWdyZWVcbiAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiAnVFJJQU5HTEVfU1RSSVAnLFxuICAgICAgICAgICAgY291bnQ6IHBvc2l0aW9ucy5sZW5ndGggLyAzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKHBvc2l0aW9ucywgcG9pbnRlcnMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1YWRUZXh0dXJlZChzaXplKSB7XG4gICAgICAgIC8vIHF1YWQgdmVydGljZXNcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uc1xuICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgIHNpemUsIDAsXG4gICAgICAgICAgICBzaXplLCBzaXplLFxuICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgIHNpemUsIHNpemUsXG4gICAgICAgICAgICAwLCBzaXplLFxuICAgICAgICAgICAgLy8gdXZzXG4gICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgMSwgMSxcbiAgICAgICAgICAgIDAsIDFcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIHF1YWQgYnVmZmVyXG4gICAgICAgIHJldHVybiBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgdmVydGljZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgMDoge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGTE9BVCcsXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IDIgKiA2ICogNFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY291bnQ6IDYsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWFkRmlsbChsZWZ0LCByaWdodCwgYm90dG9tLCB0b3ApIHtcbiAgICAgICAgLy8gcXVhZCB2ZXJ0aWNlc1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgLy8gcG9zaXRpb25zXG4gICAgICAgICAgICBsZWZ0LCBib3R0b20sXG4gICAgICAgICAgICByaWdodCwgYm90dG9tLFxuICAgICAgICAgICAgcmlnaHQsIHRvcCxcbiAgICAgICAgICAgIGxlZnQsIGJvdHRvbSxcbiAgICAgICAgICAgIHJpZ2h0LCB0b3AsXG4gICAgICAgICAgICBsZWZ0LCB0b3BcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIHF1YWQgYnVmZmVyXG4gICAgICAgIHJldHVybiBuZXcgZXNwZXIuVmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgdmVydGljZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgMDoge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRkxPQVQnLFxuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb3VudDogNixcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIGNpcmNsZToge1xuICAgICAgICAgICAgZmlsbDogY2lyY2xlRmlsbCxcbiAgICAgICAgICAgIG91dGxpbmU6IGNpcmNsZU91dGxpbmVcbiAgICAgICAgfSxcblxuICAgICAgICBxdWFkOiB7XG4gICAgICAgICAgICB0ZXh0dXJlZDogcXVhZFRleHR1cmVkLFxuICAgICAgICAgICAgZmlsbDogcXVhZEZpbGxcbiAgICAgICAgfSxcblxuICAgICAgICByaW5nOiB7XG4gICAgICAgICAgICBmaWxsOiByaW5nRmlsbFxuICAgICAgICB9XG5cbiAgICB9O1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgZXNwZXIgPSByZXF1aXJlKCdlc3BlcicpO1xuXG4gICAgY29uc3QgVElMRV9TSVpFID0gMjU2O1xuICAgIGNvbnN0IEhPUklaT05UQUxfVElMRVMgPSAxNjtcbiAgICBjb25zdCBWRVJUSUNBTF9USUxFUyA9IDg7XG5cbiAgICBjbGFzcyBUZXh0dXJlQXRsYXMge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLy8gbWVnYSB0ZXh0dXJlIGZvciBhbGwgdGlsZXNcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBlc3Blci5UZXh0dXJlMkQoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBUSUxFX1NJWkUgKiBIT1JJWk9OVEFMX1RJTEVTLFxuICAgICAgICAgICAgICAgIGhlaWdodDogVElMRV9TSVpFICogVkVSVElDQUxfVElMRVMsXG4gICAgICAgICAgICAgICAgc3JjOiBudWxsLFxuICAgICAgICAgICAgICAgIG1pcE1hcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnUkdCQScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1VOU0lHTkVEX0JZVEUnLFxuICAgICAgICAgICAgICAgIHdyYXA6ICdDTEFNUF9UT19FREdFJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6ICdORUFSRVNUJyxcbiAgICAgICAgICAgICAgICBpbnZlcnRZOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGluaXQgdGhlIGNodW5rcy8vIGFsbG9jYXRlIGF2YWlsYWJsZSBjaHVua3NcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlID0gbmV3IEFycmF5KEhPUklaT05UQUxfVElMRVMqVkVSVElDQUxfVElMRVMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPEhPUklaT05UQUxfVElMRVM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxWRVJUSUNBTF9USUxFUzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlW2kqVkVSVElDQUxfVElMRVMgKyBqXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhQaXhlbE9mZnNldDogaSAqIFRJTEVfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlQaXhlbE9mZnNldDogaiAqIFRJTEVfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2T2Zmc2V0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAvIEhPUklaT05UQUxfVElMRVMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiAvIFZFUlRJQ0FMX1RJTEVTXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXZFeHRlbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51c2VkID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVGlsZShoYXNoLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdmFpbGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBhdmFpbGFibGUgY2h1bmtzIHJlbWFpbmluZyB0byBidWZmZXIgZGF0YScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdldCBhbiBhdmFpbGFibGUgY2h1bmtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XG4gICAgICAgICAgICAvLyBzZXQgY2h1bmsgcmVzb2x1dGlvbiBhbmQgZXh0ZW50c1xuICAgICAgICAgICAgY2h1bmsucmVzb2x1dGlvbiA9IE1hdGguc3FydChkYXRhLmxlbmd0aCAvIDQpO1xuICAgICAgICAgICAgY2h1bmsudXZFeHRlbnRbMF0gPSAoY2h1bmsucmVzb2x1dGlvbiAvIFRJTEVfU0laRSkgLyBIT1JJWk9OVEFMX1RJTEVTO1xuICAgICAgICAgICAgY2h1bmsudXZFeHRlbnRbMV0gPSAoY2h1bmsucmVzb2x1dGlvbiAvIFRJTEVfU0laRSkgLyBWRVJUSUNBTF9USUxFUztcbiAgICAgICAgICAgIC8vIGJ1ZmZlciB0aGUgZGF0YSBpbnRvIHRoZSBwaHlzaWNhbCBjaHVua1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmJ1ZmZlclN1YkRhdGEoXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBjaHVuay54UGl4ZWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgY2h1bmsueVBpeGVsT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNodW5rLnJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgY2h1bmsucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAvLyBmbGFnIGFzIHVzZWRcbiAgICAgICAgICAgIHRoaXMudXNlZC5zZXQoaGFzaCwgY2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlVGlsZShoYXNoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMudXNlZC5nZXQoaGFzaCk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB1c2VkXG4gICAgICAgICAgICB0aGlzLnVzZWQuZGVsZXRlKGhhc2gpO1xuICAgICAgICAgICAgLy8gYWRkIGFzIGEgbmV3IGF2YWlsYWJsZSBjaHVua1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGUucHVzaChjaHVuayk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgICAgICB0aGlzLnVzZWQuZm9yRWFjaChmbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVBdGxhcztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IGVzcGVyID0gcmVxdWlyZSgnZXNwZXInKTtcblxuICAgIGNvbnN0IFRJTEVfU0laRSA9IDI1NjtcbiAgICBjb25zdCBNQVhfVElMRVMgPSAxMjg7XG4gICAgY29uc3QgTUFYX1BPSU5UU19QRVJfVElMRSA9IFRJTEVfU0laRSAqIFRJTEVfU0laRTtcblxuICAgIGNvbnN0IEJZVEVTX1BFUl9UWVBFID0ge1xuICAgICAgICBCWVRFOiAxLFxuICAgICAgICBVTlNJR05FRF9CWVRFOiAxLFxuICAgICAgICBTSE9SVDogMixcbiAgICAgICAgVU5TSUdORURfU0hPUlQ6IDIsXG4gICAgICAgIEZJWEVEOiA0LFxuICAgICAgICBGTE9BVDogNFxuICAgIH07XG5cbiAgICBjb25zdCBjYWxjQ2h1bmtCeXRlU2l6ZSA9IGZ1bmN0aW9uKHBvaW50ZXJzLCBjaHVua1NpemUpIHtcbiAgICAgICAgbGV0IGJ5dGVTaXplID0gMDtcbiAgICAgICAgcG9pbnRlcnMuZm9yRWFjaChwb2ludGVyID0+IHtcbiAgICAgICAgICAgIGJ5dGVTaXplICs9IEJZVEVTX1BFUl9UWVBFW3BvaW50ZXIudHlwZV0gKiBwb2ludGVyLnNpemUgKiBjaHVua1NpemU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnl0ZVNpemU7XG4gICAgfTtcblxuICAgIGNvbnN0IGNhbGNCeXRlT2Zmc2V0cyA9IGZ1bmN0aW9uKGNodW5rLCBwb2ludGVycywgY2h1bmtCeXRlT2Zmc2V0KSB7XG4gICAgICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgcG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgbG9jYXRpb24pID0+IHtcbiAgICAgICAgICAgIGNodW5rLmJ5dGVPZmZzZXRzW2xvY2F0aW9uXSA9IGNodW5rQnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBieXRlT2Zmc2V0ICs9IEJZVEVTX1BFUl9UWVBFW3BvaW50ZXIudHlwZV0gKiBwb2ludGVyLnNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICBjaHVuay5ieXRlU3RyaWRlID0gYnl0ZU9mZnNldDtcbiAgICB9O1xuXG4gICAgY2xhc3MgVmVydGV4QXRsYXMge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwb2ludGVycykge1xuICAgICAgICAgICAgLy8gZ2V0IGNvbnRleHRcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IGVzcGVyLldlYkdMQ29udGV4dC5nZXQoKTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZXh0ZW5zaW9uIGZvciBoYXJkd2FyZSBpbnN0YW5jaW5nXG4gICAgICAgICAgICB0aGlzLmV4dCA9IGVzcGVyLldlYkdMQ29udGV4dC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBXZWJHTCBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm51bUNodW5rcyA9IE1BWF9USUxFUztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTaXplID0gTUFYX1BPSU5UU19QRVJfVElMRTtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgcG9pbnRlcnMgb2YgdGhlIGF0bGFzXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgXy5mb3JJbihwb2ludGVycywgKHBvaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycy5zZXQoaW5kZXgsIHBvaW50ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYXZhaWxhYmxlIGNodW5rc1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGUgPSBuZXcgQXJyYXkodGhpcy5udW1DaHVua3MpO1xuICAgICAgICAgICAgLy8gY2FsYyB0aGUgY2h1bmsgYnl0ZSBzaXplXG4gICAgICAgICAgICBjb25zdCBjaHVua0J5dGVTaXplID0gY2FsY0NodW5rQnl0ZVNpemUoXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycyxcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBjaHVua1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMubnVtQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua0J5dGVPZmZzZXQgPSBpICogY2h1bmtCeXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBjaHVua0J5dGVPZmZzZXQ6IGNodW5rQnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBieXRlU3RyaWRlOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgaW50ZXJsZWF2ZWQgb2Zmc2V0cyAvIHN0cmlkZSwgdGhpcyBvbmx5IG5lZWRzXG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgZG9uZSBvbmNlXG4gICAgICAgICAgICAgICAgY2FsY0J5dGVPZmZzZXRzKFxuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rQnl0ZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGNodW5rXG4gICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVbaV0gPSBhdmFpbGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVzZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYnVmZmVyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgLy8gY2FsYyB0b3RhbCBzaXplIG9mIHRoZSBidWZmZXJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTaXplID0gY2h1bmtCeXRlU2l6ZSAqIHRoaXMubnVtQ2h1bmtzO1xuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ5dGVTaXplLCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRpbGUoa2V5LCBkYXRhLCBjb3VudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXZhaWxhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gYXZhaWxhYmxlIGNodW5rcyByZW1haW5pbmcgdG8gYnVmZmVyIGRhdGEnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXZhaWxhYmxlIGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuYXZhaWxhYmxlLnBvcCgpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGNodW5rIGNvdW50XG4gICAgICAgICAgICBjaHVuay5jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgLy8gYnVmZmVyIHRoZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIGNodW5rLmNodW5rQnl0ZU9mZnNldCwgZGF0YSk7XG4gICAgICAgICAgICAvLyBhZGQgdG8gdXNlZFxuICAgICAgICAgICAgdGhpcy51c2VkLnNldChrZXksIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUaWxlKGtleSkge1xuICAgICAgICAgICAgLy8gZ2V0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMudXNlZC5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHVzZWRcbiAgICAgICAgICAgIHRoaXMudXNlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIC8vIGFkZCB0byBhdmFpbGFibGVcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYmluZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZXh0O1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBlbmFibGUgaW5zdGFuY2luZyB0aGlzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB1bmJpbmQoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBjb25zdCBleHQgPSB0aGlzLmV4dDtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgYXR0cmlidXRlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgaW5zdGFuY2luZyB0aGlzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaW5kZXgsIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgICAgICB0aGlzLnVzZWQuZm9yRWFjaChmbik7XG4gICAgICAgIH1cbiAgICAgICAgZHJhdyhrZXksIG1vZGUsIGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBjb25zdCBleHQgPSB0aGlzLmV4dDtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy51c2VkLmdldChrZXkpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggYXR0cmlidXRlIHBvaW50ZXJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgYXR0cmlidXRlIHBvaW50ZXJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5zaXplLFxuICAgICAgICAgICAgICAgICAgICBnbFtwb2ludGVyLnR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuYnl0ZVN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuYnl0ZU9mZnNldHNbaW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZHJhdyB0aGUgYm91bmQgdmVydGV4IGFycmF5XG4gICAgICAgICAgICBleHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGdsW21vZGVdLCAwLCBjb3VudCwgY2h1bmsuY291bnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhBdGxhcztcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IFJlcXVlc3RvciA9IHJlcXVpcmUoJy4vUmVxdWVzdG9yJyk7XG5cbiAgICBjbGFzcyBNZXRhUmVxdWVzdG9yIGV4dGVuZHMgUmVxdWVzdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IodXJsLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgc3VwZXIodXJsLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SGFzaChyZXEpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtyZXEudHlwZX0tJHtyZXEudXJpfS0ke3JlcS5zdG9yZX1gO1xuICAgICAgICB9XG4gICAgICAgIGdldFVSTChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBgbWV0YS8ke3Jlcy50eXBlfS8ke3Jlcy5lbmRwb2ludH0vJHtyZXMudXJpfS8ke3Jlcy5zdG9yZX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNZXRhUmVxdWVzdG9yO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgUkVUUllfSU5URVJWQUwgPSA1MDAwO1xuXG4gICAgZnVuY3Rpb24gZ2V0SG9zdCgpIHtcbiAgICAgICAgY29uc3QgbG9jID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICBjb25zdCBuZXdfdXJpID0gKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJ3dzczonIDogJ3dzOic7XG4gICAgICAgIHJldHVybiBgJHtuZXdfdXJpfS8vJHtsb2MuaG9zdH0ke2xvYy5wYXRobmFtZX1gO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzdGFibGlzaENvbm5lY3Rpb24ocmVxdWVzdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXF1ZXN0b3Iuc29ja2V0ID0gbmV3IFdlYlNvY2tldChnZXRIb3N0KCkgKyByZXF1ZXN0b3IudXJsKTtcbiAgICAgICAgLy8gb24gb3BlblxuICAgICAgICByZXF1ZXN0b3Iuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVxdWVzdG9yLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2Vic29ja2V0IGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIG9uIG1lc3NhZ2VcbiAgICAgICAgcmVxdWVzdG9yLnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSByZXF1ZXN0b3IuZ2V0SGFzaChyZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3Rvci5yZXF1ZXN0c1toYXNoXTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0b3IucmVxdWVzdHNbaGFzaF07XG4gICAgICAgICAgICBpZiAocmVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdG9yLmdldFVSTChyZXMpLCByZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBvbiBjbG9zZVxuICAgICAgICByZXF1ZXN0b3Iuc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGxvZyBjbG9zZSBvbmx5IGlmIGNvbm5lY3Rpb24gd2FzIGV2ZXIgb3BlblxuICAgICAgICAgICAgaWYgKHJlcXVlc3Rvci5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCwgYXR0ZW1wdGluZyB0byByZS1jb25uZWN0IGluJywgUkVUUllfSU5URVJWQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdG9yLnNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICByZXF1ZXN0b3IuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZWplY3QgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlcXVlc3Rvci5yZXF1ZXN0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0b3IucmVxdWVzdHNba2V5XS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY2xlYXIgcmVxdWVzdCBtYXBcbiAgICAgICAgICAgIHJlcXVlc3Rvci5yZXF1ZXN0cyA9IHt9O1xuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlc3RhYmxpc2hDb25uZWN0aW9uKHJlcXVlc3RvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uY2UgY29ubmVjdGlvbiBpcyByZS1lc3RhYmxpc2hlZCwgc2VuZCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rvci5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24ocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0b3IuZ2V0KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0b3IucGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgUkVUUllfSU5URVJWQUwpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzIFJlcXVlc3RvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gW107XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgZXN0YWJsaXNoQ29ubmVjdGlvbih0aGlzLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SGFzaCgpIHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIH1cbiAgICAgICAgZ2V0VVJMKCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgfVxuICAgICAgICBnZXQocmVxKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gY29ubmVjdGlvbiwgYWRkIHJlcXVlc3QgdG8gcGVuZGluZyBxdWV1ZVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuZ2V0SGFzaChyZXEpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5wcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c1toYXNoXSA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkocmVxKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RvcjtcblxufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpO1xuICAgIGNvbnN0IFJlcXVlc3RvciA9IHJlcXVpcmUoJy4vUmVxdWVzdG9yJyk7XG5cbiAgICBmdW5jdGlvbiBwcnVuZUVtcHR5KG9iaikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHJ1bmUoY3VycmVudCkge1xuICAgICAgICAgICAgXy5mb3JPd24oY3VycmVudCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IF8uaXNOdWxsKHZhbHVlKSB8fCBfLmlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChfLmlzU3RyaW5nKHZhbHVlKSAmJiBfLmlzRW1wdHkodmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIChfLmlzT2JqZWN0KHZhbHVlKSAmJiBfLmlzRW1wdHkocHJ1bmUodmFsdWUpKSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgbGVmdG92ZXIgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSBkZWxldGVcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBvbiBhbiBhcnJheVxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIF8ucHVsbChjdXJyZW50LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH0oXy5jbG9uZURlZXAob2JqKSk7IC8vIGRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIG9iamVjdCwgY3JlYXRlIGEgY2xvbmUgaW5zdGVhZFxuICAgIH1cblxuICAgIGNsYXNzIFRpbGVSZXF1ZXN0b3IgZXh0ZW5kcyBSZXF1ZXN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdXBlcih1cmwsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRIYXNoKHJlcSkge1xuICAgICAgICAgICAgY29uc3QgY29vcmQgPSByZXEuY29vcmQ7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gc3RyaW5naWZ5KHBydW5lRW1wdHkocmVxLnBhcmFtcykpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3JlcS50eXBlfS0ke3JlcS51cml9LSR7cmVxLnN0b3JlfS0ke2Nvb3JkLnp9LSR7Y29vcmQueH0tJHtjb29yZC55fS0ke2hhc2h9YDtcbiAgICAgICAgfVxuICAgICAgICBnZXRVUkwocmVzKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZCA9IHJlcy5jb29yZDtcbiAgICAgICAgICAgIHJldHVybiBgdGlsZS8ke3Jlcy50eXBlfS8ke3Jlcy51cml9LyR7cmVzLnN0b3JlfS8ke2Nvb3JkLnp9LyR7Y29vcmQueH0vJHtjb29yZC55fWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRpbGVSZXF1ZXN0b3I7XG5cbn0oKSk7XG4iXX0=
